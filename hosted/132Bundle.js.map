{"version":3,"file":"132Bundle.js","mappings":"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","sources":["webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs","webpack://Project2/./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/types.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/Filter.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { BufferUsage } from './const.mjs';\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /** @internal */\n    this._updateID = 1;\n    this._dataInt32 = null;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size ?? (size = data?.byteLength);\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  get dataInt32() {\n    if (!this._dataInt32) {\n      this._dataInt32 = new Int32Array(this.data.buffer);\n    }\n    return this._dataInt32;\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    this._dataInt32 = null;\n    if (!oldData || oldData.length !== value.length) {\n      if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { Buffer };\n//# sourceMappingURL=Buffer.mjs.map\n","\"use strict\";\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n  BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n  BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n  BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n  BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n  BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n  BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n  BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n  BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n  BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n  BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n  return BufferUsage2;\n})(BufferUsage || {});\n\nexport { BufferUsage };\n//# sourceMappingURL=const.mjs.map\n","\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this.uint32View = null;\n    this.float32View = null;\n    this.uint16View = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this._int32View = null;\n    this._float64Array = null;\n    this._bigUint64Array = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexport { ViewableBuffer };\n//# sourceMappingURL=ViewableBuffer.mjs.map\n","\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"INVERSE_MASK_ACTIVE\"] = 3] = \"INVERSE_MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 4] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 5] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexport { BLEND_TO_NPM, STENCIL_MODES };\n//# sourceMappingURL=const.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexport { extractAttributesFromGpuProgram };\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n","\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexport { extractStructAndGroups };\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n","\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexport { ShaderStage };\n//# sourceMappingURL=const.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /** @internal */\n    this._layoutKey = 0;\n    /** @internal */\n    this._attributeLocationsKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n    programCache[this._cacheKey] = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n      programCache[key]._cacheKey = key;\n    }\n    return programCache[key];\n  }\n}\n\nexport { GpuProgram };\n//# sourceMappingURL=GpuProgram.mjs.map\n","\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexport { removeStructAndGroupDuplicates };\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n","\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexport { generateLayoutHash };\n//# sourceMappingURL=generateLayoutHash.mjs.map\n","import { ShaderStage } from '../../../shared/shader/const.mjs';\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexport { generateGpuLayoutGroups };\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n","\"use strict\";\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource?.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\nexport { BindGroup };\n//# sourceMappingURL=BindGroup.mjs.map\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext.mjs';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader.mjs';\n\n\"use strict\";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache)\n    return maxTexturesPerBatchCache;\n  const gl = getTestContext();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n  return maxTexturesPerBatchCache;\n}\n\nexport { getMaxTexturesPerBatch };\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n","\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexport { BatchTextureArray };\n//# sourceMappingURL=BatchTextureArray.mjs.map\n","import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { GlobalResourceRegistry } from '../../../utils/pool/GlobalResourceRegistry.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = \"normal\";\n    this.topology = \"triangle-strip\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nGlobalResourceRegistry.register({\n  clear: () => {\n    if (batchPool.length > 0) {\n      for (const item of batchPool) {\n        if (item)\n          item.destroy();\n      }\n    }\n    batchPool.length = 0;\n    batchPoolIndex = 0;\n  }\n});\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options) {\n    /** unique id for this batcher */\n    this.uid = uid(\"batcher\");\n    /** Indicates whether the batch data has been modified and needs updating. */\n    this.dirty = true;\n    /** The current index of the batch being processed. */\n    this.batchIndex = 0;\n    /** An array of all batches created during the current rendering process. */\n    this.batches = [];\n    this._elements = [];\n    options = { ..._Batcher.defaultOptions, ...options };\n    if (!options.maxTextures) {\n      deprecation(\"v8.8.0\", \"maxTextures is a required option for Batcher now, please pass it in the options\");\n      options.maxTextures = getMaxTexturesPerBatch();\n    }\n    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n    this.indexBuffer = new Uint16Array(indicesInitialSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject._indexStart = this.indexSize;\n    batchableObject._attributeStart = this.attributeSize;\n    batchableObject._batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject._textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    const attributeBuffer = this.attributeBuffer;\n    if (batchableObject.packAsQuad) {\n      this.packQuadAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    } else {\n      this.packAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    }\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart])\n      return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    let topology = firstElement.topology;\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const indexBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n      if (source._batchTick === BATCH_TICK && !breakRequired) {\n        element._textureId = source._textureBindLocation;\n        size += element.indexSize;\n        if (element.packAsQuad) {\n          this.packQuadAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packQuadIndex(\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        } else {\n          this.packAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packIndex(\n            element,\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        }\n        element._batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || breakRequired) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          topology,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        topology = element.topology;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element._textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element._batch = batch;\n      size += element.indexSize;\n      if (element.packAsQuad) {\n        this.packQuadAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packQuadIndex(\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      } else {\n        this.packAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packIndex(\n          element,\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      }\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        topology,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.topology = topology;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  packQuadIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  packIndex(element, indexBuffer, index, indicesOffset) {\n    const indices = element.indices;\n    const size = element.indexSize;\n    const indexOffset = element.indexOffset;\n    const attributeOffset = element.attributeOffset;\n    for (let i = 0; i < size; i++) {\n      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n  }\n  /**\n   * Destroys the batch and its resources.\n   * @param options - destruction options\n   * @param options.shader - whether to destroy the associated shader\n   */\n  destroy(options = {}) {\n    if (this.batches === null)\n      return;\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    this.geometry.destroy(true);\n    this.geometry = null;\n    if (options.shader) {\n      this.shader?.destroy();\n      this.shader = null;\n    }\n    for (let i = 0; i < this._elements.length; i++) {\n      if (this._elements[i])\n        this._elements[i]._batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  maxTextures: null,\n  attributesInitialSize: 4,\n  indicesInitialSize: 6\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n//# sourceMappingURL=Batcher.mjs.map\n","import { Buffer } from '../../renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry.mjs';\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexport { BatchGeometry };\n//# sourceMappingURL=BatchGeometry.mjs.map\n","import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram.mjs';\nimport { colorBitGl, colorBit } from '../../high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBitGl, generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBitGl, roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../renderers/shared/shader/Shader.mjs';\n\n\"use strict\";\nclass DefaultShader extends Shader {\n  constructor(maxTextures) {\n    const glProgram = compileHighShaderGlProgram({\n      name: \"batch\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        roundPixelsBitGl\n      ]\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"batch\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        roundPixelsBit\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n    this.maxTextures = maxTextures;\n  }\n}\n\nexport { DefaultShader };\n//# sourceMappingURL=DefaultShader.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Batcher } from './Batcher.mjs';\nimport { BatchGeometry } from './BatchGeometry.mjs';\nimport { DefaultShader } from './DefaultShader.mjs';\n\n\"use strict\";\nlet defaultShader = null;\nconst _DefaultBatcher = class _DefaultBatcher extends Batcher {\n  constructor(options) {\n    super(options);\n    this.geometry = new BatchGeometry();\n    this.name = _DefaultBatcher.extension.name;\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    this.vertexSize = 6;\n    defaultShader ?? (defaultShader = new DefaultShader(options.maxTextures));\n    this.shader = defaultShader;\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n   * @param element - The DefaultBatchableMeshElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packAttributes(element, float32View, uint32View, index, textureId) {\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const { positions, uvs } = element;\n    const argb = element.color;\n    const offset = element.attributeOffset;\n    const end = offset + element.attributeSize;\n    for (let i = offset; i < end; i++) {\n      const i2 = i * 2;\n      const x = positions[i2];\n      const y = positions[i2 + 1];\n      float32View[index++] = a * x + c * y + tx;\n      float32View[index++] = d * y + b * x + ty;\n      float32View[index++] = uvs[i2];\n      float32View[index++] = uvs[i2 + 1];\n      uint32View[index++] = argb;\n      uint32View[index++] = textureIdAndRound;\n    }\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n   * @param element - The DefaultBatchableQuadElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packQuadAttributes(element, float32View, uint32View, index, textureId) {\n    const texture = element.texture;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = element.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = element.color;\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  /**\n   * Updates the maximum number of textures that can be used in the shader.\n   * @param maxTextures - The maximum number of textures that can be used in the shader.\n   * @internal\n   */\n  _updateMaxTextures(maxTextures) {\n    if (this.shader.maxTextures === maxTextures)\n      return;\n    defaultShader = new DefaultShader(maxTextures);\n    this.shader = defaultShader;\n  }\n  destroy() {\n    this.shader = null;\n    super.destroy();\n  }\n};\n/** @ignore */\n_DefaultBatcher.extension = {\n  type: [\n    ExtensionType.Batcher\n  ],\n  name: \"default\"\n};\nlet DefaultBatcher = _DefaultBatcher;\n\nexport { DefaultBatcher };\n//# sourceMappingURL=DefaultBatcher.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\n\n\"use strict\";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = DOMAdapter.get().createCanvas();\n    context = canvas.getContext(\"webgl\", {});\n  }\n  return context;\n}\n\nexport { getTestContext };\n//# sourceMappingURL=getTestContext.mjs.map\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexport { RendererType };\n//# sourceMappingURL=types.mjs.map\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks };\n//# sourceMappingURL=compileHooks.mjs.map\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","\"use strict\";\nconst UNIFORM_TYPES_VALUES = [\n  \"f32\",\n  \"i32\",\n  \"vec2<f32>\",\n  \"vec3<f32>\",\n  \"vec4<f32>\",\n  \"mat2x2<f32>\",\n  \"mat3x3<f32>\",\n  \"mat4x4<f32>\",\n  \"mat3x2<f32>\",\n  \"mat4x2<f32>\",\n  \"mat2x3<f32>\",\n  \"mat4x3<f32>\",\n  \"mat2x4<f32>\",\n  \"mat3x4<f32>\",\n  \"vec2<i32>\",\n  \"vec3<i32>\",\n  \"vec4<i32>\"\n];\nconst UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {\n  acc[type] = true;\n  return acc;\n}, {});\n\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES };\n//# sourceMappingURL=types.mjs.map\n","\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { getDefaultUniformValue };\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { createIdFromString } from '../utils/createIdFromString.mjs';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './types.mjs';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue.mjs';\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"uniform\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"uniformGroup\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      if (!UNIFORM_TYPES_MAP[uniformData.type]) {\n        const arrayMatch = uniformData.type.match(/^array<(\\w+(?:<\\w+>)?),\\s*(\\d+)>$/);\n        if (arrayMatch) {\n          const [, innerType, size] = arrayMatch;\n          throw new Error(\n            `Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`\n          );\n        }\n        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(\", \")}`);\n      }\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexport { UniformGroup };\n//# sourceMappingURL=UniformGroup.mjs.map\n","import { Buffer } from '../../buffer/Buffer.mjs';\nimport { BufferUsage } from '../../buffer/const.mjs';\n\n\"use strict\";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer)) {\n    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n      }\n    }\n    buffer = new Buffer({\n      data: buffer,\n      label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n      usage\n    });\n  }\n  return buffer;\n}\n\nexport { ensureIsBuffer };\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer.mjs';\nimport { getGeometryBounds } from './utils/getGeometryBounds.mjs';\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options = {}) {\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    const { attributes, indexBuffer, topology } = options;\n    this.buffers = [];\n    this.attributes = {};\n    if (attributes) {\n      for (const i in attributes) {\n        this.addAttribute(i, attributes[i]);\n      }\n    }\n    this.instanceCount = options.instanceCount ?? 1;\n    if (indexBuffer) {\n      this.addIndex(indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /**\n   * Adds an attribute to the geometry.\n   * @param name - The name of the attribute to add.\n   * @param attributeOption - The attribute option to add.\n   */\n  addAttribute(name, attributeOption) {\n    const attribute = ensureIsAttribute(attributeOption);\n    const bufferIndex = this.buffers.indexOf(attribute.buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(attribute.buffer);\n      attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n      attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n    }\n    this.attributes[name] = attribute;\n  }\n  /**\n   * Adds an index buffer to the geometry.\n   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n   */\n  addIndex(indexBuffer) {\n    this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n    this.buffers.push(this.indexBuffer);\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.indexBuffer?.destroy();\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexport { Geometry };\n//# sourceMappingURL=Geometry.mjs.map\n","\"use strict\";\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\nexport { getGeometryBounds };\n//# sourceMappingURL=getGeometryBounds.mjs.map\n","import { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup)\n    return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\nexport { getBatchSamplersUniformGroup };\n//# sourceMappingURL=getBatchSamplersUniformGroup.mjs.map\n","\"use strict\";\nconst fragTemplate = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(\"\\n\");\nfunction generateIfTestSrc(maxIfs) {\n  let src = \"\";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += \"\\nelse \";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  try {\n    while (true) {\n      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n      gl.shaderSource(shader, fragmentSrc);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        maxIfs = maxIfs / 2 | 0;\n      } else {\n        break;\n      }\n    }\n  } finally {\n    gl.deleteShader(shader);\n  }\n  return maxIfs;\n}\n\nexport { checkMaxIfStatementsInShader };\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n    if (options.blendRequired) {\n      this.addResource(\"uBackTexture\", 0, 3);\n    }\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/** The default filter settings */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\nexport { fastCopy };\n//# sourceMappingURL=fastCopy.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexport { createIdFromString };\n//# sourceMappingURL=createIdFromString.mjs.map\n","\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexport { getAttributeInfoFromFormat };\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /** A unique identifier for the shader */\n    this.uid = uid(\"shader\");\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    /** @internal */\n    this._destroyed = false;\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      groups = {};\n      groupMap = {};\n      if (gpuProgram) {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      let bindTick = 0;\n      for (const i in resources) {\n        if (nameHash[i])\n          continue;\n        if (!groups[99]) {\n          groups[99] = new BindGroup();\n          this._ownedBindGroups.push(groups[99]);\n        }\n        nameHash[i] = { group: 99, binding: bindTick, name: i };\n        groupMap[99] = groupMap[99] || {};\n        groupMap[99][bindTick] = i;\n        bindTick++;\n      }\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    if (this._destroyed)\n      return;\n    this._destroyed = true;\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n","import { BLEND_TO_NPM } from './const.mjs';\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexport { getAdjustedBlendModeBlend };\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n","import { getTestContext } from './getTestContext.mjs';\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexport { getMaxFragmentPrecision };\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n","\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexport { setProgramName };\n//# sourceMappingURL=setProgramName.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n    programCache[this._cacheKey] = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n      programCache[key]._cacheKey = key;\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexport { GlProgram };\n//# sourceMappingURL=GlProgram.mjs.map\n","\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexport { stripVersion };\n//# sourceMappingURL=stripVersion.mjs.map\n","\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexport { ensurePrecision };\n//# sourceMappingURL=ensurePrecision.mjs.map\n","\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexport { addProgramDefines };\n//# sourceMappingURL=addProgramDefines.mjs.map\n","\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexport { insertVersion };\n//# sourceMappingURL=insertVersion.mjs.map\n"],"names":["Buffer","constructor","options","data","size","usage","label","shrinkToFit","super","this","uid","_resourceType","_resourceId","_touched","_updateID","_dataInt32","destroyed","Array","Float32Array","_data","byteLength","mappedAtCreation","descriptor","value","setDataWithSize","length","dataInt32","Int32Array","buffer","static","STATIC","syncGPU","_updateSize","BYTES_PER_ELEMENT","emit","oldData","update","sizeInBytes","destroy","removeAllListeners","BufferUsage","BufferUsage2","ViewableBuffer","sizeOrBuffer","rawBinaryData","ArrayBuffer","Uint8Array","uint32View","Uint32Array","float32View","int8View","_int8View","Int8Array","uint8View","_uint8View","int16View","_int16View","Int16Array","int32View","_int32View","float64View","_float64Array","Float64Array","bigUint64View","_bigUint64Array","BigUint64Array","view","type","uint16View","sizeOf","Error","BLEND_TO_NPM","normal","add","screen","STENCIL_MODES","STENCIL_MODES2","localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","color32BitToUniform","abgr","out","offset","alpha","WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","extractStructAndGroups","wgsl","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","groups","match","map","item","group","parseInt","binding","isUniform","structs","struct","members","reduce","acc","member","name2","split","trim","filter","some","ShaderStage","ShaderStage2","programCache","Object","create","GpuProgram","_layoutKey","_attributeLocationsKey","fragment","layout","gpuLayout","source","structsAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","Set","dupeGroupKeySet","has","key","removeStructAndGroupDuplicates","i","generateLayoutHash","push","visibility","VERTEX","FRAGMENT","sampler","texture","sampleType","viewDimension","multisampled","generateGpuLayoutGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","entryPoint","createIdFromString","attributeData","_attributeData","results","mainVertStart","indexOf","arrowFunctionStart","functionArgsSubstring","substring","inputsRegex","exec","format","location","stride","getAttributeInfoFromFormat","instance","start","extractAttributesFromGpuProgram","_cacheKey","from","BindGroup","resources","_dirty","index","resource","setResource","_updateKey","keyParts","_key","join","currentResource","off","onResourceChange","on","getResource","_touch","tick","maxTexturesPerBatchCache","BatchTextureArray","ids","textures","count","clear","t","Batch","renderPipeId","action","blendMode","topology","canBundle","gpuBindGroup","bindGroup","batcher","batchPool","batchPoolIndex","getBatchFromPool","returnBatchToPool","batch","GlobalResourceRegistry","register","BATCH_TICK","_Batcher","dirty","batchIndex","batches","_elements","defaultOptions","maxTextures","deprecation","gl","getTestContext","getParameter","MAX_TEXTURE_IMAGE_UNITS","checkMaxIfStatementsInShader","getExtension","loseContext","getMaxTexturesPerBatch","attributesInitialSize","indicesInitialSize","attributeBuffer","indexBuffer","Uint16Array","begin","elementSize","elementStart","indexSize","attributeSize","_batchIndexStart","_batchIndexSize","batchableObject","_indexStart","_attributeStart","_batcher","vertexSize","checkAndUpdateTexture","textureId","_batch","_source","_textureId","updateElement","packAsQuad","packQuadAttributes","packAttributes","instructionSet","elements","textureBatch","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","_resizeIndexBuffer","element","adjustedBlendMode","breakRequired","_batchTick","_finishBatch","_textureBindLocation","packQuadIndex","packIndex","indexStart","finish","break","ensureAttributeBuffer","ensureIndexBuffer","newSize","Math","max","newArrayBuffer","fastCopy","newIndexBuffer","indicesOffset","indices","indexOffset","attributeOffset","geometry","shader","Batcher","placeHolderBufferData","placeHolderIndexData","BatchGeometry","Geometry","COPY_DST","attributes","aPosition","aUV","aColor","aTextureIdAndRound","INDEX","DefaultShader","Shader","glProgram","bits","colorBit","generateTextureBatchBit","roundPixelsBit","gpuProgram","batchSamplers","getBatchSamplersUniformGroup","defaultShader","_DefaultBatcher","extension","textureIdAndRound","roundPixels","wt","transform","a","b","c","d","tx","ty","positions","uvs","argb","color","i2","x","y","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","x0","y0","x1","y1","x2","y2","x3","y3","_updateMaxTextures","DefaultBatcher","context","isContextLost","canvas","get","createCanvas","getContext","textureBatchBitGpuCache","generateBindingSrc","src","bindingIndex","generateSampleSrc","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","colorBitGl","RendererType","RendererType2","addBits","srcParts","parts","part","toLocaleLowerCase","sanitisedPart","warn","findHooksRx","compileHooks","programSrc","hook","forEach","extractInputs","fragmentSource","regex","compileInputs","fragments","template","sort","mainInput","finalString","inValue","cleanedString","extractOutputs","injectBits","templateSrc","fragmentParts","cacheMap","bitCacheMap","Map","CACHE_UID","compileHighShaderGl","cacheId","generateCacheId","compileBits","highFragment","set","vertexParts","shaderBit","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","vertexFragments","v","fragmentFragments","compiledVertex","mainStruct","mainStart","mainEnd","extractVariableName","compiledCode","compileOutputs","compileInputsAndOutputs","compileHighShader","compileHighShaderGlProgram","GlProgram","UNIFORM_TYPES_VALUES","UNIFORM_TYPES_MAP","getDefaultUniformValue","_UniformGroup","uniformStructures","isUniformGroup","_dirtyId","uniforms","uniformData","arrayMatch","innerType","ubo","isStatic","_signature","keys","UniformGroup","ensureIsBuffer","instanceCount","_bounds","Bounds","_boundsDirty","buffers","addAttribute","addIndex","onBufferUpdate","getAttribute","id","getIndex","getBuffer","getSize","attribute","attributeOption","isArray","ensureIsAttribute","attributeId","Infinity","byteSize","getGeometryBounds","destroyBuffers","batchSamplersUniformGroupHash","batchSamplersUniformGroup","sampleValues","uTextures","fragTemplate","generateIfTestSrc","maxIfs","createShader","FRAGMENT_SHADER","fragmentSrc","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","_Filter","enabled","_state","for2d","padding","antialias","resolution","blendRequired","clipToViewport","addResource","apply","filterManager","input","output","clearMode","applyFilter","gpu","rest","Filter","roundPixelsBitGl","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","remainingBytes","sourceUint8View","blendModeIds","multiply","overlay","erase","min","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","state","default2d","State","idCounts","idHash","groupId","attributeFormatData","uint8x2","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","BatchableSprite","batcherName","renderable","groupBlendMode","groupColorAlpha","reset","_uniformBindMap","_ownedBindGroups","_destroyed","compatibleRenderers","groupMap","WEBGPU","WEBGL","nameHash","j","uniformName","groupData","bindTick","_buildResourceAccessor","groupIndex","bindIndex","_a","_b","uniformsOut","defineProperty","destroyPrograms","textureSource","alphaMode","maxFragmentPrecision","getMaxFragmentPrecision","getShaderPrecisionFormat","shaderFragment","HIGH_FLOAT","precision","fragmentNameCache","VertexNameCache","processes","stripVersion","isES300","ensurePrecision","isFragment","maxSupportedPrecision","maxSupportedFragmentPrecision","maxSupportedVertexPrecision","requestedFragmentPrecision","requestedVertexPrecision","addProgramDefines","setProgramName","nameCache","insertVersion","_GlProgram","preprocessorOptions","preferredFragmentPrecision","preferredVertexPrecision","processKey","processOptions","transformFeedbackVaryings","_uniformData","_uniformBlockData"],"sourceRoot":""}