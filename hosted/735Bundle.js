/*! For license information please see 735Bundle.js.LICENSE.txt */
(self.webpackChunkProject2=self.webpackChunkProject2||[]).push([[735],{949:(t,e,r)=>{"use strict";r.d(e,{h:()=>o});var i=r(4486),n=r(133),s=r(1132);class o extends i.A{constructor(t){let{data:e,size:r}=t;const{usage:i,label:s,shrinkToFit:o}=t;super(),this.uid=(0,n.L)("buffer"),this._resourceType="buffer",this._resourceId=(0,n.L)("resource"),this._touched=0,this._updateID=1,this._dataInt32=null,this.shrinkToFit=!0,this.destroyed=!1,e instanceof Array&&(e=new Float32Array(e)),this._data=e,r??(r=e?.byteLength);const a=!!e;this.descriptor={size:r,usage:i,mappedAtCreation:a,label:s},this.shrinkToFit=o??!0}get data(){return this._data}set data(t){this.setDataWithSize(t,t.length,!0)}get dataInt32(){return this._dataInt32||(this._dataInt32=new Int32Array(this.data.buffer)),this._dataInt32}get static(){return!!(this.descriptor.usage&s.S.STATIC)}set static(t){t?this.descriptor.usage|=s.S.STATIC:this.descriptor.usage&=~s.S.STATIC}setDataWithSize(t,e,r){if(this._updateID++,this._updateSize=e*t.BYTES_PER_ELEMENT,this._data===t)return void(r&&this.emit("update",this));const i=this._data;this._data=t,this._dataInt32=null,i&&i.length===t.length||!this.shrinkToFit&&i&&t.byteLength<i.byteLength?r&&this.emit("update",this):(this.descriptor.size=t.byteLength,this._resourceId=(0,n.L)("resource"),this.emit("change",this))}update(t){this._updateSize=t??this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}},990:(t,e,r)=>{"use strict";r.d(e,{T:()=>d,w:()=>c});var i=r(2577),n=r(7174),s=r(7276),o=r(2806);function a(t){return t instanceof o.m}function l(t){return t instanceof s._}function h(t,e,r){return t.fill=e,t.color=16777215,t.texture=e.texture,t.matrix=e.transform,{...r,...t}}function u(t,e,r){return e.buildGradient(),t.fill=e,t.color=16777215,t.texture=e.texture,t.matrix=e.transform,t.textureSpace=e.textureSpace,{...r,...t}}function c(t,e){if(null==t)return null;const r={},s=t;return function(t){return i.Q.isColorLike(t)}(t)?function(t,e,r){const s=i.Q.shared.setValue(e??0);return t.color=s.toNumber(),t.alpha=1===s.alpha?r.alpha:s.alpha,t.texture=n.g.WHITE,{...r,...t}}(r,t,e):function(t){return t instanceof n.g}(t)?function(t,e,r){return t.texture=e,{...r,...t}}(r,t,e):a(t)?h(r,t,e):l(t)?u(r,t,e):s.fill&&a(s.fill)?h(s,s.fill,e):s.fill&&l(s.fill)?u(s,s.fill,e):function(t,e){const r={...e,...t},n=i.Q.shared.setValue(r.color);return r.alpha*=n.alpha,r.color=n.toNumber(),r}(s,e)}function d(t,e){const{width:r,alignment:i,miterLimit:n,cap:s,join:o,pixelLine:a,...l}=e,h=c(t,l);return h?{width:r,alignment:i,miterLimit:n,cap:s,join:o,pixelLine:a,...h}:null}},1132:(t,e,r)=>{"use strict";r.d(e,{S:()=>i});var i=(t=>(t[t.MAP_READ=1]="MAP_READ",t[t.MAP_WRITE=2]="MAP_WRITE",t[t.COPY_SRC=4]="COPY_SRC",t[t.COPY_DST=8]="COPY_DST",t[t.INDEX=16]="INDEX",t[t.VERTEX=32]="VERTEX",t[t.UNIFORM=64]="UNIFORM",t[t.STORAGE=128]="STORAGE",t[t.INDIRECT=256]="INDIRECT",t[t.QUERY_RESOLVE=512]="QUERY_RESOLVE",t[t.STATIC=1024]="STATIC",t))(i||{})},1242:(t,e,r)=>{"use strict";r.d(e,{Z:()=>n});const i=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function n(t){const e="number"==typeof t.fontSize?`${t.fontSize}px`:t.fontSize;let r=t.fontFamily;Array.isArray(t.fontFamily)||(r=t.fontFamily.split(","));for(let t=r.length-1;t>=0;t--){let e=r[t].trim();/([\"\'])[^\'\"]+\1/.test(e)||i.includes(e)||(e=`"${e}"`),r[t]=e}return`${t.fontStyle} ${t.fontVariant} ${t.fontWeight} ${e} ${r.join(",")}`}},1460:(t,e,r)=>{"use strict";r.d(e,{u:()=>i});class i{constructor(t){"number"==typeof t?this.rawBinaryData=new ArrayBuffer(t):t instanceof Uint8Array?this.rawBinaryData=t.buffer:this.rawBinaryData=t,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(t){return this[`${t}View`]}destroy(){this.rawBinaryData=null,this.uint32View=null,this.float32View=null,this.uint16View=null,this._int8View=null,this._uint8View=null,this._int16View=null,this._int32View=null,this._float64Array=null,this._bigUint64Array=null}static sizeOf(t){switch(t){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${t} isn't a valid view type`)}}}},2289:(t,e,r)=>{"use strict";r.d(e,{s:()=>n});var i=r(2048);function n(t,e){const{texture:r,bounds:n}=t,s=e._style._getFinalPadding();(0,i.y)(n,e._anchor,r);const o=e._anchor._x*s*2,a=e._anchor._y*s*2;n.minX-=s-o,n.minY-=s-a,n.maxX-=s-o,n.maxY-=s-a}},2331:(t,e,r)=>{"use strict";r.d(e,{i:()=>n});const i={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};function n(t,e){return"no-premultiply-alpha"===e.alphaMode&&i[t]||t}},2558:(t,e,r)=>{"use strict";r.d(e,{M:()=>s});var i=r(2437);const n=new(r(9636).c);function s(t,e,r,s){const o=n;o.minX=0,o.minY=0,o.maxX=t.width/s|0,o.maxY=t.height/s|0;const a=i.W.getOptimalTexture(o.width,o.height,s,!1);return a.source.uploadMethodId="image",a.source.resource=t,a.source.alphaMode="premultiply-alpha-on-upload",a.frame.width=e/s,a.frame.height=r/s,a.source.emit("update",a.source),a.updateUvs(),a}},2623:(t,e,r)=>{"use strict";var i=r(8507),n=r(7174),s=r(2289),o=r(8422);class a extends o.K{constructor(t){super(),this.generatingTexture=!1,this.currentKey="--",this._renderer=t,t.runners.resolutionChange.add(this)}resolutionChange(){const t=this.renderable;t._autoResolution&&t.onViewUpdate()}destroy(){const{htmlText:t}=this._renderer;null===t.getReferenceCount(this.currentKey)?t.returnTexturePromise(this.texturePromise):t.decreaseReferenceCount(this.currentKey),this._renderer.runners.resolutionChange.remove(this),this.texturePromise=null,this._renderer=null}}class l{constructor(t){this._renderer=t}validateRenderable(t){const e=this._getGpuText(t),r=t.styleKey;return e.currentKey!==r}addRenderable(t,e){const r=this._getGpuText(t);if(t._didTextUpdate){const e=t._autoResolution?this._renderer.resolution:t.resolution;r.currentKey===t.styleKey&&t.resolution===e||this._updateGpuText(t).catch(t=>{console.error(t)}),t._didTextUpdate=!1,(0,s.s)(r,t)}this._renderer.renderPipes.batch.addToBatch(r,e)}updateRenderable(t){const e=this._getGpuText(t);e._batcher.updateElement(e)}async _updateGpuText(t){t._didTextUpdate=!1;const e=this._getGpuText(t);if(e.generatingTexture)return;const r=e.texturePromise;e.texturePromise=null,e.generatingTexture=!0,t._resolution=t._autoResolution?this._renderer.resolution:t.resolution;let i=this._renderer.htmlText.getTexturePromise(t);r&&(i=i.finally(()=>{this._renderer.htmlText.decreaseReferenceCount(e.currentKey),this._renderer.htmlText.returnTexturePromise(r)})),e.texturePromise=i,e.currentKey=t.styleKey,e.texture=await i;const n=t.renderGroup||t.parentRenderGroup;n&&(n.structureDidChange=!0),e.generatingTexture=!1,(0,s.s)(e,t)}_getGpuText(t){return t._gpuData[this._renderer.uid]||this.initGpuText(t)}initGpuText(t){const e=new a(this._renderer);return e.renderable=t,e.transform=t.groupTransform,e.texture=n.g.EMPTY,e.bounds={minX:0,maxX:1,minY:0,maxY:0},e.roundPixels=this._renderer._roundPixels|t._roundPixels,t._resolution=t._autoResolution?this._renderer.resolution:t.resolution,t._gpuData[this._renderer.uid]=e,e}destroy(){this._renderer=null}}l.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"htmlText"};var h=r(7608),u=r(2437),c=r(5099),d=r(1761),f=r(268),p=r(8655),g=r(2558);const x="http://www.w3.org/2000/svg",m="http://www.w3.org/1999/xhtml";class y{constructor(){this.svgRoot=document.createElementNS(x,"svg"),this.foreignObject=document.createElementNS(x,"foreignObject"),this.domElement=document.createElementNS(m,"div"),this.styleElement=document.createElementNS(m,"style");const{foreignObject:t,svgRoot:e,styleElement:r,domElement:i}=this;t.setAttribute("width","10000"),t.setAttribute("height","10000"),t.style.overflow="hidden",e.appendChild(t),t.appendChild(r),t.appendChild(i),this.image=d.e.get().createImage()}destroy(){this.svgRoot.remove(),this.foreignObject.remove(),this.styleElement.remove(),this.domElement.remove(),this.image.src="",this.image.remove(),this.svgRoot=null,this.foreignObject=null,this.styleElement=null,this.domElement=null,this.image=null,this.canvasAndContext=null}}var _=r(1979);const b=new Map;let v;class S{constructor(t){this._activeTextures={},this._renderer=t,this._createCanvas=t.type===c.W.WEBGPU}getTexture(t){return this.getTexturePromise(t)}getManagedTexture(t){const e=t.styleKey;if(this._activeTextures[e])return this._increaseReferenceCount(e),this._activeTextures[e].promise;const r=this._buildTexturePromise(t).then(t=>(this._activeTextures[e].texture=t,t));return this._activeTextures[e]={texture:null,promise:r,usageCount:1},r}getReferenceCount(t){return this._activeTextures[t]?.usageCount??null}_increaseReferenceCount(t){this._activeTextures[t].usageCount++}decreaseReferenceCount(t){const e=this._activeTextures[t];e&&(e.usageCount--,0===e.usageCount&&(e.texture?this._cleanUp(e.texture):e.promise.then(t=>{e.texture=t,this._cleanUp(e.texture)}).catch(()=>{(0,f.R)("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[t]=null))}getTexturePromise(t){return this._buildTexturePromise(t)}async _buildTexturePromise(t){const{text:e,style:r,resolution:i,textureStyle:n}=t,s=p.Z.get(y),o=function(t,e){const r=e.fontFamily,i=[],n={},s=t.match(/font-family:([^;"\s]+)/g);function o(t){n[t]||(i.push(t),n[t]=!0)}if(Array.isArray(r))for(let t=0;t<r.length;t++)o(r[t]);else o(r);s&&s.forEach(t=>{o(t.split(":")[1].trim())});for(const t in e.tagStyles)o(e.tagStyles[t].fontFamily);return i}(e,r),a=await async function(t){const e=t.filter(t=>_.l.has(`${t}-and-url`)).map(t=>{if(!b.has(t)){const{entries:e}=_.l.get(`${t}-and-url`),r=[];e.forEach(e=>{const i=e.url,n=e.faces.map(t=>({weight:t.weight,style:t.style}));r.push(...n.map(e=>async function(t,e){const r=await async function(t){const e=await d.e.get().fetch(t),r=await e.blob(),i=new FileReader;return await new Promise((t,e)=>{i.onloadend=()=>t(i.result),i.onerror=e,i.readAsDataURL(r)})}(e);return`@font-face {\n        font-family: "${t.fontFamily}";\n        font-weight: ${t.fontWeight};\n        font-style: ${t.fontStyle};\n        src: url('${r}');\n    }`}({fontWeight:e.weight,fontStyle:e.style,fontFamily:t},i)))}),b.set(t,Promise.all(r).then(t=>t.join("\n")))}return b.get(t)});return(await Promise.all(e)).join("\n")}(o),l=function(t,e,r,i){i||(i=v||(v=new y));const{domElement:n,styleElement:s,svgRoot:o}=i;n.innerHTML=`<style>${e.cssStyle};</style><div style='padding:0'>${t}</div>`,n.setAttribute("style","transform-origin: top left; display: inline-block"),r&&(s.textContent=r),document.body.appendChild(o);const a=n.getBoundingClientRect();o.remove();const l=2*e.padding;return{width:a.width-l,height:a.height-l}}(e,r,a,s),u=Math.ceil(Math.ceil(Math.max(1,l.width)+2*r.padding)*i),c=Math.ceil(Math.ceil(Math.max(1,l.height)+2*r.padding)*i),f=s.image;f.width=2+(0|u),f.height=2+(0|c);const x=function(t,e,r,i,n){const{domElement:s,styleElement:o,svgRoot:a}=n;s.innerHTML=`<style>${e.cssStyle}</style><div style='padding:0;'>${t}</div>`,s.setAttribute("style",`transform: scale(${r});transform-origin: top left; display: inline-block`),o.textContent=i;const{width:l,height:h}=n.image;return a.setAttribute("width",l.toString()),a.setAttribute("height",h.toString()),(new XMLSerializer).serializeToString(a)}(e,r,i,a,s);await function(t,e,r){return new Promise(async i=>{r&&await new Promise(t=>setTimeout(t,100)),t.onload=()=>{i()},t.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`,t.crossOrigin="anonymous"})}(f,x,function(){const{userAgent:t}=d.e.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(t)}()&&o.length>0);const m=f;let S;this._createCanvas&&(S=function(t,e){const r=h.N.getOptimalCanvasAndContext(t.width,t.height,e),{context:i}=r;return i.clearRect(0,0,t.width,t.height),i.drawImage(t,0,0),r}(f,i));const w=(0,g.M)(S?S.canvas:m,f.width-2,f.height-2,i);return n&&(w.source.style=n),this._createCanvas&&(this._renderer.texture.initSource(w.source),h.N.returnCanvasAndContext(S)),p.Z.return(s),w}returnTexturePromise(t){t.then(t=>{this._cleanUp(t)}).catch(()=>{(0,f.R)("HTMLTextSystem: Failed to clean texture")})}_cleanUp(t){u.W.returnTexture(t,!0),t.source.resource=null,t.source.uploadMethodId="unknown"}destroy(){this._renderer=null;for(const t in this._activeTextures)this._activeTextures[t]&&this.returnTexturePromise(this._activeTextures[t].promise);this._activeTextures=null}}S.extension={type:[i.Ag.WebGLSystem,i.Ag.WebGPUSystem,i.Ag.CanvasSystem],name:"htmlText"},i.XO.add(S),i.XO.add(l)},2760:(t,e,r)=>{"use strict";function i(t,e,r){const i=(t>>24&255)/255;e[r++]=(255&t)/255*i,e[r++]=(t>>8&255)/255*i,e[r++]=(t>>16&255)/255*i,e[r++]=i}r.d(e,{V:()=>i})},2806:(t,e,r)=>{"use strict";r.d(e,{m:()=>o});var i=r(9313),n=r(133);const s={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class o{constructor(t,e){this.uid=(0,n.L)("fillPattern"),this._tick=0,this.transform=new i.u,this.texture=t,this.transform.scale(1/t.frame.width,1/t.frame.height),e&&(t.source.style.addressModeU=s[e].addressModeU,t.source.style.addressModeV=s[e].addressModeV)}setTransform(t){const e=this.texture;this.transform.copyFrom(t),this.transform.invert(),this.transform.scale(1/e.frame.width,1/e.frame.height),this._tick++}get texture(){return this._texture}set texture(t){this._texture!==t&&(this._texture=t,this._tick++)}get styleKey(){return`fill-pattern-${this.uid}-${this._tick}`}destroy(){this.texture.destroy(!0),this.texture=null}}},3012:(t,e,r)=>{"use strict";r.d(e,{B:()=>h});var i=r(7952),n=r(8306);const s={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function o(t){const e=/@group\((\d+)\)/,r=/@binding\((\d+)\)/,i=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,s=/(\w+)\s*:\s*([\w\<\>]+)/g,o=/struct\s+(\w+)/,a=t.match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g)?.map(t=>({group:parseInt(t.match(e)[1],10),binding:parseInt(t.match(r)[1],10),name:t.match(i)[2],isUniform:"<uniform>"===t.match(i)[1],type:t.match(n)[1]}));if(!a)return{groups:[],structs:[]};const l=t.match(/struct\s+(\w+)\s*{([^}]+)}/g)?.map(t=>{const e=t.match(o)[1],r=t.match(s).reduce((t,e)=>{const[r,i]=e.split(":");return t[r.trim()]=i.trim(),t},{});return r?{name:e,members:r}:null}).filter(({name:t})=>a.some(e=>e.type===t))??[];return{groups:a,structs:l}}var a=(t=>(t[t.VERTEX=1]="VERTEX",t[t.FRAGMENT=2]="FRAGMENT",t[t.COMPUTE=4]="COMPUTE",t))(a||{});const l=Object.create(null);class h{constructor(t){this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:e,vertex:r,layout:i,gpuLayout:n,name:s}=t;if(this.name=s,this.fragment=e,this.vertex=r,e.source===r.source){const t=o(e.source);this.structsAndGroups=t}else{const t=o(r.source),i=o(e.source);this.structsAndGroups=function(t,e){const r=new Set,i=new Set;return{structs:[...t.structs,...e.structs].filter(t=>!r.has(t.name)&&(r.add(t.name),!0)),groups:[...t.groups,...e.groups].filter(t=>{const e=`${t.name}-${t.binding}`;return!i.has(e)&&(i.add(e),!0)})}}(t,i)}this.layout=i??function({groups:t}){const e=[];for(let r=0;r<t.length;r++){const i=t[r];e[i.group]||(e[i.group]={}),e[i.group][i.name]=i.binding}return e}(this.structsAndGroups),this.gpuLayout=n??function({groups:t}){const e=[];for(let r=0;r<t.length;r++){const i=t[r];e[i.group]||(e[i.group]=[]),i.isUniform?e[i.group].push({binding:i.binding,visibility:a.VERTEX|a.FRAGMENT,buffer:{type:"uniform"}}):"sampler"===i.type?e[i.group].push({binding:i.binding,visibility:a.FRAGMENT,sampler:{type:"filtering"}}):"texture_2d"===i.type&&e[i.group].push({binding:i.binding,visibility:a.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return e}(this.structsAndGroups),this.autoAssignGlobalUniforms=!(void 0===this.layout[0]?.globalUniforms),this.autoAssignLocalUniforms=!(void 0===this.layout[1]?.localUniforms),this._generateProgramKey()}_generateProgramKey(){const{vertex:t,fragment:e}=this,r=t.source+e.source+t.entryPoint+e.entryPoint;this._layoutKey=(0,i.X)(r,"program")}get attributeData(){return this._attributeData??(this._attributeData=function({source:t,entryPoint:e}){const r={},i=t.indexOf(`fn ${e}`);if(-1!==i){const e=t.indexOf("->",i);if(-1!==e){const o=t.substring(i,e),a=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let l;for(;null!==(l=a.exec(o));){const t=s[l[3]]??"float32";r[l[2]]={location:parseInt(l[1],10),format:t,stride:(0,n.m)(t).stride,offset:0,instance:!1,start:0}}}}return r}(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null,l[this._cacheKey]=null}static from(t){const e=`${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;return l[e]||(l[e]=new h(t),l[e]._cacheKey=e),l[e]}}},3513:(t,e,r)=>{"use strict";r.d(e,{T:()=>i});class i{constructor(t){this.resources=Object.create(null),this._dirty=!0;let e=0;for(const r in t){const i=t[r];this.setResource(i,e++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const t=[];let e=0;for(const r in this.resources)t[e++]=this.resources[r]._resourceId;this._key=t.join("|")}setResource(t,e){const r=this.resources[e];t!==r&&(r&&t.off?.("change",this.onResourceChange,this),t.on?.("change",this.onResourceChange,this),this.resources[e]=t,this._dirty=!0)}getResource(t){return this.resources[t]}_touch(t){const e=this.resources;for(const r in e)e[r]._touched=t}destroy(){const t=this.resources;for(const e in t){const r=t[e];r?.off?.("change",this.onResourceChange,this)}this.resources=null}onResourceChange(t){if(this._dirty=!0,t.destroyed){const e=this.resources;for(const r in e)e[r]===t&&(e[r]=null)}else this._updateKey()}}},3548:(t,e,r)=>{"use strict";r.d(e,{r:()=>u});var i=r(2577),n=r(9313),s=r(7174),o=r(268),a=r(7276),l=r(2806);const h=1e5;function u(t,e,r,u=0){if(t.texture===s.g.WHITE&&!t.fill)return i.Q.shared.setValue(t.color).setAlpha(t.alpha??1).toHexa();if(!t.fill){const r=e.createPattern(t.texture.source.resource,"repeat"),i=t.matrix.copyTo(n.u.shared);return i.scale(t.texture.frame.width,t.texture.frame.height),r.setTransform(i),r}if(t.fill instanceof l.m){const r=t.fill,i=e.createPattern(r.texture.source.resource,"repeat"),s=r.transform.copyTo(n.u.shared);return s.scale(r.texture.frame.width,r.texture.frame.height),i.setTransform(s),i}if(t.fill instanceof a._){const n=t.fill,s="linear"===n.type,o="local"===n.textureSpace;let a,l=1,c=1;o&&r&&(l=r.width+u,c=r.height+u);let d=!1;if(s){const{start:t,end:r}=n;a=e.createLinearGradient(t.x*l,t.y*c,r.x*l,r.y*c),d=Math.abs(r.x-t.x)<Math.abs(.1*(r.y-t.y))}else{const{center:t,innerRadius:r,outerCenter:i,outerRadius:s}=n;a=e.createRadialGradient(t.x*l,t.y*c,r*l,i.x*l,i.y*c,s*l)}if(d&&o&&r){const t=r.lineHeight/c;for(let e=0;e<r.lines.length;e++){const s=(e*r.lineHeight+u/2)/c;n.colorStops.forEach(e=>{const r=s+e.offset*t;a.addColorStop(Math.floor(r*h)/h,i.Q.shared.setValue(e.color).toHex())})}}else n.colorStops.forEach(t=>{a.addColorStop(t.offset,i.Q.shared.setValue(t.color).toHex())});return a}return(0,o.R)("FillStyle not recognised",t),"red"}},3804:(t,e,r)=>{"use strict";r.d(e,{W:()=>s});var i=r(1761);let n;function s(){if(!n||n?.isContextLost()){const t=i.e.get().createCanvas();n=t.getContext("webgl",{})}return n}},3830:(t,e,r)=>{"use strict";var i=r(8507),n=r(2331),s=r(7547),o=r(5099),a=r(2760),l=r(8734),h=r(5060),u=r(9313),c=r(5611);const d={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},f=(d.vertex,d.vertex.header.replace("group(1)","group(2)"),{name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}});var p=r(6665),g=r(8475),x=r(5811),m=r(7174);const y={name:"tiling-bit",vertex:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        "},fragment:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        "}},_={name:"tiling-bit",vertex:{header:"\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        ",main:"\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        "},fragment:{header:"\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ",main:"\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        "}};let b,v;class S extends g.M{constructor(){b??(b=(0,c.v)({name:"tiling-sprite-shader",bits:[d,y,p.b]})),v??(v=(0,c.I)({name:"tiling-sprite-shader",bits:[f,_,p.m]}));const t=new x.k({uMapCoord:{value:new u.u,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new u.u,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:v,gpuProgram:b,resources:{localUniforms:new x.k({uTransformMatrix:{value:new u.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:t,uTexture:m.g.EMPTY.source,uSampler:m.g.EMPTY.source.style}})}updateUniforms(t,e,r,i,n,s){const o=this.resources.tilingUniforms,a=s.width,l=s.height,h=s.textureMatrix,u=o.uniforms.uTextureTransform;u.set(r.a*a/t,r.b*a/e,r.c*l/t,r.d*l/e,r.tx/t,r.ty/e),u.invert(),o.uniforms.uMapCoord=h.mapCoord,o.uniforms.uClampFrame=h.uClampFrame,o.uniforms.uClampOffset=h.uClampOffset,o.uniforms.uTextureTransform=u,o.uniforms.uSizeAnchor[0]=t,o.uniforms.uSizeAnchor[1]=e,o.uniforms.uSizeAnchor[2]=i,o.uniforms.uSizeAnchor[3]=n,s&&(this.resources.uTexture=s.source,this.resources.uSampler=s.source.style)}}class w extends h.u{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}const T=new w;class P{constructor(){this.canBatch=!0,this.geometry=new h.u({indices:T.indices.slice(),positions:T.positions.slice(),uvs:T.uvs.slice()})}destroy(){this.geometry.destroy(),this.shader?.destroy()}}class C{constructor(t){this._state=s.U.default2d,this._renderer=t}validateRenderable(t){const e=this._getTilingSpriteData(t),r=e.canBatch;this._updateCanBatch(t);const i=e.canBatch;if(i&&i===r){const{batchableMesh:r}=e;return!r._batcher.checkAndUpdateTexture(r,t.texture)}return r!==i}addRenderable(t,e){const r=this._renderer.renderPipes.batch;this._updateCanBatch(t);const i=this._getTilingSpriteData(t),{geometry:n,canBatch:s}=i;if(s){i.batchableMesh||(i.batchableMesh=new l.U);const s=i.batchableMesh;t.didViewUpdate&&(this._updateBatchableMesh(t),s.geometry=n,s.renderable=t,s.transform=t.groupTransform,s.setTexture(t._texture)),s.roundPixels=this._renderer._roundPixels|t._roundPixels,r.addToBatch(s,e)}else r.break(e),i.shader||(i.shader=new S),this.updateRenderable(t),e.add(t)}execute(t){const{shader:e}=this._getTilingSpriteData(t);e.groups[0]=this._renderer.globalUniforms.bindGroup;const r=e.resources.localUniforms.uniforms;r.uTransformMatrix=t.groupTransform,r.uRound=this._renderer._roundPixels|t._roundPixels,(0,a.V)(t.groupColorAlpha,r.uColor,0),this._state.blendMode=(0,n.i)(t.groupBlendMode,t.texture._source),this._renderer.encoder.draw({geometry:T,shader:e,state:this._state})}updateRenderable(t){const e=this._getTilingSpriteData(t),{canBatch:r}=e;if(r){const{batchableMesh:r}=e;t.didViewUpdate&&this._updateBatchableMesh(t),r._batcher.updateElement(r)}else if(t.didViewUpdate){const{shader:r}=e;r.updateUniforms(t.width,t.height,t._tileTransform.matrix,t.anchor.x,t.anchor.y,t.texture)}}_getTilingSpriteData(t){return t._gpuData[this._renderer.uid]||this._initTilingSpriteData(t)}_initTilingSpriteData(t){const e=new P;return e.renderable=t,t._gpuData[this._renderer.uid]=e,e}_updateBatchableMesh(t){const e=this._getTilingSpriteData(t),{geometry:r}=e,i=t.texture.source.style;"repeat"!==i.addressMode&&(i.addressMode="repeat",i.update()),function(t,e){const r=t.texture,i=r.frame.width,n=r.frame.height;let s=0,o=0;t.applyAnchorToTexture&&(s=t.anchor.x,o=t.anchor.y),e[0]=e[6]=-s,e[2]=e[4]=1-s,e[1]=e[3]=-o,e[5]=e[7]=1-o;const a=u.u.shared;a.copyFrom(t._tileTransform.matrix),a.tx/=t.width,a.ty/=t.height,a.invert(),a.scale(t.width/i,t.height/n),function(t,e,r,i){let n=0;const s=t.length/2,o=i.a,a=i.b,l=i.c,h=i.d,u=i.tx,c=i.ty;for(r*=2;n<s;){const e=t[r],i=t[r+1];t[r]=o*e+l*i+u,t[r+1]=a*e+h*i+c,r+=2,n++}}(e,0,0,a)}(t,r.uvs),function(t,e){const r=t.anchor.x,i=t.anchor.y;e[0]=-r*t.width,e[1]=-i*t.height,e[2]=(1-r)*t.width,e[3]=-i*t.height,e[4]=(1-r)*t.width,e[5]=(1-i)*t.height,e[6]=-r*t.width,e[7]=(1-i)*t.height}(t,r.positions)}destroy(){this._renderer=null}_updateCanBatch(t){const e=this._getTilingSpriteData(t),r=t.texture;let i=!0;return this._renderer.type===o.W.WEBGL&&(i=this._renderer.context.supports.nonPowOf2wrapping),e.canBatch=r.textureMatrix.isSimple&&(i||r.source.isPowerOfTwo),e.canBatch}}C.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"tilingSprite"},i.XO.add(C)},4e3:(t,e,r)=>{"use strict";r.d(e,{P:()=>h,_:()=>o});const i={};function n(t){const e=[];if(1===t)e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),e.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let r=0;for(let i=0;i<t;i++)e.push(`@group(1) @binding(${r++}) var textureSource${i+1}: texture_2d<f32>;`),e.push(`@group(1) @binding(${r++}) var textureSampler${i+1}: sampler;`)}return e.join("\n")}function s(t){const e=[];if(1===t)e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{e.push("switch vTextureId {");for(let r=0;r<t;r++)r===t-1?e.push("  default:{"):e.push(`  case ${r}:{`),e.push(`      outColor = textureSampleGrad(textureSource${r+1}, textureSampler${r+1}, vUV, uvDx, uvDy);`),e.push("      break;}");e.push("}")}return e.join("\n")}function o(t){return i[t]||(i[t]={name:"texture-batch-bit",vertex:{header:"\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            "},fragment:{header:`\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${n(t)}\n            `,main:`\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${s(t)}\n            `}}),i[t]}const a={};function l(t){const e=[];for(let r=0;r<t;r++)r>0&&e.push("else"),r<t-1&&e.push(`if(vTextureId < ${r}.5)`),e.push("{"),e.push(`\toutColor = texture(uTextures[${r}], vUV);`),e.push("}");return e.join("\n")}function h(t){return a[t]||(a[t]={name:"texture-batch-bit",vertex:{header:"\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            "},fragment:{header:`\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${t}];\n\n            `,main:`\n\n                ${l(t)}\n            `}}),a[t]}},4016:(t,e,r)=>{"use strict";r.d(e,{P:()=>l});var i=r(5957),n=r(1761),s=r(1242);const o={willReadFrequently:!0},a=class t{static get experimentalLetterSpacingSupported(){let e=t._experimentalLetterSpacingSupported;if(void 0===e){const r=n.e.get().getCanvasRenderingContext2D().prototype;e=t._experimentalLetterSpacingSupported="letterSpacing"in r||"textLetterSpacing"in r}return e}constructor(t,e,r,i,n,s,o,a,l){this.text=t,this.style=e,this.width=r,this.height=i,this.lines=n,this.lineWidths=s,this.lineHeight=o,this.maxLineWidth=a,this.fontProperties=l}static measureText(e=" ",r,i=t._canvas,n=r.wordWrap){const o=`${e}-${r.styleKey}-wordWrap-${n}`;if(t._measurementCache.has(o))return t._measurementCache.get(o);const a=(0,s.Z)(r),l=t.measureFont(a);0===l.fontSize&&(l.fontSize=r.fontSize,l.ascent=r.fontSize);const h=t.__context;h.font=a;const u=(n?t._wordWrap(e,r,i):e).split(/(?:\r\n|\r|\n)/),c=new Array(u.length);let d=0;for(let e=0;e<u.length;e++){const i=t._measureText(u[e],r.letterSpacing,h);c[e]=i,d=Math.max(d,i)}const f=r._stroke?.width||0;let p=d+f;r.dropShadow&&(p+=r.dropShadow.distance);const g=r.lineHeight||l.fontSize;let x=Math.max(g,l.fontSize+f)+(u.length-1)*(g+r.leading);r.dropShadow&&(x+=r.dropShadow.distance);const m=new t(e,r,p,x,u,c,g+r.leading,d,l);return t._measurementCache.set(o,m),m}static _measureText(e,r,i){let n=!1;t.experimentalLetterSpacingSupported&&(t.experimentalLetterSpacing?(i.letterSpacing=`${r}px`,i.textLetterSpacing=`${r}px`,n=!0):(i.letterSpacing="0px",i.textLetterSpacing="0px"));const s=i.measureText(e);let o=s.width;const a=-s.actualBoundingBoxLeft;let l=s.actualBoundingBoxRight-a;if(o>0)if(n)o-=r,l-=r;else{const i=(t.graphemeSegmenter(e).length-1)*r;o+=i,l+=i}return Math.max(o,l)}static _wordWrap(e,r,i=t._canvas){const n=i.getContext("2d",o);let s=0,a="",l="";const h=Object.create(null),{letterSpacing:u,whiteSpace:c}=r,d=t._collapseSpaces(c),f=t._collapseNewlines(c);let p=!d;const g=r.wordWrapWidth+u,x=t._tokenize(e);for(let e=0;e<x.length;e++){let i=x[e];if(t._isNewline(i)){if(!f){l+=t._addLine(a),p=!d,a="",s=0;continue}i=" "}if(d){const e=t.isBreakingSpace(i),r=t.isBreakingSpace(a[a.length-1]);if(e&&r)continue}const o=t._getFromCache(i,u,h,n);if(o>g)if(""!==a&&(l+=t._addLine(a),a="",s=0),t.canBreakWords(i,r.breakWords)){const e=t.wordWrapSplit(i);for(let o=0;o<e.length;o++){let c=e[o],d=c,f=1;for(;e[o+f];){const n=e[o+f];if(t.canBreakChars(d,n,i,o,r.breakWords))break;c+=n,d=n,f++}o+=f-1;const x=t._getFromCache(c,u,h,n);x+s>g&&(l+=t._addLine(a),p=!1,a="",s=0),a+=c,s+=x}}else{a.length>0&&(l+=t._addLine(a),a="",s=0);const r=e===x.length-1;l+=t._addLine(i,!r),p=!1,a="",s=0}else o+s>g&&(p=!1,l+=t._addLine(a),a="",s=0),(a.length>0||!t.isBreakingSpace(i)||p)&&(a+=i,s+=o)}return l+=t._addLine(a,!1),l}static _addLine(e,r=!0){return e=t._trimRight(e),r?`${e}\n`:e}static _getFromCache(e,r,i,n){let s=i[e];return"number"!=typeof s&&(s=t._measureText(e,r,n)+r,i[e]=s),s}static _collapseSpaces(t){return"normal"===t||"pre-line"===t}static _collapseNewlines(t){return"normal"===t}static _trimRight(e){if("string"!=typeof e)return"";for(let r=e.length-1;r>=0;r--){const i=e[r];if(!t.isBreakingSpace(i))break;e=e.slice(0,-1)}return e}static _isNewline(e){return"string"==typeof e&&t._newlines.includes(e.charCodeAt(0))}static isBreakingSpace(e,r){return"string"==typeof e&&t._breakingSpaces.includes(e.charCodeAt(0))}static _tokenize(e){const r=[];let i="";if("string"!=typeof e)return r;for(let n=0;n<e.length;n++){const s=e[n],o=e[n+1];t.isBreakingSpace(s,o)||t._isNewline(s)?(""!==i&&(r.push(i),i=""),"\r"===s&&"\n"===o?(r.push("\r\n"),n++):r.push(s)):i+=s}return""!==i&&r.push(i),r}static canBreakWords(t,e){return e}static canBreakChars(t,e,r,i,n){return!0}static wordWrapSplit(e){return t.graphemeSegmenter(e)}static measureFont(e){if(t._fonts[e])return t._fonts[e];const r=t._context;r.font=e;const i=r.measureText(t.METRICS_STRING+t.BASELINE_SYMBOL),n={ascent:i.actualBoundingBoxAscent,descent:i.actualBoundingBoxDescent,fontSize:i.actualBoundingBoxAscent+i.actualBoundingBoxDescent};return t._fonts[e]=n,n}static clearMetrics(e=""){e?delete t._fonts[e]:t._fonts={}}static get _canvas(){if(!t.__canvas){let e;try{const r=new OffscreenCanvas(0,0),i=r.getContext("2d",o);if(i?.measureText)return t.__canvas=r,r;e=n.e.get().createCanvas()}catch(t){e=n.e.get().createCanvas()}e.width=e.height=10,t.__canvas=e}return t.__canvas}static get _context(){return t.__context||(t.__context=t._canvas.getContext("2d",o)),t.__context}};a.METRICS_STRING="|ÉqÅ",a.BASELINE_SYMBOL="M",a.BASELINE_MULTIPLIER=1.4,a.HEIGHT_MULTIPLIER=2,a.graphemeSegmenter=(()=>{if("function"==typeof Intl?.Segmenter){const t=new Intl.Segmenter;return e=>{const r=t.segment(e),i=[];let n=0;for(const t of r)i[n++]=t.segment;return i}}return t=>[...t]})(),a.experimentalLetterSpacing=!1,a._fonts={},a._newlines=[10,13],a._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288],a._measurementCache=(0,i.g)(1e3);let l=a},4459:(t,e,r)=>{"use strict";r.d(e,{F:()=>i,a:()=>n});const i={name:"color-bit",vertex:{header:"\n            @in aColor: vec4<f32>;\n        ",main:"\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        "}},n={name:"color-bit",vertex:{header:"\n            in vec4 aColor;\n        ",main:"\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        "}}},4732:(t,e,r)=>{"use strict";var i=r(8507);class n{static init(t){Object.defineProperty(this,"resizeTo",{configurable:!0,set(t){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=t,t&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;let t,e;if(this._cancelResize(),this._resizeTo===globalThis.window)t=globalThis.innerWidth,e=globalThis.innerHeight;else{const{clientWidth:r,clientHeight:i}=this._resizeTo;t=r,e=i}this.renderer.resize(t,e),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=t.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}n.extension=i.Ag.Application;var s=r(4458),o=r(7309);class a{static init(t){t=Object.assign({autoStart:!0,sharedTicker:!1},t),Object.defineProperty(this,"ticker",{configurable:!0,set(t){this._ticker&&this._ticker.remove(this.render,this),this._ticker=t,t&&t.add(this.render,this,s.d.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=t.sharedTicker?o.R.shared:new o.R,t.autoStart&&this.start()}static destroy(){if(this._ticker){const t=this._ticker;this.ticker=null,t.destroy()}}}a.extension=i.Ag.Application,i.XO.add(n),i.XO.add(a)},5060:(t,e,r)=>{"use strict";r.d(e,{u:()=>l});var i=r(949),n=r(1132),s=r(6011),o=r(4670);const a=class t extends s.V{constructor(...e){let r=e[0]??{};r instanceof Float32Array&&((0,o.t6)(o.lj,"use new MeshGeometry({ positions, uvs, indices }) instead"),r={positions:r,uvs:e[1],indices:e[2]}),r={...t.defaultOptions,...r};const s=r.positions||new Float32Array([0,0,1,0,1,1,0,1]);let a=r.uvs;a||(a=r.positions?new Float32Array(s.length):new Float32Array([0,0,1,0,1,1,0,1]));const l=r.indices||new Uint32Array([0,1,2,0,2,3]),h=r.shrinkBuffersToFit;super({attributes:{aPosition:{buffer:new i.h({data:s,label:"attribute-mesh-positions",shrinkToFit:h,usage:n.S.VERTEX|n.S.COPY_DST}),format:"float32x2",stride:8,offset:0},aUV:{buffer:new i.h({data:a,label:"attribute-mesh-uvs",shrinkToFit:h,usage:n.S.VERTEX|n.S.COPY_DST}),format:"float32x2",stride:8,offset:0}},indexBuffer:new i.h({data:l,label:"index-mesh-buffer",shrinkToFit:h,usage:n.S.INDEX|n.S.COPY_DST}),topology:r.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(t){this.attributes.aPosition.buffer.data=t}get uvs(){return this.attributes.aUV.buffer.data}set uvs(t){this.attributes.aUV.buffer.data=t}get indices(){return this.indexBuffer.data}set indices(t){this.indexBuffer.data=t}};a.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let l=a},5099:(t,e,r)=>{"use strict";r.d(e,{W:()=>i});var i=(t=>(t[t.WEBGL=1]="WEBGL",t[t.WEBGPU=2]="WEBGPU",t[t.BOTH=3]="BOTH",t))(i||{})},5148:(t,e,r)=>{"use strict";var i=r(8507),n=r(2289),s=r(8422);class o extends s.K{constructor(t){super(),this._renderer=t,t.runners.resolutionChange.add(this)}resolutionChange(){const t=this.renderable;t._autoResolution&&t.onViewUpdate()}destroy(){const{canvasText:t}=this._renderer;t.getReferenceCount(this.currentKey)>0?t.decreaseReferenceCount(this.currentKey):this.texture&&t.returnTexture(this.texture),this._renderer.runners.resolutionChange.remove(this),this._renderer=null}}class a{constructor(t){this._renderer=t}validateRenderable(t){const e=this._getGpuText(t),r=t.styleKey;return e.currentKey!==r||t._didTextUpdate}addRenderable(t,e){const r=this._getGpuText(t);if(t._didTextUpdate){const e=t._autoResolution?this._renderer.resolution:t.resolution;r.currentKey===t.styleKey&&t.resolution===e||this._updateGpuText(t),t._didTextUpdate=!1,(0,n.s)(r,t)}this._renderer.renderPipes.batch.addToBatch(r,e)}updateRenderable(t){const e=this._getGpuText(t);e._batcher.updateElement(e)}_updateGpuText(t){const e=this._getGpuText(t);e.texture&&this._renderer.canvasText.decreaseReferenceCount(e.currentKey),t._resolution=t._autoResolution?this._renderer.resolution:t.resolution,e.texture=this._renderer.canvasText.getManagedTexture(t),e.currentKey=t.styleKey}_getGpuText(t){return t._gpuData[this._renderer.uid]||this.initGpuText(t)}initGpuText(t){const e=new o(this._renderer);return e.currentKey="--",e.renderable=t,e.transform=t.groupTransform,e.bounds={minX:0,maxX:1,minY:0,maxY:0},e.roundPixels=this._renderer._roundPixels|t._roundPixels,t._gpuData[this._renderer.uid]=e,e}destroy(){this._renderer=null}}a.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"text"};var l=r(2437),h=r(218),u=r(4670),c=r(8291),d=r(2558),f=r(2577),p=r(9252),g=r(7608),x=r(1761),m=r(9939);let y=null,_=null;function b(t,e,r){for(let i=0,n=4*r*e;i<e;++i,n+=4)if(0!==t[n+3])return!1;return!0}function v(t,e,r,i,n){const s=4*e;for(let e=i,o=i*s+4*r;e<=n;++e,o+=s)if(0!==t[o+3])return!1;return!0}function S(...t){let e=t[0];e.canvas||(e={canvas:t[0],resolution:t[1]});const{canvas:r}=e,i=Math.min(e.resolution??1,1),n=e.width??r.width,s=e.height??r.height;let o=e.output;if(function(t,e){y||(y=x.e.get().createCanvas(256,128),_=y.getContext("2d",{willReadFrequently:!0}),_.globalCompositeOperation="copy",_.globalAlpha=1),(y.width<t||y.height<e)&&(y.width=(0,m.U5)(t),y.height=(0,m.U5)(e))}(n,s),!_)throw new TypeError("Failed to get canvas 2D context");_.drawImage(r,0,0,n,s,0,0,n*i,s*i);const a=_.getImageData(0,0,n,s).data;let l=0,h=0,u=n-1,c=s-1;for(;h<s&&b(a,n,h);)++h;if(h===s)return p.M.EMPTY;for(;b(a,n,c);)--c;for(;v(a,n,l,h,c);)++l;for(;v(a,n,u,h,c);)--u;return++u,++c,_.globalCompositeOperation="source-over",_.strokeRect(l,h,u-l,c-h),_.globalCompositeOperation="copy",o??(o=new p.M),o.set(l/i,h/i,(u-l)/i,(c-h)/i),o}var w=r(4016),T=r(1242),P=r(3548);const C=new p.M,M=new class{getCanvasAndContext(t){const{text:e,style:r,resolution:i=1}=t,n=r._getFinalPadding(),s=w.P.measureText(e||" ",r),o=Math.ceil(Math.ceil(Math.max(1,s.width)+2*n)*i),a=Math.ceil(Math.ceil(Math.max(1,s.height)+2*n)*i),l=g.N.getOptimalCanvasAndContext(o,a);return this._renderTextToCanvas(e,r,n,i,l),{canvasAndContext:l,frame:r.trim?S({canvas:l.canvas,width:o,height:a,resolution:1,output:C}):C.set(0,0,o,a)}}returnCanvasAndContext(t){g.N.returnCanvasAndContext(t)}_renderTextToCanvas(t,e,r,i,n){const{canvas:s,context:o}=n,a=(0,T.Z)(e),l=w.P.measureText(t||" ",e),h=l.lines,u=l.lineHeight,c=l.lineWidths,d=l.maxLineWidth,p=l.fontProperties,g=s.height;if(o.resetTransform(),o.scale(i,i),o.textBaseline=e.textBaseline,e._stroke?.width){const t=e._stroke;o.lineWidth=t.width,o.miterLimit=t.miterLimit,o.lineJoin=t.join,o.lineCap=t.cap}let x,m;o.font=a;const y=e.dropShadow?2:1;for(let t=0;t<y;++t){const s=e.dropShadow&&0===t,a=s?Math.ceil(Math.max(1,g)+2*r):0,y=a*i;if(s){o.fillStyle="black",o.strokeStyle="black";const t=e.dropShadow,r=t.color,n=t.alpha;o.shadowColor=f.Q.shared.setValue(r).setAlpha(n).toRgbaString();const s=t.blur*i,a=t.distance*i;o.shadowBlur=s,o.shadowOffsetX=Math.cos(t.angle)*a,o.shadowOffsetY=Math.sin(t.angle)*a+y}else{if(o.fillStyle=e._fill?(0,P.r)(e._fill,o,l,2*r):null,e._stroke?.width){const t=.5*e._stroke.width+2*r;o.strokeStyle=(0,P.r)(e._stroke,o,l,t)}o.shadowColor="black"}let _=(u-p.fontSize)/2;u-p.fontSize<0&&(_=0);const b=e._stroke?.width??0;for(let t=0;t<h.length;t++)x=b/2,m=b/2+t*u+p.ascent+_,"right"===e.align?x+=d-c[t]:"center"===e.align&&(x+=(d-c[t])/2),e._stroke?.width&&this._drawLetterSpacing(h[t],e,n,x+r,m+r-a,!0),void 0!==e._fill&&this._drawLetterSpacing(h[t],e,n,x+r,m+r-a)}}_drawLetterSpacing(t,e,r,i,n,s=!1){const{context:o}=r,a=e.letterSpacing;let l=!1;if(w.P.experimentalLetterSpacingSupported&&(w.P.experimentalLetterSpacing?(o.letterSpacing=`${a}px`,o.textLetterSpacing=`${a}px`,l=!0):(o.letterSpacing="0px",o.textLetterSpacing="0px")),0===a||l)return void(s?o.strokeText(t,i,n):o.fillText(t,i,n));let h=i;const u=w.P.graphemeSegmenter(t);let c=o.measureText(t).width,d=0;for(let t=0;t<u.length;++t){const e=u[t];s?o.strokeText(e,h,n):o.fillText(e,h,n);let r="";for(let e=t+1;e<u.length;++e)r+=u[e];d=o.measureText(r).width,h+=c-d+a,c=d}}};class k{constructor(t){this._activeTextures={},this._renderer=t}getTexture(t,e,r,i){"string"==typeof t&&((0,u.t6)("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),t={text:t,style:r,resolution:e}),t.style instanceof c.x||(t.style=new c.x(t.style)),t.textureStyle instanceof h.n||(t.textureStyle=new h.n(t.textureStyle)),"string"!=typeof t.text&&(t.text=t.text.toString());const{text:n,style:s,textureStyle:o}=t,a=t.resolution??this._renderer.resolution,{frame:l,canvasAndContext:f}=M.getCanvasAndContext({text:n,style:s,resolution:a}),p=(0,d.M)(f.canvas,l.width,l.height,a);if(o&&(p.source.style=o),s.trim&&(l.pad(s.padding),p.frame.copyFrom(l),p.frame.scale(1/a),p.updateUvs()),s.filters){const t=this._applyFilters(p,s.filters);return this.returnTexture(p),M.returnCanvasAndContext(f),t}return this._renderer.texture.initSource(p._source),M.returnCanvasAndContext(f),p}returnTexture(t){const e=t.source;e.resource=null,e.uploadMethodId="unknown",e.alphaMode="no-premultiply-alpha",l.W.returnTexture(t,!0)}renderTextToCanvas(){(0,u.t6)("8.10.0","CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead")}getManagedTexture(t){t._resolution=t._autoResolution?this._renderer.resolution:t.resolution;const e=t.styleKey;if(this._activeTextures[e])return this._increaseReferenceCount(e),this._activeTextures[e].texture;const r=this.getTexture({text:t.text,style:t.style,resolution:t._resolution,textureStyle:t.textureStyle});return this._activeTextures[e]={texture:r,usageCount:1},r}decreaseReferenceCount(t){const e=this._activeTextures[t];e.usageCount--,0===e.usageCount&&(this.returnTexture(e.texture),this._activeTextures[t]=null)}getReferenceCount(t){return this._activeTextures[t]?.usageCount??0}_increaseReferenceCount(t){this._activeTextures[t].usageCount++}_applyFilters(t,e){const r=this._renderer.renderTarget.renderTarget,i=this._renderer.filter.generateFilteredTexture({texture:t,filters:e});return this._renderer.renderTarget.bind(r,!1),i}destroy(){this._renderer=null;for(const t in this._activeTextures)this._activeTextures[t]&&this.returnTexture(this._activeTextures[t].texture);this._activeTextures=null}}k.extension={type:[i.Ag.WebGLSystem,i.Ag.WebGPUSystem,i.Ag.CanvasSystem],name:"canvasText"},i.XO.add(k),i.XO.add(a)},5285:(t,e,r)=>{"use strict";var i=r(8507),n=r(9313),s=r(3513),o=r(5811),a=r(2331),l=r(2760),h=r(8734);class u{destroy(){}}class c{constructor(t,e){this.localUniforms=new o.k({uTransformMatrix:{value:new n.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new s.T({0:this.localUniforms}),this.renderer=t,this._adaptor=e,this._adaptor.init()}validateRenderable(t){const e=this._getMeshData(t),r=e.batched,i=t.batched;if(e.batched=i,r!==i)return!0;if(i){const r=t._geometry;if(r.indices.length!==e.indexSize||r.positions.length!==e.vertexSize)return e.indexSize=r.indices.length,e.vertexSize=r.positions.length,!0;const i=this._getBatchableMesh(t);return i.texture.uid!==t._texture.uid&&(i._textureMatrixUpdateId=-1),!i._batcher.checkAndUpdateTexture(i,t._texture)}return!1}addRenderable(t,e){const r=this.renderer.renderPipes.batch,i=this._getMeshData(t);if(t.didViewUpdate&&(i.indexSize=t._geometry.indices?.length,i.vertexSize=t._geometry.positions?.length),i.batched){const i=this._getBatchableMesh(t);i.setTexture(t._texture),i.geometry=t._geometry,r.addToBatch(i,e)}else r.break(e),e.add(t)}updateRenderable(t){if(t.batched){const e=this._getBatchableMesh(t);e.setTexture(t._texture),e.geometry=t._geometry,e._batcher.updateElement(e)}}execute(t){if(!t.isRenderable)return;t.state.blendMode=(0,a.i)(t.groupBlendMode,t.texture._source);const e=this.localUniforms;e.uniforms.uTransformMatrix=t.groupTransform,e.uniforms.uRound=this.renderer._roundPixels|t._roundPixels,e.update(),(0,l.V)(t.groupColorAlpha,e.uniforms.uColor,0),this._adaptor.execute(this,t)}_getMeshData(t){var e,r;return(e=t._gpuData)[r=this.renderer.uid]||(e[r]=new u),t._gpuData[this.renderer.uid].meshData||this._initMeshData(t)}_initMeshData(t){return t._gpuData[this.renderer.uid].meshData={batched:t.batched,indexSize:0,vertexSize:0},t._gpuData[this.renderer.uid].meshData}_getBatchableMesh(t){var e,r;return(e=t._gpuData)[r=this.renderer.uid]||(e[r]=new u),t._gpuData[this.renderer.uid].batchableMesh||this._initBatchableMesh(t)}_initBatchableMesh(t){const e=new h.U;return e.renderable=t,e.setTexture(t._texture),e.transform=t.groupTransform,e.roundPixels=this.renderer._roundPixels|t._roundPixels,t._gpuData[this.renderer.uid].batchableMesh=e,e}destroy(){this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}c.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"mesh"},i.XO.add(c)},5611:(t,e,r)=>{"use strict";r.d(e,{I:()=>C,v:()=>P});var i=r(9113),n=r(3012),s=r(268);function o(t,e,r){if(t)for(const i in t){const n=e[i.toLocaleLowerCase()];if(n){let e=t[i];"header"===i&&(e=e.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),r&&n.push(`//----${r}----//`),n.push(e)}else(0,s.R)(`${i} placement hook does not exist in shader`)}}const a=/\{\{(.*?)\}\}/g;function l(t){const e={};return(t.match(a)?.map(t=>t.replace(/[{()}]/g,""))??[]).forEach(t=>{e[t]=[]}),e}function h(t,e){let r;const i=/@in\s+([^;]+);/g;for(;null!==(r=i.exec(t));)e.push(r[1])}function u(t,e,r=!1){const i=[];h(e,i),t.forEach(t=>{t.header&&h(t.header,i)});const n=i;r&&n.sort();const s=n.map((t,e)=>`       @location(${e}) ${t},`).join("\n");let o=e.replace(/@in\s+[^;]+;\s*/g,"");return o=o.replace("{{in}}",`\n${s}\n`),o}function c(t,e){let r;const i=/@out\s+([^;]+);/g;for(;null!==(r=i.exec(t));)e.push(r[1])}function d(t,e){let r=t;for(const t in e){const i=e[t];r=i.join("\n").length?r.replace(`{{${t}}}`,`//-----${t} START-----//\n${i.join("\n")}\n//----${t} FINISH----//`):r.replace(`{{${t}}}`,"")}return r}const f=Object.create(null),p=new Map;let g=0;function x({template:t,bits:e}){const r=m(t,e);return f[r]||(f[r]=y(t.vertex,t.fragment,e)),f[r]}function m(t,e){return e.map(t=>(p.has(t)||p.set(t,g++),p.get(t))).sort((t,e)=>t-e).join("-")+t.vertex+t.fragment}function y(t,e,r){const i=l(t),n=l(e);return r.forEach(t=>{o(t.vertex,i,t.name),o(t.fragment,n,t.name)}),{vertex:d(t,i),fragment:d(e,n)}}const _="\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n",b="\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n",v="\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n",S="\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n",w={name:"global-uniforms-bit",vertex:{header:"\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        "}},T={name:"global-uniforms-bit",vertex:{header:"\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        "}};function P({bits:t,name:e}){const r=function({template:t,bits:e}){const r=m(t,e);if(f[r])return f[r];const{vertex:i,fragment:n}=function(t,e){const r=e.map(t=>t.vertex).filter(t=>!!t),i=e.map(t=>t.fragment).filter(t=>!!t);let n=u(r,t.vertex,!0);return n=function(t,e){const r=[];c(e,r),t.forEach(t=>{t.header&&c(t.header,r)});let i=0;const n=r.sort().map(t=>t.indexOf("builtin")>-1?t:`@location(${i++}) ${t}`).join(",\n"),s=r.sort().map(t=>{return`       var ${e=t,e.replace(/@.*?\s+/g,"")};`;var e}).join("\n"),o=`return VSOutput(\n            ${r.sort().map(t=>` ${function(t){const e=/\b(\w+)\s*:/g.exec(t);return e?e[1]:""}(t)}`).join(",\n")});`;let a=e.replace(/@out\s+[^;]+;\s*/g,"");return a=a.replace("{{struct}}",`\n${n}\n`),a=a.replace("{{start}}",`\n${s}\n`),a=a.replace("{{return}}",`\n${o}\n`),a}(r,n),{vertex:n,fragment:u(i,t.fragment,!0)}}(t,e);return f[r]=y(i,n,e),f[r]}({template:{fragment:b,vertex:_},bits:[w,...t]});return n.B.from({name:e,vertex:{source:r.vertex,entryPoint:"main"},fragment:{source:r.fragment,entryPoint:"main"}})}function C({bits:t,name:e}){return new i.M({name:e,...x({template:{vertex:v,fragment:S},bits:[T,...t]})})}},5811:(t,e,r)=>{"use strict";r.d(e,{k:()=>h});var i=r(133),n=r(7952);const s=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>","vec2<i32>","vec3<i32>","vec4<i32>"],o=s.reduce((t,e)=>(t[e]=!0,t),{});function a(t,e){switch(t){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*e);case"vec3<f32>":return new Float32Array(3*e);case"vec4<f32>":return new Float32Array(4*e);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const l=class t{constructor(e,r){this._touched=0,this.uid=(0,i.L)("uniform"),this._resourceType="uniformGroup",this._resourceId=(0,i.L)("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,r={...t.defaultOptions,...r},this.uniformStructures=e;const l={};for(const t in e){const r=e[t];if(r.name=t,r.size=r.size??1,!o[r.type]){const t=r.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);if(t){const[,e,i]=t;throw new Error(`Uniform type ${r.type} is not supported. Use type: '${e}', size: ${i} instead.`)}throw new Error(`Uniform type ${r.type} is not supported. Supported uniform types are: ${s.join(", ")}`)}r.value??(r.value=a(r.type,r.size)),l[t]=r.value}this.uniforms=l,this._dirtyId=1,this.ubo=r.ubo,this.isStatic=r.isStatic,this._signature=(0,n.X)(Object.keys(l).map(t=>`${t}-${e[t].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};l.defaultOptions={ubo:!1,isStatic:!1};let h=l},5957:(t,e,r)=>{"use strict";r.d(e,{g:()=>n});class i{constructor(t=0,e=0,r=!1){this.first=null,this.items=Object.create(null),this.last=null,this.max=t,this.resetTtl=r,this.size=0,this.ttl=e}clear(){return this.first=null,this.items=Object.create(null),this.last=null,this.size=0,this}delete(t){if(this.has(t)){const e=this.items[t];delete this.items[t],this.size--,null!==e.prev&&(e.prev.next=e.next),null!==e.next&&(e.next.prev=e.prev),this.first===e&&(this.first=e.next),this.last===e&&(this.last=e.prev)}return this}entries(t=this.keys()){return t.map(t=>[t,this.get(t)])}evict(t=!1){if(t||this.size>0){const t=this.first;delete this.items[t.key],0===--this.size?(this.first=null,this.last=null):(this.first=t.next,this.first.prev=null)}return this}expiresAt(t){let e;return this.has(t)&&(e=this.items[t].expiry),e}get(t){const e=this.items[t];if(void 0!==e)return this.ttl>0&&e.expiry<=Date.now()?void this.delete(t):(this.moveToEnd(e),e.value)}has(t){return t in this.items}moveToEnd(t){this.last!==t&&(null!==t.prev&&(t.prev.next=t.next),null!==t.next&&(t.next.prev=t.prev),this.first===t&&(this.first=t.next),t.prev=this.last,t.next=null,null!==this.last&&(this.last.next=t),this.last=t,null===this.first&&(this.first=t))}keys(){const t=[];let e=this.first;for(;null!==e;)t.push(e.key),e=e.next;return t}setWithEvicted(t,e,r=this.resetTtl){let i=null;if(this.has(t))this.set(t,e,!0,r);else{this.max>0&&this.size===this.max&&(i={...this.first},this.evict(!0));let r=this.items[t]={expiry:this.ttl>0?Date.now()+this.ttl:this.ttl,key:t,prev:this.last,next:null,value:e};1===++this.size?this.first=r:this.last.next=r,this.last=r}return i}set(t,e,r=!1,i=this.resetTtl){let n=this.items[t];return r||void 0!==n?(n.value=e,!1===r&&i&&(n.expiry=this.ttl>0?Date.now()+this.ttl:this.ttl),this.moveToEnd(n)):(this.max>0&&this.size===this.max&&this.evict(!0),n=this.items[t]={expiry:this.ttl>0?Date.now()+this.ttl:this.ttl,key:t,prev:this.last,next:null,value:e},1===++this.size?this.first=n:this.last.next=n,this.last=n),this}values(t=this.keys()){return t.map(t=>this.get(t))}}function n(t=1e3,e=0,r=!1){if(isNaN(t)||t<0)throw new TypeError("Invalid max value");if(isNaN(e)||e<0)throw new TypeError("Invalid ttl value");if("boolean"!=typeof r)throw new TypeError("Invalid resetTtl value");return new i(t,e,r)}},6011:(t,e,r)=>{"use strict";r.d(e,{V:()=>h});var i=r(4486),n=r(9636),s=r(133),o=r(949),a=r(1132);function l(t,e){if(!(t instanceof o.h)){let r=e?a.S.INDEX:a.S.VERTEX;t instanceof Array&&(e?(t=new Uint32Array(t),r=a.S.INDEX|a.S.COPY_DST):(t=new Float32Array(t),r=a.S.VERTEX|a.S.COPY_DST)),t=new o.h({data:t,label:e?"index-mesh-buffer":"vertex-mesh-buffer",usage:r})}return t}class h extends i.A{constructor(t={}){super(),this.uid=(0,s.L)("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new n.c,this._boundsDirty=!0;const{attributes:e,indexBuffer:r,topology:i}=t;if(this.buffers=[],this.attributes={},e)for(const t in e)this.addAttribute(t,e[t]);this.instanceCount=t.instanceCount??1,r&&this.addIndex(r),this.topology=i||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(t){return this.attributes[t]}getIndex(){return this.indexBuffer}getBuffer(t){return this.getAttribute(t).buffer}getSize(){for(const t in this.attributes){const e=this.attributes[t];return e.buffer.data.length/(e.stride/4||e.size)}return 0}addAttribute(t,e){const r=function(t){return(t instanceof o.h||Array.isArray(t)||t.BYTES_PER_ELEMENT)&&(t={buffer:t}),t.buffer=l(t.buffer,!1),t}(e);-1===this.buffers.indexOf(r.buffer)&&(this.buffers.push(r.buffer),r.buffer.on("update",this.onBufferUpdate,this),r.buffer.on("change",this.onBufferUpdate,this)),this.attributes[t]=r}addIndex(t){this.indexBuffer=l(t,!0),this.buffers.push(this.indexBuffer)}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,function(t,e,r){const i=t.getAttribute("aPosition");if(!i)return r.minX=0,r.minY=0,r.maxX=0,r.maxY=0,r;const n=i.buffer.data;let s=1/0,o=1/0,a=-1/0,l=-1/0;const h=n.BYTES_PER_ELEMENT,u=(i.offset||0)/h,c=(i.stride||8)/h;for(let t=u;t<n.length;t+=c){const e=n[t],r=n[t+1];e>a&&(a=e),r>l&&(l=r),e<s&&(s=e),r<o&&(o=r)}return r.minX=s,r.minY=o,r.maxX=a,r.maxY=l,r}(this,0,this._bounds)):this._bounds}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners(),t&&this.buffers.forEach(t=>t.destroy()),this.indexBuffer?.destroy(),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}},6040:(t,e,r)=>{"use strict";r.d(e,{n:()=>s});var i=r(5811);const n={};function s(t){let e=n[t];if(e)return e;const r=new Int32Array(t);for(let e=0;e<t;e++)r[e]=e;return e=n[t]=new i.k({uTextures:{value:r,type:"i32",size:t}},{isStatic:!0}),e}},6442:(t,e,r)=>{"use strict";r.d(e,{GH:()=>jt});var i=r(8507),n=r(3513),s=r(7174);const o={};function a(t,e,r){let i=2166136261;for(let r=0;r<e;r++)i^=t[r].uid,i=Math.imul(i,16777619),i>>>=0;return o[i]||function(t,e,r,i){const a={};let l=0;for(let r=0;r<i;r++){const i=r<e?t[r]:s.g.EMPTY.source;a[l++]=i.source,a[l++]=i.style}const h=new n.T(a);return o[r]=h,h}(t,e,i,r)}var l=r(133),h=r(1460),u=r(4670),c=r(6083);function d(t,e){const r=t.byteLength/8|0,i=new Float64Array(t,0,r);new Float64Array(e,0,r).set(i);const n=t.byteLength-8*r;if(n>0){const i=new Uint8Array(t,8*r,n);new Uint8Array(e,8*r,n).set(i)}}var f=r(2331),p=r(3804);const g=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join("\n");function x(t){let e="";for(let r=0;r<t;++r)r>0&&(e+="\nelse "),r<t-1&&(e+=`if(test == ${r}.0){}`);return e}let m=null;class y{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let t=0;t<this.count;t++){const e=this.textures[t];this.textures[t]=null,this.ids[e.uid]=null}this.count=0}}class _{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.textures=new y,this.blendMode="normal",this.topology="triangle-strip",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}const b=[];let v=0;function S(){return v>0?b[--v]:new _}function w(t){b[v++]=t}c.L.register({clear:()=>{if(b.length>0)for(const t of b)t&&t.destroy();b.length=0,v=0}});let T=0;const P=class t{constructor(e){this.uid=(0,l.L)("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._elements=[],(e={...t.defaultOptions,...e}).maxTextures||((0,u.t6)("v8.8.0","maxTextures is a required option for Batcher now, please pass it in the options"),e.maxTextures=function(){if(m)return m;const t=(0,p.W)();return m=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),m=function(t,e){if(0===t)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const r=e.createShader(e.FRAGMENT_SHADER);try{for(;;){const i=g.replace(/%forloop%/gi,x(t));if(e.shaderSource(r,i),e.compileShader(r),e.getShaderParameter(r,e.COMPILE_STATUS))break;t=t/2|0}}finally{e.deleteShader(r)}return t}(m,t),t.getExtension("WEBGL_lose_context")?.loseContext(),m}());const{maxTextures:r,attributesInitialSize:i,indicesInitialSize:n}=e;this.attributeBuffer=new h.u(4*i),this.indexBuffer=new Uint16Array(n),this.maxTextures=r}begin(){this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0;for(let t=0;t<this.batchIndex;t++)w(this.batches[t]);this.batchIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(t){this._elements[this.elementSize++]=t,t._indexStart=this.indexSize,t._attributeStart=this.attributeSize,t._batcher=this,this.indexSize+=t.indexSize,this.attributeSize+=t.attributeSize*this.vertexSize}checkAndUpdateTexture(t,e){const r=t._batch.textures.ids[e._source.uid];return!(!r&&0!==r||(t._textureId=r,t.texture=e,0))}updateElement(t){this.dirty=!0;const e=this.attributeBuffer;t.packAsQuad?this.packQuadAttributes(t,e.float32View,e.uint32View,t._attributeStart,t._textureId):this.packAttributes(t,e.float32View,e.uint32View,t._attributeStart,t._textureId)}break(t){const e=this._elements;if(!e[this.elementStart])return;let r=S(),i=r.textures;i.clear();const n=e[this.elementStart];let s=(0,f.i)(n.blendMode,n.texture._source),o=n.topology;4*this.attributeSize>this.attributeBuffer.size&&this._resizeAttributeBuffer(4*this.attributeSize),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const a=this.attributeBuffer.float32View,l=this.attributeBuffer.uint32View,h=this.indexBuffer;let u=this._batchIndexSize,c=this._batchIndexStart,d="startBatch";const p=this.maxTextures;for(let n=this.elementStart;n<this.elementSize;++n){const g=e[n];e[n]=null;const x=g.texture._source,m=(0,f.i)(g.blendMode,x),y=s!==m||o!==g.topology;x._batchTick!==T||y?(x._batchTick=T,(i.count>=p||y)&&(this._finishBatch(r,c,u-c,i,s,o,t,d),d="renderBatch",c=u,s=m,o=g.topology,r=S(),i=r.textures,i.clear(),++T),g._textureId=x._textureBindLocation=i.count,i.ids[x.uid]=i.count,i.textures[i.count++]=x,g._batch=r,u+=g.indexSize,g.packAsQuad?(this.packQuadAttributes(g,a,l,g._attributeStart,g._textureId),this.packQuadIndex(h,g._indexStart,g._attributeStart/this.vertexSize)):(this.packAttributes(g,a,l,g._attributeStart,g._textureId),this.packIndex(g,h,g._indexStart,g._attributeStart/this.vertexSize))):(g._textureId=x._textureBindLocation,u+=g.indexSize,g.packAsQuad?(this.packQuadAttributes(g,a,l,g._attributeStart,g._textureId),this.packQuadIndex(h,g._indexStart,g._attributeStart/this.vertexSize)):(this.packAttributes(g,a,l,g._attributeStart,g._textureId),this.packIndex(g,h,g._indexStart,g._attributeStart/this.vertexSize)),g._batch=r)}i.count>0&&(this._finishBatch(r,c,u-c,i,s,o,t,d),c=u,++T),this.elementStart=this.elementSize,this._batchIndexStart=c,this._batchIndexSize=u}_finishBatch(t,e,r,i,n,s,o,a){t.gpuBindGroup=null,t.bindGroup=null,t.action=a,t.batcher=this,t.textures=i,t.blendMode=n,t.topology=s,t.start=e,t.size=r,++T,this.batches[this.batchIndex++]=t,o.add(t)}finish(t){this.break(t)}ensureAttributeBuffer(t){4*t<=this.attributeBuffer.size||this._resizeAttributeBuffer(4*t)}ensureIndexBuffer(t){t<=this.indexBuffer.length||this._resizeIndexBuffer(t)}_resizeAttributeBuffer(t){const e=Math.max(t,2*this.attributeBuffer.size),r=new h.u(e);d(this.attributeBuffer.rawBinaryData,r.rawBinaryData),this.attributeBuffer=r}_resizeIndexBuffer(t){const e=this.indexBuffer;let r=Math.max(t,1.5*e.length);r+=r%2;const i=r>65535?new Uint32Array(r):new Uint16Array(r);if(i.BYTES_PER_ELEMENT!==e.BYTES_PER_ELEMENT)for(let t=0;t<e.length;t++)i[t]=e[t];else d(e.buffer,i.buffer);this.indexBuffer=i}packQuadIndex(t,e,r){t[e]=r+0,t[e+1]=r+1,t[e+2]=r+2,t[e+3]=r+0,t[e+4]=r+2,t[e+5]=r+3}packIndex(t,e,r,i){const n=t.indices,s=t.indexSize,o=t.indexOffset,a=t.attributeOffset;for(let t=0;t<s;t++)e[r++]=i+n[t+o]-a}destroy(t={}){if(null!==this.batches){for(let t=0;t<this.batches.length;t++)w(this.batches[t]);this.batches=null,this.geometry.destroy(!0),this.geometry=null,t.shader&&(this.shader?.destroy(),this.shader=null);for(let t=0;t<this._elements.length;t++)this._elements[t]&&(this._elements[t]._batch=null);this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}}};P.defaultOptions={maxTextures:null,attributesInitialSize:4,indicesInitialSize:6};let C=P;var M=r(949),k=r(1132),A=r(6011);const R=new Float32Array(1),F=new Uint32Array(1);class z extends A.V{constructor(){const t=new M.h({data:R,label:"attribute-batch-buffer",usage:k.S.VERTEX|k.S.COPY_DST,shrinkToFit:!1});super({attributes:{aPosition:{buffer:t,format:"float32x2",stride:24,offset:0},aUV:{buffer:t,format:"float32x2",stride:24,offset:8},aColor:{buffer:t,format:"unorm8x4",stride:24,offset:16},aTextureIdAndRound:{buffer:t,format:"uint16x2",stride:24,offset:20}},indexBuffer:new M.h({data:F,label:"index-batch-buffer",usage:k.S.INDEX|k.S.COPY_DST,shrinkToFit:!1})})}}var B=r(5611),U=r(4459),I=r(4e3),G=r(6665),D=r(6040),E=r(8475);class O extends E.M{constructor(t){super({glProgram:(0,B.I)({name:"batch",bits:[U.a,(0,I.P)(t),G.m]}),gpuProgram:(0,B.v)({name:"batch",bits:[U.F,(0,I._)(t),G.b]}),resources:{batchSamplers:(0,D.n)(t)}}),this.maxTextures=t}}let V=null;const W=class t extends C{constructor(e){super(e),this.geometry=new z,this.name=t.extension.name,this.vertexSize=6,V??(V=new O(e.maxTextures)),this.shader=V}packAttributes(t,e,r,i,n){const s=n<<16|65535&t.roundPixels,o=t.transform,a=o.a,l=o.b,h=o.c,u=o.d,c=o.tx,d=o.ty,{positions:f,uvs:p}=t,g=t.color,x=t.attributeOffset,m=x+t.attributeSize;for(let t=x;t<m;t++){const n=2*t,o=f[n],x=f[n+1];e[i++]=a*o+h*x+c,e[i++]=u*x+l*o+d,e[i++]=p[n],e[i++]=p[n+1],r[i++]=g,r[i++]=s}}packQuadAttributes(t,e,r,i,n){const s=t.texture,o=t.transform,a=o.a,l=o.b,h=o.c,u=o.d,c=o.tx,d=o.ty,f=t.bounds,p=f.maxX,g=f.minX,x=f.maxY,m=f.minY,y=s.uvs,_=t.color,b=n<<16|65535&t.roundPixels;e[i+0]=a*g+h*m+c,e[i+1]=u*m+l*g+d,e[i+2]=y.x0,e[i+3]=y.y0,r[i+4]=_,r[i+5]=b,e[i+6]=a*p+h*m+c,e[i+7]=u*m+l*p+d,e[i+8]=y.x1,e[i+9]=y.y1,r[i+10]=_,r[i+11]=b,e[i+12]=a*p+h*x+c,e[i+13]=u*x+l*p+d,e[i+14]=y.x2,e[i+15]=y.y2,r[i+16]=_,r[i+17]=b,e[i+18]=a*g+h*x+c,e[i+19]=u*x+l*g+d,e[i+20]=y.x3,e[i+21]=y.y3,r[i+22]=_,r[i+23]=b}_updateMaxTextures(t){this.shader.maxTextures!==t&&(V=new O(t),this.shader=V)}destroy(){this.shader=null,super.destroy()}};W.extension={type:[i.Ag.Batcher],name:"default"};let L=W;var $=r(848),H=r(8655),j=r(9313),X=r(9252);function N(t,e,r,i,n){const s=e.a,o=e.b,a=e.c,l=e.d,h=e.tx,u=e.ty;r||(r=0),i||(i=2),n||(n=t.length/i-r);let c=r*i;for(let e=0;e<n;e++){const e=t[c],r=t[c+1];t[c]=s*e+a*r+h,t[c+1]=o*e+l*r+u,c+=i}}var Y=r(6954);const q={extension:{type:i.Ag.ShapeBuilder,name:"circle"},build(t,e){let r,i,n,s,o,a;if("circle"===t.type){const e=t;if(o=a=e.radius,o<=0)return!1;r=e.x,i=e.y,n=s=0}else if("ellipse"===t.type){const e=t;if(o=e.halfWidth,a=e.halfHeight,o<=0||a<=0)return!1;r=e.x,i=e.y,n=s=0}else{const e=t,l=e.width/2,h=e.height/2;r=e.x+l,i=e.y+h,o=a=Math.max(0,Math.min(e.radius,Math.min(l,h))),n=l-o,s=h-a}if(n<0||s<0)return!1;const l=Math.ceil(2.3*Math.sqrt(o+a)),h=8*l+(n?4:0)+(s?4:0);if(0===h)return!1;if(0===l)return e[0]=e[6]=r+n,e[1]=e[3]=i+s,e[2]=e[4]=r-n,e[5]=e[7]=i-s,!0;let u=0,c=4*l+(n?2:0)+2,d=c,f=h,p=n+o,g=s,x=r+p,m=r-p,y=i+g;if(e[u++]=x,e[u++]=y,e[--c]=y,e[--c]=m,s){const t=i-g;e[d++]=m,e[d++]=t,e[--f]=t,e[--f]=x}for(let t=1;t<l;t++){const h=Math.PI/2*(t/l),p=n+Math.cos(h)*o,g=s+Math.sin(h)*a,x=r+p,m=r-p,y=i+g,_=i-g;e[u++]=x,e[u++]=y,e[--c]=y,e[--c]=m,e[d++]=m,e[d++]=_,e[--f]=_,e[--f]=x}p=n,g=s+a,x=r+p,m=r-p,y=i+g;const _=i-g;return e[u++]=x,e[u++]=y,e[--f]=_,e[--f]=x,n&&(e[u++]=m,e[u++]=y,e[--f]=_,e[--f]=m),!0},triangulate(t,e,r,i,n,s){if(0===t.length)return;let o=0,a=0;for(let e=0;e<t.length;e+=2)o+=t[e],a+=t[e+1];o/=t.length/2,a/=t.length/2;let l=i;e[l*r]=o,e[l*r+1]=a;const h=l++;for(let i=0;i<t.length;i+=2)e[l*r]=t[i],e[l*r+1]=t[i+1],i>0&&(n[s++]=l,n[s++]=h,n[s++]=l-1),l++;n[s++]=h+1,n[s++]=h,n[s++]=l-1}},K={...q,extension:{...q.extension,name:"ellipse"}},Z={...q,extension:{...q.extension,name:"roundedRectangle"}};var Q=r(5101);const J=1e-4;function tt(t,e,r,i,n,s,o,a){let l,h;o?(l=i,h=-r):(l=-i,h=r);const u=t-r*n+l,c=e-i*n+h,d=t+r*s+l,f=e+i*s+h;return a.push(u,c),a.push(d,f),2}function et(t,e,r,i,n,s,o,a){const l=r-t,h=i-e;let u=Math.atan2(l,h),c=Math.atan2(n-t,s-e);a&&u<c?u+=2*Math.PI:!a&&u>c&&(c+=2*Math.PI);let d=u;const f=c-u,p=Math.abs(f),g=Math.sqrt(l*l+h*h),x=1+(15*p*Math.sqrt(g)/Math.PI|0),m=f/x;if(d+=m,a){o.push(t,e),o.push(r,i);for(let r=1,i=d;r<x;r++,i+=m)o.push(t,e),o.push(t+Math.sin(i)*g,e+Math.cos(i)*g);o.push(t,e),o.push(n,s)}else{o.push(r,i),o.push(t,e);for(let r=1,i=d;r<x;r++,i+=m)o.push(t+Math.sin(i)*g,e+Math.cos(i)*g),o.push(t,e);o.push(n,s),o.push(t,e)}return 2*x}function rt(t,e,r=2){const i=e&&e.length,n=i?e[0]*r:t.length;let s=it(t,0,n,r,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,h;if(i&&(s=function(t,e,r,i){const n=[];for(let r=0,s=e.length;r<s;r++){const o=it(t,e[r]*i,r<s-1?e[r+1]*i:t.length,i,!1);o===o.next&&(o.steiner=!0),n.push(pt(o))}n.sort(ut);for(let t=0;t<n.length;t++)r=ct(n[t],r);return r}(t,e,s,r)),t.length>80*r){a=t[0],l=t[1];let e=a,i=l;for(let s=r;s<n;s+=r){const r=t[s],n=t[s+1];r<a&&(a=r),n<l&&(l=n),r>e&&(e=r),n>i&&(i=n)}h=Math.max(e-a,i-l),h=0!==h?32767/h:0}return st(s,o,r,a,l,h,0),o}function it(t,e,r,i,n){let s;if(n===function(t,e,r,i){let n=0;for(let s=e,o=r-i;s<r;s+=i)n+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return n}(t,e,r,i)>0)for(let n=e;n<r;n+=i)s=Pt(n/i|0,t[n],t[n+1],s);else for(let n=r-i;n>=e;n-=i)s=Pt(n/i|0,t[n],t[n+1],s);return s&&_t(s,s.next)&&(Ct(s),s=s.next),s}function nt(t,e){if(!t)return t;e||(e=t);let r,i=t;do{if(r=!1,i.steiner||!_t(i,i.next)&&0!==yt(i.prev,i,i.next))i=i.next;else{if(Ct(i),i=e=i.prev,i===i.next)break;r=!0}}while(r||i!==e);return e}function st(t,e,r,i,n,s,o){if(!t)return;!o&&s&&function(t,e,r,i){let n=t;do{0===n.z&&(n.z=ft(n.x,n.y,e,r,i)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next}while(n!==t);n.prevZ.nextZ=null,n.prevZ=null,function(t){let e,r=1;do{let i,n=t;t=null;let s=null;for(e=0;n;){e++;let o=n,a=0;for(let t=0;t<r&&(a++,o=o.nextZ,o);t++);let l=r;for(;a>0||l>0&&o;)0!==a&&(0===l||!o||n.z<=o.z)?(i=n,n=n.nextZ,a--):(i=o,o=o.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;n=o}s.nextZ=null,r*=2}while(e>1)}(n)}(t,i,n,s);let a=t;for(;t.prev!==t.next;){const l=t.prev,h=t.next;if(s?at(t,i,n,s):ot(t))e.push(l.i,t.i,h.i),Ct(t),t=h.next,a=h.next;else if((t=h)===a){o?1===o?st(t=lt(nt(t),e),e,r,i,n,s,2):2===o&&ht(t,e,r,i,n,s):st(nt(t),e,r,i,n,s,1);break}}}function ot(t){const e=t.prev,r=t,i=t.next;if(yt(e,r,i)>=0)return!1;const n=e.x,s=r.x,o=i.x,a=e.y,l=r.y,h=i.y,u=Math.min(n,s,o),c=Math.min(a,l,h),d=Math.max(n,s,o),f=Math.max(a,l,h);let p=i.next;for(;p!==e;){if(p.x>=u&&p.x<=d&&p.y>=c&&p.y<=f&&xt(n,a,s,l,o,h,p.x,p.y)&&yt(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function at(t,e,r,i){const n=t.prev,s=t,o=t.next;if(yt(n,s,o)>=0)return!1;const a=n.x,l=s.x,h=o.x,u=n.y,c=s.y,d=o.y,f=Math.min(a,l,h),p=Math.min(u,c,d),g=Math.max(a,l,h),x=Math.max(u,c,d),m=ft(f,p,e,r,i),y=ft(g,x,e,r,i);let _=t.prevZ,b=t.nextZ;for(;_&&_.z>=m&&b&&b.z<=y;){if(_.x>=f&&_.x<=g&&_.y>=p&&_.y<=x&&_!==n&&_!==o&&xt(a,u,l,c,h,d,_.x,_.y)&&yt(_.prev,_,_.next)>=0)return!1;if(_=_.prevZ,b.x>=f&&b.x<=g&&b.y>=p&&b.y<=x&&b!==n&&b!==o&&xt(a,u,l,c,h,d,b.x,b.y)&&yt(b.prev,b,b.next)>=0)return!1;b=b.nextZ}for(;_&&_.z>=m;){if(_.x>=f&&_.x<=g&&_.y>=p&&_.y<=x&&_!==n&&_!==o&&xt(a,u,l,c,h,d,_.x,_.y)&&yt(_.prev,_,_.next)>=0)return!1;_=_.prevZ}for(;b&&b.z<=y;){if(b.x>=f&&b.x<=g&&b.y>=p&&b.y<=x&&b!==n&&b!==o&&xt(a,u,l,c,h,d,b.x,b.y)&&yt(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function lt(t,e){let r=t;do{const i=r.prev,n=r.next.next;!_t(i,n)&&bt(i,r,r.next,n)&&wt(i,n)&&wt(n,i)&&(e.push(i.i,r.i,n.i),Ct(r),Ct(r.next),r=t=n),r=r.next}while(r!==t);return nt(r)}function ht(t,e,r,i,n,s){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&mt(o,t)){let a=Tt(o,t);return o=nt(o,o.next),a=nt(a,a.next),st(o,e,r,i,n,s,0),void st(a,e,r,i,n,s,0)}t=t.next}o=o.next}while(o!==t)}function ut(t,e){let r=t.x-e.x;return 0===r&&(r=t.y-e.y,0===r)&&(r=(t.next.y-t.y)/(t.next.x-t.x)-(e.next.y-e.y)/(e.next.x-e.x)),r}function ct(t,e){const r=function(t,e){let r=e;const i=t.x,n=t.y;let s,o=-1/0;if(_t(t,r))return r;do{if(_t(t,r.next))return r.next;if(n<=r.y&&n>=r.next.y&&r.next.y!==r.y){const t=r.x+(n-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(t<=i&&t>o&&(o=t,s=r.x<r.next.x?r:r.next,t===i))return s}r=r.next}while(r!==e);if(!s)return null;const a=s,l=s.x,h=s.y;let u=1/0;r=s;do{if(i>=r.x&&r.x>=l&&i!==r.x&&gt(n<h?i:o,n,l,h,n<h?o:i,n,r.x,r.y)){const e=Math.abs(n-r.y)/(i-r.x);wt(r,t)&&(e<u||e===u&&(r.x>s.x||r.x===s.x&&dt(s,r)))&&(s=r,u=e)}r=r.next}while(r!==a);return s}(t,e);if(!r)return e;const i=Tt(r,t);return nt(i,i.next),nt(r,r.next)}function dt(t,e){return yt(t.prev,t,e.prev)<0&&yt(e.next,t,t.next)<0}function ft(t,e,r,i,n){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*n|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*n|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function pt(t){let e=t,r=t;do{(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next}while(e!==t);return r}function gt(t,e,r,i,n,s,o,a){return(n-o)*(e-a)>=(t-o)*(s-a)&&(t-o)*(i-a)>=(r-o)*(e-a)&&(r-o)*(s-a)>=(n-o)*(i-a)}function xt(t,e,r,i,n,s,o,a){return!(t===o&&e===a)&&gt(t,e,r,i,n,s,o,a)}function mt(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&bt(r,r.next,t,e))return!0;r=r.next}while(r!==t);return!1}(t,e)&&(wt(t,e)&&wt(e,t)&&function(t,e){let r=t,i=!1;const n=(t.x+e.x)/2,s=(t.y+e.y)/2;do{r.y>s!=r.next.y>s&&r.next.y!==r.y&&n<(r.next.x-r.x)*(s-r.y)/(r.next.y-r.y)+r.x&&(i=!i),r=r.next}while(r!==t);return i}(t,e)&&(yt(t.prev,t,e.prev)||yt(t,e.prev,e))||_t(t,e)&&yt(t.prev,t,t.next)>0&&yt(e.prev,e,e.next)>0)}function yt(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function _t(t,e){return t.x===e.x&&t.y===e.y}function bt(t,e,r,i){const n=St(yt(t,e,r)),s=St(yt(t,e,i)),o=St(yt(r,i,t)),a=St(yt(r,i,e));return n!==s&&o!==a||!(0!==n||!vt(t,r,e))||!(0!==s||!vt(t,i,e))||!(0!==o||!vt(r,t,i))||!(0!==a||!vt(r,e,i))}function vt(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function St(t){return t>0?1:t<0?-1:0}function wt(t,e){return yt(t.prev,t,t.next)<0?yt(t,e,t.next)>=0&&yt(t,t.prev,e)>=0:yt(t,e,t.prev)<0||yt(t,t.next,e)<0}function Tt(t,e){const r=Mt(t.i,t.x,t.y),i=Mt(e.i,e.x,e.y),n=t.next,s=e.prev;return t.next=e,e.prev=t,r.next=n,n.prev=r,i.next=r,r.prev=i,s.next=i,i.prev=s,i}function Pt(t,e,r,i){const n=Mt(t,e,r);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function Ct(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Mt(t,e,r){return{i:t,x:e,y:r,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}r(4486);const kt=rt.default||rt;function At(t,e,r,i,n,s,o){const a=kt(t,e,2);if(!a)return;for(let t=0;t<a.length;t+=3)s[o++]=a[t]+n,s[o++]=a[t+1]+n,s[o++]=a[t+2]+n;let l=n*i;for(let e=0;e<t.length;e+=2)r[l]=t[e],r[l+1]=t[e+1],l+=i}const Rt=[],Ft={extension:{type:i.Ag.ShapeBuilder,name:"polygon"},build(t,e){for(let r=0;r<t.points.length;r++)e[r]=t.points[r];return!0},triangulate(t,e,r,i,n,s){At(t,Rt,e,r,i,n,s)}},zt={extension:{type:i.Ag.ShapeBuilder,name:"rectangle"},build(t,e){const r=t,i=r.x,n=r.y,s=r.width,o=r.height;return s>0&&o>0&&(e[0]=i,e[1]=n,e[2]=i+s,e[3]=n,e[4]=i+s,e[5]=n+o,e[6]=i,e[7]=n+o,!0)},triangulate(t,e,r,i,n,s){let o=0;e[(i*=r)+o]=t[0],e[i+o+1]=t[1],o+=r,e[i+o]=t[2],e[i+o+1]=t[3],o+=r,e[i+o]=t[6],e[i+o+1]=t[7],o+=r,e[i+o]=t[4],e[i+o+1]=t[5],o+=r;const a=i/r;n[s++]=a,n[s++]=a+1,n[s++]=a+2,n[s++]=a+1,n[s++]=a+3,n[s++]=a+2}},Bt={extension:{type:i.Ag.ShapeBuilder,name:"triangle"},build:(t,e)=>(e[0]=t.x,e[1]=t.y,e[2]=t.x2,e[3]=t.y2,e[4]=t.x3,e[5]=t.y3,!0),triangulate(t,e,r,i,n,s){let o=0;e[(i*=r)+o]=t[0],e[i+o+1]=t[1],o+=r,e[i+o]=t[2],e[i+o+1]=t[3],o+=r,e[i+o]=t[4],e[i+o+1]=t[5];const a=i/r;n[s++]=a,n[s++]=a+1,n[s++]=a+2}};var Ut=r(7276);const It=new j.u,Gt=new X.M,Dt={};i.XO.handleByMap(i.Ag.ShapeBuilder,Dt),i.XO.add(zt,Ft,Bt,q,K,Z);const Et=new X.M,Ot=new j.u;function Vt(t,e,r){const i=[],n=Dt.rectangle,s=Et;s.x=t.dx,s.y=t.dy,s.width=t.dw,s.height=t.dh;const o=t.transform;if(!n.build(s,i))return;const{vertices:a,uvs:l,indices:h}=r,u=h.length,c=a.length/2;o&&N(i,o),n.triangulate(i,a,2,c,h,u);const d=t.image,f=d.uvs;l.push(f.x0,f.y0,f.x1,f.y1,f.x3,f.y3,f.x2,f.y2);const p=H.Z.get(Y.G);p.indexOffset=u,p.indexSize=h.length-u,p.attributeOffset=c,p.attributeSize=a.length/2-c,p.baseColor=t.style,p.alpha=t.alpha,p.texture=d,p.geometryData=r,e.push(p)}function Wt(t,e,r,i,n){const{vertices:o,uvs:a,indices:l}=n;t.shapePrimitives.forEach(({shape:t,transform:h,holes:u})=>{const c=[],d=Dt[t.type];if(!d.build(t,c))return;const f=l.length,p=o.length/2;let g="triangle-list";if(h&&N(c,h),r){const r=t.closePath??!0,i=e;i.pixelLine?(function(t,e,r,i){const n=J;if(0===t.length)return;const s=t[0],o=t[1],a=t[t.length-2],l=t[t.length-1],h=e||Math.abs(s-a)<n&&Math.abs(o-l)<n,u=r,c=t.length/2,d=u.length/2;for(let e=0;e<c;e++)u.push(t[2*e]),u.push(t[2*e+1]);for(let t=0;t<c-1;t++)i.push(d+t,d+t+1);h&&i.push(d+c-1,d)}(c,r,o,l),g="line-list"):function(t,e,r,i,n,s){const o=J;if(0===t.length)return;const a=e;let l=a.alignment;if(.5!==e.alignment){let e=function(t){const e=t.length;if(e<6)return 1;let r=0;for(let i=0,n=t[e-2],s=t[e-1];i<e;i+=2){const e=t[i],o=t[i+1];r+=(e-n)*(o+s),n=e,s=o}return r<0?-1:1}(t);l=(l-.5)*e+.5}const h=new Q.b(t[0],t[1]),u=new Q.b(t[t.length-2],t[t.length-1]),c=i,d=Math.abs(h.x-u.x)<o&&Math.abs(h.y-u.y)<o;if(c){t=t.slice(),d&&(t.pop(),t.pop(),u.set(t[t.length-2],t[t.length-1]));const e=.5*(h.x+u.x),r=.5*(u.y+h.y);t.unshift(e,r),t.push(e,r)}const f=n,p=t.length/2;let g=t.length;const x=f.length/2,m=a.width/2,y=m*m,_=a.miterLimit*a.miterLimit;let b=t[0],v=t[1],S=t[2],w=t[3],T=0,P=0,C=-(v-w),M=b-S,k=0,A=0,R=Math.sqrt(C*C+M*M);C/=R,M/=R,C*=m,M*=m;const F=2*(1-l),z=2*l;c||("round"===a.cap?g+=et(b-C*(F-z)*.5,v-M*(F-z)*.5,b-C*F,v-M*F,b+C*z,v+M*z,f,!0)+2:"square"===a.cap&&(g+=tt(b,v,C,M,F,z,!0,f))),f.push(b-C*F,v-M*F),f.push(b+C*z,v+M*z);for(let e=1;e<p-1;++e){b=t[2*(e-1)],v=t[2*(e-1)+1],S=t[2*e],w=t[2*e+1],T=t[2*(e+1)],P=t[2*(e+1)+1],C=-(v-w),M=b-S,R=Math.sqrt(C*C+M*M),C/=R,M/=R,C*=m,M*=m,k=-(w-P),A=S-T,R=Math.sqrt(k*k+A*A),k/=R,A/=R,k*=m,A*=m;const r=S-b,i=v-w,n=S-T,s=P-w,o=r*n+i*s,l=i*n-s*r,h=l<0;if(Math.abs(l)<.001*Math.abs(o)){f.push(S-C*F,w-M*F),f.push(S+C*z,w+M*z),o>=0&&("round"===a.join?g+=et(S,w,S-C*F,w-M*F,S-k*F,w-A*F,f,!1)+4:g+=2,f.push(S-k*z,w-A*z),f.push(S+k*F,w+A*F));continue}const u=(-C+b)*(-M+w)-(-C+S)*(-M+v),c=(-k+T)*(-A+w)-(-k+S)*(-A+P),d=(r*c-n*u)/l,p=(s*u-i*c)/l,x=(d-S)*(d-S)+(p-w)*(p-w),B=S+(d-S)*F,U=w+(p-w)*F,I=S-(d-S)*z,G=w-(p-w)*z,D=h?F:z;x<=Math.min(r*r+i*i,n*n+s*s)+D*D*y?"bevel"===a.join||x/y>_?(h?(f.push(B,U),f.push(S+C*z,w+M*z),f.push(B,U),f.push(S+k*z,w+A*z)):(f.push(S-C*F,w-M*F),f.push(I,G),f.push(S-k*F,w-A*F),f.push(I,G)),g+=2):"round"===a.join?h?(f.push(B,U),f.push(S+C*z,w+M*z),g+=et(S,w,S+C*z,w+M*z,S+k*z,w+A*z,f,!0)+4,f.push(B,U),f.push(S+k*z,w+A*z)):(f.push(S-C*F,w-M*F),f.push(I,G),g+=et(S,w,S-C*F,w-M*F,S-k*F,w-A*F,f,!1)+4,f.push(S-k*F,w-A*F),f.push(I,G)):(f.push(B,U),f.push(I,G)):(f.push(S-C*F,w-M*F),f.push(S+C*z,w+M*z),"round"===a.join?g+=h?et(S,w,S+C*z,w+M*z,S+k*z,w+A*z,f,!0)+2:et(S,w,S-C*F,w-M*F,S-k*F,w-A*F,f,!1)+2:"miter"===a.join&&x/y<=_&&(h?(f.push(I,G),f.push(I,G)):(f.push(B,U),f.push(B,U)),g+=2),f.push(S-k*F,w-A*F),f.push(S+k*z,w+A*z),g+=2)}b=t[2*(p-2)],v=t[2*(p-2)+1],S=t[2*(p-1)],w=t[2*(p-1)+1],C=-(v-w),M=b-S,R=Math.sqrt(C*C+M*M),C/=R,M/=R,C*=m,M*=m,f.push(S-C*F,w-M*F),f.push(S+C*z,w+M*z),c||("round"===a.cap?g+=et(S-C*(F-z)*.5,w-M*(F-z)*.5,S-C*F,w-M*F,S+C*z,w+M*z,f,!1)+2:"square"===a.cap&&(g+=tt(S,w,C,M,F,z,!1,f)));for(let t=x;t<g+x-2;++t)b=f[2*t],v=f[2*t+1],S=f[2*(t+1)],w=f[2*(t+1)+1],T=f[2*(t+2)],P=f[2*(t+2)+1],Math.abs(b*(w-P)+S*(P-v)+T*(v-w))<1e-8||s.push(t,t+1,t+2)}(c,i,0,r,o,l)}else if(u){const t=[],e=c.slice();(function(t){const e=[];for(let r=0;r<t.length;r++){const i=t[r].shape,n=[];Dt[i.type].build(i,n)&&e.push(n)}return e})(u).forEach(r=>{t.push(e.length/2),e.push(...r)}),At(e,t,o,2,p,l,f)}else d.triangulate(c,o,2,p,l,f);const x=a.length/2,m=e.texture;if(m!==s.g.WHITE){const r=function(t,e,r,i){const n=e.matrix?t.copyFrom(e.matrix).invert():t.identity();if("local"===e.textureSpace){const t=r.getBounds(Gt);e.width&&t.pad(e.width);const{x:i,y:s}=t,o=1/t.width,a=1/t.height,l=-i*o,h=-s*a,u=n.a,c=n.b,d=n.c,f=n.d;n.a*=o,n.b*=o,n.c*=a,n.d*=a,n.tx=l*u+h*d+n.tx,n.ty=l*c+h*f+n.ty}else n.translate(e.texture.frame.x,e.texture.frame.y),n.scale(1/e.texture.source.width,1/e.texture.source.height);const s=e.texture.source.style;return e.fill instanceof Ut._||"clamp-to-edge"!==s.addressMode||(s.addressMode="repeat",s.update()),i&&n.append(It.copyFrom(i).invert()),n}(Ot,e,t,h);!function(t,e,r,i,n,s,o,a=null){let l=0;r*=e,n*=s;const h=a.a,u=a.b,c=a.c,d=a.d,f=a.tx,p=a.ty;for(;l<o;){const o=t[r],a=t[r+1];i[n]=h*o+c*a+f,i[n+1]=u*o+d*a+p,n+=s,r+=e,l++}}(o,2,p,a,x,2,o.length/2-p,r)}else!function(t,e,r,i){let n=0;for(e*=2;n<i;)t[e]=0,t[e+1]=0,e+=2,n++}(a,x,0,o.length/2-p);const y=H.Z.get(Y.G);y.indexOffset=f,y.indexSize=l.length-f,y.attributeOffset=p,y.attributeSize=o.length/2-p,y.baseColor=e.color,y.alpha=e.alpha,y.texture=m,y.geometryData=n,y.topology=g,i.push(y)})}class Lt{constructor(){this.batches=[],this.geometryData={vertices:[],uvs:[],indices:[]}}}class $t{constructor(){this.instructions=new $.L}init(t){const e=t.maxTextures;this.batcher?this.batcher._updateMaxTextures(e):this.batcher=new L({maxTextures:e}),this.instructions.reset()}get geometry(){return(0,u.t6)(u.Ek,"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."),this.batcher.geometry}destroy(){this.batcher.destroy(),this.instructions.destroy(),this.batcher=null,this.instructions=null}}const Ht=class t{constructor(t){this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null),this._renderer=t,t.renderableGC.addManagedHash(this,"_gpuContextHash"),t.renderableGC.addManagedHash(this,"_graphicsDataContextHash")}init(e){t.defaultOptions.bezierSmoothness=e?.bezierSmoothness??t.defaultOptions.bezierSmoothness}getContextRenderData(t){return this._graphicsDataContextHash[t.uid]||this._initContextRenderData(t)}updateGpuContext(t){let e=this._gpuContextHash[t.uid]||this._initContext(t);if(t.dirty){e?this._cleanGraphicsContextData(t):e=this._initContext(t),function(t,e){const{geometryData:r,batches:i}=e;i.length=0,r.indices.length=0,r.vertices.length=0,r.uvs.length=0;for(let e=0;e<t.instructions.length;e++){const n=t.instructions[e];if("texture"===n.action)Vt(n.data,i,r);else if("fill"===n.action||"stroke"===n.action){const t="stroke"===n.action,e=n.data.path.shapePath,s=n.data.style,o=n.data.hole;t&&o&&Wt(o.shapePath,s,!0,i,r),o&&(e.shapePrimitives[e.shapePrimitives.length-1].holes=o.shapePath.shapePrimitives),Wt(e,s,t,i,r)}}}(t,e);const r=t.batchMode;t.customShader||"no-batch"===r?e.isBatchable=!1:e.isBatchable="auto"!==r||e.geometryData.vertices.length<400,t.dirty=!1}return e}getGpuContext(t){return this._gpuContextHash[t.uid]||this._initContext(t)}_initContextRenderData(t){const e=H.Z.get($t,{maxTextures:this._renderer.limits.maxBatchableTextures}),{batches:r,geometryData:i}=this._gpuContextHash[t.uid],n=i.vertices.length,s=i.indices.length;for(let t=0;t<r.length;t++)r[t].applyTransform=!1;const o=e.batcher;o.ensureAttributeBuffer(n),o.ensureIndexBuffer(s),o.begin();for(let t=0;t<r.length;t++){const e=r[t];o.add(e)}o.finish(e.instructions);const l=o.geometry;l.indexBuffer.setDataWithSize(o.indexBuffer,o.indexSize,!0),l.buffers[0].setDataWithSize(o.attributeBuffer.float32View,o.attributeSize,!0);const h=o.batches;for(let t=0;t<h.length;t++){const e=h[t];e.bindGroup=a(e.textures.textures,e.textures.count,this._renderer.limits.maxBatchableTextures)}return this._graphicsDataContextHash[t.uid]=e,e}_initContext(t){const e=new Lt;return e.context=t,this._gpuContextHash[t.uid]=e,t.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[t.uid]}onGraphicsContextDestroy(t){this._cleanGraphicsContextData(t),t.off("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[t.uid]=null}_cleanGraphicsContextData(t){const e=this._gpuContextHash[t.uid];e.isBatchable||this._graphicsDataContextHash[t.uid]&&(H.Z.return(this.getContextRenderData(t)),this._graphicsDataContextHash[t.uid]=null),e.batches&&e.batches.forEach(t=>{H.Z.return(t)})}destroy(){for(const t in this._gpuContextHash)this._gpuContextHash[t]&&this.onGraphicsContextDestroy(this._gpuContextHash[t].context);this._gpuContextHash={},this._graphicsDataContextHash={},this._renderer=null}};Ht.extension={type:[i.Ag.WebGLSystem,i.Ag.WebGPUSystem,i.Ag.CanvasSystem],name:"graphicsContext"},Ht.defaultOptions={bezierSmoothness:.5};let jt=Ht},6607:(t,e,r)=>{"use strict";var i=r(8507),n=r(1979),s=r(4670),o=r(4985),a=r(8288);class l extends o.l{constructor(t){t instanceof a.T&&(t={context:t});const{context:e,roundPixels:r,...i}=t||{};super({label:"Graphics",...i}),this.renderPipeId="graphics",this._context=e||(this._ownedContext=new a.T),this._context.on("update",this.onViewUpdate,this),this.didViewUpdate=!0,this.allowChildren=!1,this.roundPixels=r??!1}set context(t){t!==this._context&&(this._context.off("update",this.onViewUpdate,this),this._context=t,this._context.on("update",this.onViewUpdate,this),this.onViewUpdate())}get context(){return this._context}get bounds(){return this._context.bounds}updateBounds(){}containsPoint(t){return this._context.containsPoint(t)}destroy(t){this._ownedContext&&!t?this._ownedContext.destroy(t):!0!==t&&!0!==t?.context||this._context.destroy(t),this._ownedContext=null,this._context=null,super.destroy(t)}_callContextMethod(t,e){return this.context[t](...e),this}setFillStyle(...t){return this._callContextMethod("setFillStyle",t)}setStrokeStyle(...t){return this._callContextMethod("setStrokeStyle",t)}fill(...t){return this._callContextMethod("fill",t)}stroke(...t){return this._callContextMethod("stroke",t)}texture(...t){return this._callContextMethod("texture",t)}beginPath(){return this._callContextMethod("beginPath",[])}cut(){return this._callContextMethod("cut",[])}arc(...t){return this._callContextMethod("arc",t)}arcTo(...t){return this._callContextMethod("arcTo",t)}arcToSvg(...t){return this._callContextMethod("arcToSvg",t)}bezierCurveTo(...t){return this._callContextMethod("bezierCurveTo",t)}closePath(){return this._callContextMethod("closePath",[])}ellipse(...t){return this._callContextMethod("ellipse",t)}circle(...t){return this._callContextMethod("circle",t)}path(...t){return this._callContextMethod("path",t)}lineTo(...t){return this._callContextMethod("lineTo",t)}moveTo(...t){return this._callContextMethod("moveTo",t)}quadraticCurveTo(...t){return this._callContextMethod("quadraticCurveTo",t)}rect(...t){return this._callContextMethod("rect",t)}roundRect(...t){return this._callContextMethod("roundRect",t)}poly(...t){return this._callContextMethod("poly",t)}regularPoly(...t){return this._callContextMethod("regularPoly",t)}roundPoly(...t){return this._callContextMethod("roundPoly",t)}roundShape(...t){return this._callContextMethod("roundShape",t)}filletRect(...t){return this._callContextMethod("filletRect",t)}chamferRect(...t){return this._callContextMethod("chamferRect",t)}star(...t){return this._callContextMethod("star",t)}svg(...t){return this._callContextMethod("svg",t)}restore(...t){return this._callContextMethod("restore",t)}save(){return this._callContextMethod("save",[])}getTransform(){return this.context.getTransform()}resetTransform(){return this._callContextMethod("resetTransform",[])}rotateTransform(...t){return this._callContextMethod("rotate",t)}scaleTransform(...t){return this._callContextMethod("scale",t)}setTransform(...t){return this._callContextMethod("setTransform",t)}transform(...t){return this._callContextMethod("transform",t)}translateTransform(...t){return this._callContextMethod("translate",t)}clear(){return this._callContextMethod("clear",[])}get fillStyle(){return this._context.fillStyle}set fillStyle(t){this._context.fillStyle=t}get strokeStyle(){return this._context.strokeStyle}set strokeStyle(t){this._context.strokeStyle=t}clone(t=!1){return t?new l(this._context.clone()):(this._ownedContext=null,new l(this._context))}lineStyle(t,e,r){(0,s.t6)(s.lj,"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");const i={};return t&&(i.width=t),e&&(i.color=e),r&&(i.alpha=r),this.context.strokeStyle=i,this}beginFill(t,e){(0,s.t6)(s.lj,"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");const r={};return void 0!==t&&(r.color=t),void 0!==e&&(r.alpha=e),this.context.fillStyle=r,this}endFill(){(0,s.t6)(s.lj,"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill();const t=this.context.strokeStyle;return t.width===a.T.defaultStrokeStyle.width&&t.color===a.T.defaultStrokeStyle.color&&t.alpha===a.T.defaultStrokeStyle.alpha||this.context.stroke(),this}drawCircle(...t){return(0,s.t6)(s.lj,"Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",t)}drawEllipse(...t){return(0,s.t6)(s.lj,"Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",t)}drawPolygon(...t){return(0,s.t6)(s.lj,"Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",t)}drawRect(...t){return(0,s.t6)(s.lj,"Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",t)}drawRoundedRect(...t){return(0,s.t6)(s.lj,"Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",t)}drawStar(...t){return(0,s.t6)(s.lj,"Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",t)}}var h=r(4016),u=r(9313),c=r(5611),d=r(4459),f=r(4e3),p=r(6665),g=r(6040),x=r(8475),m=r(5811);const y={name:"local-uniform-msdf-bit",vertex:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "},fragment:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         ",main:"\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        "}},_={name:"local-uniform-msdf-bit",vertex:{header:"\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "},fragment:{header:"\n            uniform float uDistance;\n         ",main:"\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        "}},b={name:"msdf-bit",fragment:{header:"\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        "}},v={name:"msdf-bit",fragment:{header:"\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        "}};let S,w;class T extends x.M{constructor(t){const e=new m.k({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new u.u,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}});S??(S=(0,c.v)({name:"sdf-shader",bits:[d.F,(0,f._)(t),y,b,p.b]})),w??(w=(0,c.I)({name:"sdf-shader",bits:[d.a,(0,f.P)(t),_,v,p.m]})),super({glProgram:w,gpuProgram:S,resources:{localUniforms:e,batchSamplers:(0,g.n)(t)}})}}var P=r(5957),C=r(268),M=r(8291),k=r(2577),A=r(9252),R=r(7608),F=r(8293),z=r(7174),B=r(218),U=r(1242),I=r(3548),G=r(4486);class D extends G.A{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return(0,s.t6)(s.lj,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return(0,s.t6)(s.lj,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return(0,s.t6)(s.lj,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return(0,s.t6)(s.lj,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return(0,s.t6)(s.lj,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners();for(const t in this.chars)this.chars[t].texture?.destroy();this.chars=null,t&&(this.pages.forEach(t=>t.texture.destroy(!0)),this.pages=null)}}const E=class t extends D{constructor(e){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const r={...t.defaultOptions,...e};this._textureSize=r.textureSize,this._mipmap=r.mipmap;const i=r.style.clone();r.overrideFill&&(i._fill.color=16777215,i._fill.alpha=1,i._fill.texture=z.g.WHITE,i._fill.fill=null),this.applyFillAsTint=r.overrideFill;const n=i.fontSize;i.fontSize=this.baseMeasurementFontSize;const s=(0,U.Z)(i);r.overrideSize?i._stroke&&(i._stroke.width*=this.baseRenderedFontSize/n):i.fontSize=this.baseRenderedFontSize=n,this._style=i,this._skipKerning=r.skipKerning??!1,this.resolution=r.resolution??1,this._padding=r.padding??4,r.textureStyle&&(this._textureStyle=r.textureStyle instanceof B.n?r.textureStyle:new B.n(r.textureStyle)),this.fontMetrics=h.P.measureFont(s),this.lineHeight=i.lineHeight||this.fontMetrics.fontSize||i.fontSize}ensureCharacters(t){const e=h.P.graphemeSegmenter(t).filter(t=>!this._currentChars.includes(t)).filter((t,e,r)=>r.indexOf(t)===e);if(!e.length)return;let r;this._currentChars=[...this._currentChars,...e],r=-1===this._currentPageIndex?this._nextPage():this.pages[this._currentPageIndex];let{canvas:i,context:n}=r.canvasAndContext,s=r.texture.source;const o=this._style;let a=this._currentX,l=this._currentY,u=this._currentMaxCharHeight;const c=this.baseRenderedFontSize/this.baseMeasurementFontSize,d=this._padding*c;let f=!1;const p=i.width/this.resolution,g=i.height/this.resolution;for(let t=0;t<e.length;t++){const r=e[t],x=h.P.measureText(r,o,i,!1);x.lineHeight=x.height;const m=x.width*c,y=Math.ceil(("italic"===o.fontStyle?2:1)*m)+2*d,_=x.height*c+2*d;if(f=!1,"\n"!==r&&"\r"!==r&&"\t"!==r&&" "!==r&&(f=!0,u=Math.ceil(Math.max(_,u))),a+y>p&&(l+=u,u=_,a=0,l+u>g)){s.update();const t=this._nextPage();i=t.canvasAndContext.canvas,n=t.canvasAndContext.context,s=t.texture.source,a=0,l=0,u=0}const b=m/c-(o.dropShadow?.distance??0)-(o._stroke?.width??0);if(this.chars[r]={id:r.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:b,kerning:{}},f){this._drawGlyph(n,x,a+d,l+d,c,o);const t=s.width*c,e=s.height*c,i=new A.M(a/t*s.width,l/e*s.height,y/t*s.width,_/e*s.height);this.chars[r].texture=new z.g({source:s,frame:i}),a+=Math.ceil(y)}}s.update(),this._currentX=a,this._currentY=l,this._currentMaxCharHeight=u,this._skipKerning&&this._applyKerning(e,n)}get pageTextures(){return(0,s.t6)(s.lj,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const r=this._measureCache;for(let i=0;i<t.length;i++){const n=t[i];for(let t=0;t<this._currentChars.length;t++){const i=this._currentChars[t];let s=r[n];s||(s=r[n]=e.measureText(n).width);let o=r[i];o||(o=r[i]=e.measureText(i).width);let a=e.measureText(n+i).width,l=a-(s+o);l&&(this.chars[n].kerning[i]=l),a=e.measureText(n+i).width,l=a-(s+o),l&&(this.chars[i].kerning[n]=l)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=R.N.getOptimalCanvasAndContext(this._textureSize,this._textureSize,t);this._setupContext(e.context,this._style,t);const r=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),i=new z.g({source:new F.b({resource:e.canvas,resolution:r,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(i.source.style=this._textureStyle);const n={canvasAndContext:e,texture:i};return this.pages[this._currentPageIndex]=n,n}_setupContext(t,e,r){e.fontSize=this.baseRenderedFontSize,t.scale(r,r),t.font=(0,U.Z)(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const i=e._stroke,n=i?.width??0;if(i&&(t.lineWidth=n,t.lineJoin=i.join,t.miterLimit=i.miterLimit,t.strokeStyle=(0,I.r)(i,t)),e._fill&&(t.fillStyle=(0,I.r)(e._fill,t)),e.dropShadow){const i=e.dropShadow,n=k.Q.shared.setValue(i.color).toArray(),s=i.blur*r,o=i.distance*r;t.shadowColor=`rgba(${255*n[0]},${255*n[1]},${255*n[2]},${i.alpha})`,t.shadowBlur=s,t.shadowOffsetX=Math.cos(i.angle)*o,t.shadowOffsetY=Math.sin(i.angle)*o}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,r,i,n,s){const o=e.text,a=e.fontProperties,l=s._stroke,h=(l?.width??0)*n,u=r+h/2,c=i-h/2,d=a.descent*n,f=e.lineHeight*n;let p=!1;s.stroke&&h&&(p=!0,t.strokeText(o,u,c+f-d));const{shadowBlur:g,shadowOffsetX:x,shadowOffsetY:m}=t;s._fill&&(p&&(t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0),t.fillText(o,u,c+f-d)),p&&(t.shadowBlur=g,t.shadowOffsetX=x,t.shadowOffsetY=m)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:r}=this.pages[t];R.N.returnCanvasAndContext(e),r.destroy(!0)}this.pages=null}};E.defaultOptions={textureSize:512,style:new M.x,mipmap:!0};let O=E;function V(t,e,r,i){const n={width:0,height:0,offsetY:0,scale:e.fontSize/r.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};n.offsetY=r.baseLineOffset;let s=n.lines[0],o=null,a=!0;const l={spaceWord:!1,width:0,start:0,index:0,positions:[],chars:[]},h=r.baseMeasurementFontSize/e.fontSize,u=e.letterSpacing*h,c=e.wordWrapWidth*h,d=e.lineHeight?e.lineHeight*h:r.lineHeight,f=e.wordWrap&&e.breakWords,p=t=>{const e=s.width;for(let r=0;r<l.index;r++){const i=t.positions[r];s.chars.push(t.chars[r]),s.charPositions.push(i+e)}s.width+=t.width,a=!1,l.width=0,l.index=0,l.chars.length=0},g=()=>{let t=s.chars.length-1;if(i){let e=s.chars[t];for(;" "===e;)s.width-=r.chars[e].xAdvance,e=s.chars[--t]}n.width=Math.max(n.width,s.width),s={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},a=!0,n.lines.push(s),n.height+=d},x=t=>t-u>c;for(let i=0;i<t.length+1;i++){let n;const h=i===t.length;h||(n=t[i]);const c=r.chars[n]||r.chars[" "];if(/(?:\s)/.test(n)||"\r"===n||"\n"===n||h){if(!a&&e.wordWrap&&x(s.width+l.width)?(g(),p(l),h||s.charPositions.push(0)):(l.start=s.width,p(l),h||s.charPositions.push(0)),"\r"===n||"\n"===n)g();else if(!h){const t=c.xAdvance+(c.kerning[o]||0)+u;s.width+=t,s.spaceWidth=t,s.spacesIndex.push(s.charPositions.length),s.chars.push(n)}}else{const t=c.kerning[o]||0,e=c.xAdvance+t+u;f&&x(s.width+l.width+e)&&(p(l),g()),l.positions[l.index++]=l.width+t,l.chars.push(n),l.width+=e}o=n}return g(),"center"===e.align?function(t){for(let e=0;e<t.lines.length;e++){const r=t.lines[e],i=t.width/2-r.width/2;for(let t=0;t<r.charPositions.length;t++)r.charPositions[t]+=i}}(n):"right"===e.align?function(t){for(let e=0;e<t.lines.length;e++){const r=t.lines[e],i=t.width-r.width;for(let t=0;t<r.charPositions.length;t++)r.charPositions[t]+=i}}(n):"justify"===e.align&&function(t){const e=t.width;for(let r=0;r<t.lines.length;r++){const i=t.lines[r];let n=0,s=i.spacesIndex[n++],o=0;const a=i.spacesIndex.length,l=(e-i.width)/a;for(let t=0;t<i.charPositions.length;t++)t===s&&(s=i.spacesIndex[n++],o+=l),i.charPositions[t]+=o}}(n),n}let W=0;const L=new class{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=(0,P.g)(1e3)}getFont(t,e){let r=`${e.fontFamily}-bitmap`,i=!0;if(e._fill.fill&&!e._stroke?(r+=e._fill.fill.styleKey,i=!1):(e._stroke||e.dropShadow)&&(r=`${e.styleKey}-bitmap`,i=!1),!n.l.has(r)){const t=Object.create(e);t.lineHeight=0;const s=new O({style:t,overrideFill:i,overrideSize:!0,...this.defaultOptions});W++,W>50&&(0,C.R)("BitmapText",`You have dynamically created ${W} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),s.once("destroy",()=>{W--,n.l.remove(r)}),n.l.set(r,s)}const s=n.l.get(r);return s.ensureCharacters?.(t),s}getLayout(t,e,r=!0){const i=this.getFont(t,e),n=`${t}-${e.styleKey}-${r}`;if(this.measureCache.has(n))return this.measureCache.get(n);const s=V(h.P.graphemeSegmenter(t),e,i,r);return this.measureCache.set(n,s),s}measureText(t,e,r=!0){return this.getLayout(t,e,r)}install(...t){let e=t[0];"string"==typeof e&&(e={name:e,style:t[1],chars:t[2]?.chars,resolution:t[2]?.resolution,padding:t[2]?.padding,skipKerning:t[2]?.skipKerning},(0,s.t6)(s.lj,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const r=e?.name;if(!r)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const i=e.style,o=i instanceof M.x?i:new M.x(i),a=e.dynamicFill??this._canUseTintForStyle(o),l=new O({style:o,overrideFill:a,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1,textureStyle:e.textureStyle}),h=function(t){if(""===t)return[];"string"==typeof t&&(t=[t]);const e=[];for(let r=0,i=t.length;r<i;r++){const i=t[r];if(Array.isArray(i)){if(2!==i.length)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);if(0===i[0].length||0===i[1].length)throw new Error("[BitmapFont]: Invalid character delimiter.");const t=i[0].charCodeAt(0),r=i[1].charCodeAt(0);if(r<t)throw new Error("[BitmapFont]: Invalid character range.");for(let i=t,n=r;i<=n;i++)e.push(String.fromCharCode(i))}else e.push(...Array.from(i))}if(0===e.length)throw new Error("[BitmapFont]: Empty set when resolving characters.");return e}(e.chars);return l.ensureCharacters(h.join("")),n.l.set(`${r}-bitmap`,l),l.once("destroy",()=>n.l.remove(`${r}-bitmap`)),l}uninstall(t){const e=`${t}-bitmap`,r=n.l.get(e);r&&r.destroy()}_canUseTintForStyle(t){return!(t._stroke||t.dropShadow&&0!==t.dropShadow.color||t._fill.fill||16777215!==t._fill.color)}};class $ extends l{destroy(){this.context.customShader&&this.context.customShader.destroy(),super.destroy()}}class H{constructor(t){this._renderer=t}validateRenderable(t){const e=this._getGpuBitmapText(t);return this._renderer.renderPipes.graphics.validateRenderable(e)}addRenderable(t,e){const r=this._getGpuBitmapText(t);j(t,r),t._didTextUpdate&&(t._didTextUpdate=!1,this._updateContext(t,r)),this._renderer.renderPipes.graphics.addRenderable(r,e),r.context.customShader&&this._updateDistanceField(t)}updateRenderable(t){const e=this._getGpuBitmapText(t);j(t,e),this._renderer.renderPipes.graphics.updateRenderable(e),e.context.customShader&&this._updateDistanceField(t)}_updateContext(t,e){const{context:r}=e,i=L.getFont(t.text,t._style);r.clear(),"none"!==i.distanceField.type&&(r.customShader||(r.customShader=new T(this._renderer.limits.maxBatchableTextures)));const n=h.P.graphemeSegmenter(t.text),s=t._style;let o=i.baseLineOffset;const a=V(n,s,i,!0),l=s.padding,u=a.scale;let c=a.width,d=a.height+a.offsetY;s._stroke&&(c+=s._stroke.width/u,d+=s._stroke.width/u),r.translate(-t._anchor._x*c-l,-t._anchor._y*d-l).scale(u,u);const f=i.applyFillAsTint?s._fill.color:16777215;let p=i.fontMetrics.fontSize,g=i.lineHeight;s.lineHeight&&(p=s.fontSize/u,g=s.lineHeight/u);let x=(g-p)/2;x-i.baseLineOffset<0&&(x=0);for(let t=0;t<a.lines.length;t++){const e=a.lines[t];for(let t=0;t<e.charPositions.length;t++){const n=e.chars[t],s=i.chars[n];if(s?.texture){const i=s.texture;r.texture(i,f||"black",Math.round(e.charPositions[t]+s.xOffset),Math.round(o+s.yOffset+x),i.orig.width,i.orig.height)}}o+=g}}_getGpuBitmapText(t){return t._gpuData[this._renderer.uid]||this.initGpuText(t)}initGpuText(t){const e=new $;return t._gpuData[this._renderer.uid]=e,this._updateContext(t,e),e}_updateDistanceField(t){const e=this._getGpuBitmapText(t).context,r=t._style.fontFamily,i=n.l.get(`${r}-bitmap`),{a:s,b:o,c:a,d:l}=t.groupTransform,h=Math.sqrt(s*s+o*o),u=Math.sqrt(a*a+l*l),c=(Math.abs(h)+Math.abs(u))/2,d=i.baseRenderedFontSize/t._style.fontSize,f=c*i.distanceField.range*(1/d);e.customShader.resources.localUniforms.uniforms.uDistance=f}destroy(){this._renderer=null}}function j(t,e){e.groupTransform=t.groupTransform,e.groupColorAlpha=t.groupColorAlpha,e.groupColor=t.groupColor,e.groupBlendMode=t.groupBlendMode,e.globalDisplayStatus=t.globalDisplayStatus,e.groupTransform=t.groupTransform,e.localDisplayStatus=t.localDisplayStatus,e.groupAlpha=t.groupAlpha,e._roundPixels=t._roundPixels}H.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"bitmapText"},i.XO.add(H)},6665:(t,e,r)=>{"use strict";r.d(e,{b:()=>i,m:()=>n});const i={name:"round-pixels-bit",vertex:{header:"\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        "}},n={name:"round-pixels-bit",vertex:{header:"\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        "}}},6954:(t,e,r)=>{"use strict";r.d(e,{G:()=>o});var i=r(9313),n=r(4676);const s=new i.u;class o{constructor(){this.packAsQuad=!1,this.batcherName="default",this.topology="triangle-list",this.applyTransform=!0,this.roundPixels=0,this._batcher=null,this._batch=null}get uvs(){return this.geometryData.uvs}get positions(){return this.geometryData.vertices}get indices(){return this.geometryData.indices}get blendMode(){return this.renderable&&this.applyTransform?this.renderable.groupBlendMode:"normal"}get color(){const t=this.baseColor,e=t>>16|65280&t|(255&t)<<16,r=this.renderable;return r?(0,n.u)(e,r.groupColor)+(this.alpha*r.groupAlpha*255<<24):e+(255*this.alpha<<24)}get transform(){return this.renderable?.groupTransform||s}copyTo(t){t.indexOffset=this.indexOffset,t.indexSize=this.indexSize,t.attributeOffset=this.attributeOffset,t.attributeSize=this.attributeSize,t.baseColor=this.baseColor,t.alpha=this.alpha,t.texture=this.texture,t.geometryData=this.geometryData,t.topology=this.topology}reset(){this.applyTransform=!0,this.renderable=null,this.topology="triangle-list"}destroy(){this.renderable=null,this.texture=null,this.geometryData=null,this._batcher=null,this._batch=null}}},7252:(t,e,r)=>{"use strict";var i=r(8507),n=r(8734),s=r(4670),o=r(5060);const a=class t extends o.u{constructor(...t){super({});let e=t[0]??{};"number"==typeof e&&((0,s.t6)(s.lj,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),e={width:e,height:t[1],verticesX:t[2],verticesY:t[3]}),this.build(e)}build(e){e={...t.defaultOptions,...e},this.verticesX=this.verticesX??e.verticesX,this.verticesY=this.verticesY??e.verticesY,this.width=this.width??e.width,this.height=this.height??e.height;const r=this.verticesX*this.verticesY,i=[],n=[],s=[],o=this.verticesX-1,a=this.verticesY-1,l=this.width/o,h=this.height/a;for(let t=0;t<r;t++){const e=t%this.verticesX,r=t/this.verticesX|0;i.push(e*l,r*h),n.push(e/o,r/a)}const u=o*a;for(let t=0;t<u;t++){const e=t%o,r=t/o|0,i=r*this.verticesX+e,n=r*this.verticesX+e+1,a=(r+1)*this.verticesX+e,l=(r+1)*this.verticesX+e+1;s.push(i,n,a,n,l,a)}this.buffers[0].data=new Float32Array(i),this.buffers[1].data=new Float32Array(n),this.indexBuffer.data=new Uint32Array(s),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};a.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let l=a;const h=class t extends l{constructor(e={}){super({width:(e={...t.defaultOptions,...e}).width,height:e.height,verticesX:4,verticesY:4}),this.update(e)}update(t){this.width=t.width??this.width,this.height=t.height??this.height,this._originalWidth=t.originalWidth??this._originalWidth,this._originalHeight=t.originalHeight??this._originalHeight,this._leftWidth=t.leftWidth??this._leftWidth,this._rightWidth=t.rightWidth??this._rightWidth,this._topHeight=t.topHeight??this._topHeight,this._bottomHeight=t.bottomHeight??this._bottomHeight,this._anchorX=t.anchor?.x,this._anchorY=t.anchor?.y,this.updateUvs(),this.updatePositions()}updatePositions(){const t=this.positions,{width:e,height:r,_leftWidth:i,_rightWidth:n,_topHeight:s,_bottomHeight:o,_anchorX:a,_anchorY:l}=this,h=i+n,u=e>h?1:e/h,c=s+o,d=r>c?1:r/c,f=Math.min(u,d),p=a*e,g=l*r;t[0]=t[8]=t[16]=t[24]=-p,t[2]=t[10]=t[18]=t[26]=i*f-p,t[4]=t[12]=t[20]=t[28]=e-n*f-p,t[6]=t[14]=t[22]=t[30]=e-p,t[1]=t[3]=t[5]=t[7]=-g,t[9]=t[11]=t[13]=t[15]=s*f-g,t[17]=t[19]=t[21]=t[23]=r-o*f-g,t[25]=t[27]=t[29]=t[31]=r-g,this.getBuffer("aPosition").update()}updateUvs(){const t=this.uvs;t[0]=t[8]=t[16]=t[24]=0,t[1]=t[3]=t[5]=t[7]=0,t[6]=t[14]=t[22]=t[30]=1,t[25]=t[27]=t[29]=t[31]=1;const e=1/this._originalWidth,r=1/this._originalHeight;t[2]=t[10]=t[18]=t[26]=e*this._leftWidth,t[9]=t[11]=t[13]=t[15]=r*this._topHeight,t[4]=t[12]=t[20]=t[28]=1-e*this._rightWidth,t[17]=t[19]=t[21]=t[23]=1-r*this._bottomHeight,this.getBuffer("aUV").update()}};h.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let u=h;class c extends n.U{constructor(){super(),this.geometry=new u}destroy(){this.geometry.destroy()}}class d{constructor(t){this._renderer=t}addRenderable(t,e){const r=this._getGpuSprite(t);t.didViewUpdate&&this._updateBatchableSprite(t,r),this._renderer.renderPipes.batch.addToBatch(r,e)}updateRenderable(t){const e=this._getGpuSprite(t);t.didViewUpdate&&this._updateBatchableSprite(t,e),e._batcher.updateElement(e)}validateRenderable(t){const e=this._getGpuSprite(t);return!e._batcher.checkAndUpdateTexture(e,t._texture)}_updateBatchableSprite(t,e){e.geometry.update(t),e.setTexture(t._texture)}_getGpuSprite(t){return t._gpuData[this._renderer.uid]||this._initGPUSprite(t)}_initGPUSprite(t){const e=t._gpuData[this._renderer.uid]=new c,r=e;return r.renderable=t,r.transform=t.groupTransform,r.texture=t._texture,r.roundPixels=this._renderer._roundPixels|t._roundPixels,t.didViewUpdate||this._updateBatchableSprite(t,r),e}destroy(){this._renderer=null}}d.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"nineSliceSprite"},i.XO.add(d)},7276:(t,e,r)=>{"use strict";r.d(e,{_:()=>f});var i=r(2577),n=r(1761),s=r(9313),o=r(8293),a=r(7174),l=r(133),h=r(4670),u=r(2698);const c=[{offset:0,color:"white"},{offset:1,color:"black"}],d=class t{constructor(...e){this.uid=(0,l.L)("fillGradient"),this._tick=0,this.type="linear",this.colorStops=[];let r=function(t){let e=t[0]??{};return("number"==typeof e||t[1])&&((0,h.t6)("8.5.2","use options object instead"),e={type:"linear",start:{x:t[0],y:t[1]},end:{x:t[2],y:t[3]},textureSpace:t[4],textureSize:t[5]??f.defaultLinearOptions.textureSize}),e}(e);r={..."radial"===r.type?t.defaultRadialOptions:t.defaultLinearOptions,...(0,u.S)(r)},this._textureSize=r.textureSize,this._wrapMode=r.wrapMode,"radial"===r.type?(this.center=r.center,this.outerCenter=r.outerCenter??this.center,this.innerRadius=r.innerRadius,this.outerRadius=r.outerRadius,this.scale=r.scale,this.rotation=r.rotation):(this.start=r.start,this.end=r.end),this.textureSpace=r.textureSpace,this.type=r.type,r.colorStops.forEach(t=>{this.addColorStop(t.offset,t.color)})}addColorStop(t,e){return this.colorStops.push({offset:t,color:i.Q.shared.setValue(e).toHexa()}),this}buildLinearGradient(){if(this.texture)return;let{x:t,y:e}=this.start,{x:r,y:i}=this.end,n=r-t,l=i-e;const h=n<0||l<0;if("clamp-to-edge"===this._wrapMode){if(n<0){const e=t;t=r,r=e,n*=-1}if(l<0){const t=e;e=i,i=t,l*=-1}}const u=this.colorStops.length?this.colorStops:c,d=this._textureSize,{canvas:f,context:x}=g(d,1),m=h?x.createLinearGradient(this._textureSize,0,0,0):x.createLinearGradient(0,0,this._textureSize,0);p(m,u),x.fillStyle=m,x.fillRect(0,0,d,1),this.texture=new a.g({source:new o.b({resource:f,addressMode:this._wrapMode})});const y=Math.sqrt(n*n+l*l),_=Math.atan2(l,n),b=new s.u;b.scale(y/d,1),b.rotate(_),b.translate(t,e),"local"===this.textureSpace&&b.scale(d,d),this.transform=b}buildGradient(){this.texture||this._tick++,"linear"===this.type?this.buildLinearGradient():this.buildRadialGradient()}buildRadialGradient(){if(this.texture)return;const t=this.colorStops.length?this.colorStops:c,e=this._textureSize,{canvas:r,context:i}=g(e,e),{x:n,y:l}=this.center,{x:h,y:u}=this.outerCenter,d=this.innerRadius,f=this.outerRadius,x=h-f,m=u-f,y=e/(2*f),_=(n-x)*y,b=(l-m)*y,v=i.createRadialGradient(_,b,d*y,(h-x)*y,(u-m)*y,f*y);p(v,t),i.fillStyle=t[t.length-1].color,i.fillRect(0,0,e,e),i.fillStyle=v,i.translate(_,b),i.rotate(this.rotation),i.scale(1,this.scale),i.translate(-_,-b),i.fillRect(0,0,e,e),this.texture=new a.g({source:new o.b({resource:r,addressMode:this._wrapMode})});const S=new s.u;S.scale(1/y,1/y),S.translate(x,m),"local"===this.textureSpace&&S.scale(e,e),this.transform=S}destroy(){this.texture?.destroy(!0),this.texture=null,this.transform=null,this.colorStops=[],this.start=null,this.end=null,this.center=null,this.outerCenter=null}get styleKey(){return`fill-gradient-${this.uid}-${this._tick}`}};d.defaultLinearOptions={start:{x:0,y:0},end:{x:0,y:1},colorStops:[],textureSpace:"local",type:"linear",textureSize:256,wrapMode:"clamp-to-edge"},d.defaultRadialOptions={center:{x:.5,y:.5},innerRadius:0,outerRadius:.5,colorStops:[],scale:1,textureSpace:"local",type:"radial",textureSize:256,wrapMode:"clamp-to-edge"};let f=d;function p(t,e){for(let r=0;r<e.length;r++){const i=e[r];t.addColorStop(i.offset,i.color)}}function g(t,e){const r=n.e.get().createCanvas(t,e),i=r.getContext("2d");return{canvas:r,context:i}}},7547:(t,e,r)=>{"use strict";r.d(e,{U:()=>s});const i={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},n=class t{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(t){!!(1&this.data)!==t&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(t){!!(2&this.data)!==t&&(this.data^=2)}set cullMode(t){"none"!==t?(this.culling=!0,this.clockwiseFrontFace="front"===t):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(t){!!(4&this.data)!==t&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(t){!!(8&this.data)!==t&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(t){!!(32&this.data)!==t&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(t){!!(16&this.data)!==t&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(t){this.blend="none"!==t,this._blendMode=t,this._blendModeId=i[t]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(t){this.offsets=!!t,this._polygonOffset=t}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const e=new t;return e.depthTest=!1,e.blend=!0,e}};n.default2d=n.for2d();let s=n},7608:(t,e,r)=>{"use strict";r.d(e,{N:()=>o});var i=r(1761),n=r(9939),s=r(6083);const o=new class{constructor(t){this._canvasPool=Object.create(null),this.canvasOptions=t||{},this.enableFullScreen=!1}_createCanvasAndContext(t,e){const r=i.e.get().createCanvas();r.width=t,r.height=e;const n=r.getContext("2d");return{canvas:r,context:n}}getOptimalCanvasAndContext(t,e,r=1){t=Math.ceil(t*r-1e-6),e=Math.ceil(e*r-1e-6);const i=((t=(0,n.U5)(t))<<17)+((e=(0,n.U5)(e))<<1);this._canvasPool[i]||(this._canvasPool[i]=[]);let s=this._canvasPool[i].pop();return s||(s=this._createCanvasAndContext(t,e)),s}returnCanvasAndContext(t){const e=t.canvas,{width:r,height:i}=e,n=(r<<17)+(i<<1);t.context.resetTransform(),t.context.clearRect(0,0,r,i),this._canvasPool[n].push(t)}clear(){this._canvasPool={}}};s.L.register(o)},7950:(t,e,r)=>{"use strict";var i=r(8507);class n{constructor(t){this._renderer=t}push(t,e,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:e,filterEffect:t})}pop(t,e,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(t){"pushFilter"===t.action?this._renderer.filter.push(t):"popFilter"===t.action&&this._renderer.filter.pop()}destroy(){this._renderer=null}}n.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"filter"};var s=r(9113),o=r(3012),a=r(8475),l=r(7547);const h=class t extends a.M{constructor(e){super(e={...t.defaultOptions,...e}),this.enabled=!0,this._state=l.U.for2d(),this.blendMode=e.blendMode,this.padding=e.padding,"boolean"==typeof e.antialias?this.antialias=e.antialias?"on":"off":this.antialias=e.antialias,this.resolution=e.resolution,this.blendRequired=e.blendRequired,this.clipToViewport=e.clipToViewport,this.addResource("uTexture",0,1),e.blendRequired&&this.addResource("uBackTexture",0,3)}apply(t,e,r,i){t.applyFilter(this,e,r,i)}get blendMode(){return this._state.blendMode}set blendMode(t){this._state.blendMode=t}static from(e){const{gpu:r,gl:i,...n}=e;let a,l;return r&&(a=o.B.from(r)),i&&(l=s.M.from(i)),new t({gpuProgram:a,glProgram:l,...n})}};h.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let u=h;var c="struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";class d extends u{constructor(){super({gpuProgram:o.B.from({vertex:{source:c,entryPoint:"mainVertex"},fragment:{source:c,entryPoint:"mainFragment"},name:"passthrough-filter"}),glProgram:s.M.from({vertex:"in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n",name:"passthrough-filter"})})}}var f=r(9313),p=r(3513),g=r(6011),x=r(5811),m=r(7174),y=r(2437),_=r(5099),b=r(9636);const v=new f.u;var S=r(268);const w=new g.V({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class T{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new b.c,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0},this.firstEnabledIndex=-1,this.lastEnabledIndex=-1}}class P{constructor(t){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new x.k({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new p.T({}),this.renderer=t}get activeBackTexture(){return this._activeFilterData?.backTexture}push(t){const e=this.renderer,r=t.filterEffect.filters,i=this._pushFilterData();i.skip=!1,i.filters=r,i.container=t.container,i.outputRenderSurface=e.renderTarget.renderSurface;const n=e.renderTarget.renderTarget.colorTexture.source,s=n.resolution,o=n.antialias;if(r.every(t=>!t.enabled))return void(i.skip=!0);const a=i.bounds;if(this._calculateFilterArea(t,a),this._calculateFilterBounds(i,e.renderTarget.rootViewPort,o,s,1),i.skip)return;const l=this._getPreviousFilterData(),h=this._findFilterResolution(s);let u=0,c=0;l&&(u=l.bounds.minX,c=l.bounds.minY),this._calculateGlobalFrame(i,u,c,h,n.width,n.height),this._setupFilterTextures(i,a,e,l)}generateFilteredTexture({texture:t,filters:e}){const r=this._pushFilterData();this._activeFilterData=r,r.skip=!1,r.filters=e;const i=t.source,n=i.resolution,s=i.antialias;if(e.every(t=>!t.enabled))return r.skip=!0,t;const o=r.bounds;if(o.addRect(t.frame),this._calculateFilterBounds(r,o.rectangle,s,n,0),r.skip)return t;const a=n;this._calculateGlobalFrame(r,0,0,a,i.width,i.height),r.outputRenderSurface=y.W.getOptimalTexture(o.width,o.height,r.resolution,r.antialias),r.backTexture=m.g.EMPTY,r.inputTexture=t,this.renderer.renderTarget.finishRenderPass(),this._applyFiltersToTexture(r,!0);const l=r.outputRenderSurface;return l.source.alphaMode="premultiplied-alpha",l}pop(){const t=this.renderer,e=this._popFilterData();e.skip||(t.globalUniforms.pop(),t.renderTarget.finishRenderPass(),this._activeFilterData=e,this._applyFiltersToTexture(e,!1),e.blendRequired&&y.W.returnTexture(e.backTexture),y.W.returnTexture(e.inputTexture))}getBackTexture(t,e,r){const i=t.colorTexture.source._resolution,n=y.W.getOptimalTexture(e.width,e.height,i,!1);let s=e.minX,o=e.minY;r&&(s-=r.minX,o-=r.minY),s=Math.floor(s*i),o=Math.floor(o*i);const a=Math.ceil(e.width*i),l=Math.ceil(e.height*i);return this.renderer.renderTarget.copyToTexture(t,n,{x:s,y:o},{width:a,height:l},{x:0,y:0}),n}applyFilter(t,e,r,i){const n=this.renderer,s=this._activeFilterData,o=s.outputRenderSurface===r,a=n.renderTarget.rootRenderTarget.colorTexture.source._resolution,l=this._findFilterResolution(a);let h=0,u=0;if(o){const t=this._findPreviousFilterOffset();h=t.x,u=t.y}this._updateFilterUniforms(e,r,s,h,u,l,o,i);const c=t.enabled?t:this._getPassthroughFilter();this._setupBindGroupsAndRender(c,e,n)}calculateSpriteMatrix(t,e){const r=this._activeFilterData,i=t.set(r.inputTexture._source.width,0,0,r.inputTexture._source.height,r.bounds.minX,r.bounds.minY),n=e.worldTransform.copyTo(f.u.shared),s=e.renderGroup||e.parentRenderGroup;return s&&s.cacheToLocalTransform&&n.prepend(s.cacheToLocalTransform),n.invert(),i.prepend(n),i.scale(1/e.texture.orig.width,1/e.texture.orig.height),i.translate(e.anchor.x,e.anchor.y),i}destroy(){this._passthroughFilter?.destroy(!0),this._passthroughFilter=null}_getPassthroughFilter(){return this._passthroughFilter??(this._passthroughFilter=new d),this._passthroughFilter}_setupBindGroupsAndRender(t,e,r){if(r.renderPipes.uniformBatch){const t=r.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(t,0)}else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms,0);this._globalFilterBindGroup.setResource(e.source,1),this._globalFilterBindGroup.setResource(e.source.style,2),t.groups[0]=this._globalFilterBindGroup,r.encoder.draw({geometry:w,shader:t,state:t._state,topology:"triangle-list"}),r.type===_.W.WEBGL&&r.renderTarget.finishRenderPass()}_setupFilterTextures(t,e,r,i){if(t.backTexture=m.g.EMPTY,t.inputTexture=y.W.getOptimalTexture(e.width,e.height,t.resolution,t.antialias),t.blendRequired){r.renderTarget.finishRenderPass();const n=r.renderTarget.getRenderTarget(t.outputRenderSurface);t.backTexture=this.getBackTexture(n,e,i?.bounds)}r.renderTarget.bind(t.inputTexture,!0),r.globalUniforms.push({offset:e})}_calculateGlobalFrame(t,e,r,i,n,s){const o=t.globalFrame;o.x=e*i,o.y=r*i,o.width=n*i,o.height=s*i}_updateFilterUniforms(t,e,r,i,n,s,o,a){const l=this._filterGlobalUniforms.uniforms,h=l.uOutputFrame,u=l.uInputSize,c=l.uInputPixel,d=l.uInputClamp,f=l.uGlobalFrame,p=l.uOutputTexture;o?(h[0]=r.bounds.minX-i,h[1]=r.bounds.minY-n):(h[0]=0,h[1]=0),h[2]=t.frame.width,h[3]=t.frame.height,u[0]=t.source.width,u[1]=t.source.height,u[2]=1/u[0],u[3]=1/u[1],c[0]=t.source.pixelWidth,c[1]=t.source.pixelHeight,c[2]=1/c[0],c[3]=1/c[1],d[0]=.5*c[2],d[1]=.5*c[3],d[2]=t.frame.width*u[2]-.5*c[2],d[3]=t.frame.height*u[3]-.5*c[3];const g=this.renderer.renderTarget.rootRenderTarget.colorTexture;f[0]=i*s,f[1]=n*s,f[2]=g.source.width*s,f[3]=g.source.height*s,e instanceof m.g&&(e.source.resource=null);const x=this.renderer.renderTarget.getRenderTarget(e);this.renderer.renderTarget.bind(e,!!a),e instanceof m.g?(p[0]=e.frame.width,p[1]=e.frame.height):(p[0]=x.width,p[1]=x.height),p[2]=x.isRoot?-1:1,this._filterGlobalUniforms.update()}_findFilterResolution(t){let e=this._filterStackIndex-1;for(;e>0&&this._filterStack[e].skip;)--e;return e>0&&this._filterStack[e].inputTexture?this._filterStack[e].inputTexture.source._resolution:t}_findPreviousFilterOffset(){let t=0,e=0,r=this._filterStackIndex;for(;r>0;){r--;const i=this._filterStack[r];if(!i.skip){t=i.bounds.minX,e=i.bounds.minY;break}}return{x:t,y:e}}_calculateFilterArea(t,e){if(t.renderables?function(t,e){e.clear();const r=e.matrix;for(let r=0;r<t.length;r++){const i=t[r];if(i.globalDisplayStatus<7)continue;const n=i.renderGroup??i.parentRenderGroup;e.matrix=n?.isCachedAsTexture?v.copyFrom(n.textureOffsetInverseTransform).append(i.worldTransform):n?._parentCacheAsTextureRenderGroup?v.copyFrom(n._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(i.groupTransform):i.worldTransform,e.addBounds(i.bounds)}e.matrix=r}(t.renderables,e):t.filterEffect.filterArea?(e.clear(),e.addRect(t.filterEffect.filterArea),e.applyMatrix(t.container.worldTransform)):t.container.getFastGlobalBounds(!0,e),t.container){const r=(t.container.renderGroup||t.container.parentRenderGroup).cacheToLocalTransform;r&&e.applyMatrix(r)}}_applyFiltersToTexture(t,e){const r=t.inputTexture,i=t.bounds,n=t.filters,s=t.firstEnabledIndex,o=t.lastEnabledIndex;if(this._globalFilterBindGroup.setResource(r.source.style,2),this._globalFilterBindGroup.setResource(t.backTexture.source,3),s===o)n[s].apply(this,r,t.outputRenderSurface,e);else{let r=t.inputTexture;const a=y.W.getOptimalTexture(i.width,i.height,r.source._resolution,!1);let l=a;for(let t=s;t<o;t++){const e=n[t];if(!e.enabled)continue;e.apply(this,r,l,!0);const i=r;r=l,l=i}n[o].apply(this,r,t.outputRenderSurface,e),y.W.returnTexture(a)}}_calculateFilterBounds(t,e,r,i,n){const s=this.renderer,o=t.bounds,a=t.filters;let l=1/0,h=0,u=!0,c=!1,d=!1,f=!0,p=-1,g=-1;for(let t=0;t<a.length;t++){const e=a[t];if(e.enabled){if(-1===p&&(p=t),g=t,l=Math.min(l,"inherit"===e.resolution?i:e.resolution),h+=e.padding,"off"===e.antialias?u=!1:"inherit"===e.antialias&&u&&(u=r),e.clipToViewport||(f=!1),!(e.compatibleRenderers&s.type)){d=!1;break}if(e.blendRequired&&!(s.backBuffer?.useBackBuffer??1)){(0,S.R)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),d=!1;break}d=!0,c||(c=e.blendRequired)}}d?(f&&o.fitBounds(0,e.width/i,0,e.height/i),o.scale(l).ceil().scale(1/l).pad((0|h)*n),o.isPositive?(t.antialias=u,t.resolution=l,t.blendRequired=c,t.firstEnabledIndex=p,t.lastEnabledIndex=g):t.skip=!0):t.skip=!0}_popFilterData(){return this._filterStackIndex--,this._filterStack[this._filterStackIndex]}_getPreviousFilterData(){let t,e=this._filterStackIndex-1;for(;e>0&&(e--,t=this._filterStack[e],t.skip););return t}_pushFilterData(){let t=this._filterStack[this._filterStackIndex];return t||(t=this._filterStack[this._filterStackIndex]=new T),this._filterStackIndex++,t}}P.extension={type:[i.Ag.WebGLSystem,i.Ag.WebGPUSystem],name:"filter"},i.XO.add(P),i.XO.add(n)},7952:(t,e,r)=>{"use strict";r.d(e,{X:()=>s});const i=Object.create(null),n=Object.create(null);function s(t,e){let r=n[t];return void 0===r&&(void 0===i[e]&&(i[e]=1),n[t]=r=i[e]++),r}},8133:t=>{t.exports=function(t){var n=[];return t.replace(r,function(t,r,s){var o=r.toLowerCase();for(s=function(t){var e=t.match(i);return e?e.map(Number):[]}(s),"m"==o&&s.length>2&&(n.push([r].concat(s.splice(0,2))),o="l",r="m"==r?"l":"L");;){if(s.length==e[o])return s.unshift(r),n.push(s);if(s.length<e[o])throw new Error("malformed path data");n.push([r].concat(s.splice(0,e[o])))}}),n};var e={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},r=/([astvzqmhlc])([^astvzqmhlc]*)/gi,i=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi},8288:(t,e,r)=>{"use strict";r.d(e,{T:()=>Z});var i=r(4486),n=r(2577),s=r(9313),o=r(5101),a=r(7174),l=r(133),h=r(4670),u=r(9636),c=r(268),d=r(8133),f=r(9252);class p{constructor(t=0,e=0,r=0){this.type="circle",this.x=t,this.y=e,this.radius=r}clone(){return new p(this.x,this.y,this.radius)}contains(t,e){if(this.radius<=0)return!1;const r=this.radius*this.radius;let i=this.x-t,n=this.y-e;return i*=i,n*=n,i+n<=r}strokeContains(t,e,r,i=.5){if(0===this.radius)return!1;const n=this.x-t,s=this.y-e,o=this.radius,a=(1-i)*r,l=Math.sqrt(n*n+s*s);return l<=o+a&&l>o-(r-a)}getBounds(t){return t||(t=new f.M),t.x=this.x-this.radius,t.y=this.y-this.radius,t.width=2*this.radius,t.height=2*this.radius,t}copyFrom(t){return this.x=t.x,this.y=t.y,this.radius=t.radius,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`}}class g{constructor(t=0,e=0,r=0,i=0){this.type="ellipse",this.x=t,this.y=e,this.halfWidth=r,this.halfHeight=i}clone(){return new g(this.x,this.y,this.halfWidth,this.halfHeight)}contains(t,e){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let r=(t-this.x)/this.halfWidth,i=(e-this.y)/this.halfHeight;return r*=r,i*=i,r+i<=1}strokeContains(t,e,r,i=.5){const{halfWidth:n,halfHeight:s}=this;if(n<=0||s<=0)return!1;const o=r*(1-i),a=r-o,l=n-a,h=s-a,u=n+o,c=s+o,d=t-this.x,f=e-this.y;return d*d/(l*l)+f*f/(h*h)>1&&d*d/(u*u)+f*f/(c*c)<=1}getBounds(t){return t||(t=new f.M),t.x=this.x-this.halfWidth,t.y=this.y-this.halfHeight,t.width=2*this.halfWidth,t.height=2*this.halfHeight,t}copyFrom(t){return this.x=t.x,this.y=t.y,this.halfWidth=t.halfWidth,this.halfHeight=t.halfHeight,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`}}function x(t,e,r,i,n,s){const o=n-r,a=s-i,l=o*o+a*a;let h,u,c=-1;0!==l&&(c=((t-r)*o+(e-i)*a)/l),c<0?(h=r,u=i):c>1?(h=n,u=s):(h=r+c*o,u=i+c*a);const d=t-h,f=e-u;return d*d+f*f}class m{constructor(...t){this.type="polygon";let e=Array.isArray(t[0])?t[0]:t;if("number"!=typeof e[0]){const t=[];for(let r=0,i=e.length;r<i;r++)t.push(e[r].x,e[r].y);e=t}this.points=e,this.closePath=!0}isClockwise(){let t=0;const e=this.points,r=e.length;for(let i=0;i<r;i+=2){const n=e[i],s=e[i+1];t+=(e[(i+2)%r]-n)*(e[(i+3)%r]+s)}return t<0}containsPolygon(t){const e=this.getBounds(void 0),r=t.getBounds(void 0);if(!e.containsRect(r))return!1;const i=t.points;for(let t=0;t<i.length;t+=2){const e=i[t],r=i[t+1];if(!this.contains(e,r))return!1}return!0}clone(){const t=this.points.slice(),e=new m(t);return e.closePath=this.closePath,e}contains(t,e){let r=!1;const i=this.points.length/2;for(let n=0,s=i-1;n<i;s=n++){const i=this.points[2*n],o=this.points[2*n+1],a=this.points[2*s],l=this.points[2*s+1];o>e!=l>e&&t<(e-o)/(l-o)*(a-i)+i&&(r=!r)}return r}strokeContains(t,e,r,i=.5){const n=r*r,s=n*(1-i),o=n-s,{points:a}=this,l=a.length-(this.closePath?0:2);for(let r=0;r<l;r+=2){const i=a[r],n=a[r+1],l=a[(r+2)%a.length],h=a[(r+3)%a.length];if(x(t,e,i,n,l,h)<=(Math.sign((l-i)*(e-n)-(h-n)*(t-i))<0?o:s))return!0}return!1}getBounds(t){t||(t=new f.M);const e=this.points;let r=1/0,i=-1/0,n=1/0,s=-1/0;for(let t=0,o=e.length;t<o;t+=2){const o=e[t],a=e[t+1];r=o<r?o:r,i=o>i?o:i,n=a<n?a:n,s=a>s?a:s}return t.x=r,t.width=i-r,t.y=n,t.height=s-n,t}copyFrom(t){return this.points=t.points.slice(),this.closePath=t.closePath,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t,e)=>`${t}, ${e}`,"")}]`}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return(0,h.t6)("8.11.0","Polygon.lastX is deprecated, please use Polygon.lastX instead."),this.points[this.points.length-2]}get y(){return(0,h.t6)("8.11.0","Polygon.y is deprecated, please use Polygon.lastY instead."),this.points[this.points.length-1]}get startX(){return this.points[0]}get startY(){return this.points[1]}}const y=(t,e,r,i,n,s,o)=>{const a=t-r,l=e-i,h=Math.sqrt(a*a+l*l);return h>=n-s&&h<=n+o};class _{constructor(t=0,e=0,r=0,i=0,n=20){this.type="roundedRectangle",this.x=t,this.y=e,this.width=r,this.height=i,this.radius=n}getBounds(t){return t||(t=new f.M),t.x=this.x,t.y=this.y,t.width=this.width,t.height=this.height,t}clone(){return new _(this.x,this.y,this.width,this.height,this.radius)}copyFrom(t){return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this}copyTo(t){return t.copyFrom(this),t}contains(t,e){if(this.width<=0||this.height<=0)return!1;if(t>=this.x&&t<=this.x+this.width&&e>=this.y&&e<=this.y+this.height){const r=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(e>=this.y+r&&e<=this.y+this.height-r||t>=this.x+r&&t<=this.x+this.width-r)return!0;let i=t-(this.x+r),n=e-(this.y+r);const s=r*r;if(i*i+n*n<=s)return!0;if(i=t-(this.x+this.width-r),i*i+n*n<=s)return!0;if(n=e-(this.y+this.height-r),i*i+n*n<=s)return!0;if(i=t-(this.x+r),i*i+n*n<=s)return!0}return!1}strokeContains(t,e,r,i=.5){const{x:n,y:s,width:o,height:a,radius:l}=this,h=r*(1-i),u=r-h,c=n+l,d=s+l,f=n+o,p=s+a;return(t>=n-h&&t<=n+u||t>=f-u&&t<=f+h)&&e>=d&&e<=d+(a-2*l)||(e>=s-h&&e<=s+u||e>=p-u&&e<=p+h)&&t>=c&&t<=c+(o-2*l)||t<c&&e<d&&y(t,e,c,d,l,u,h)||t>f-l&&e<d&&y(t,e,f-l,d,l,u,h)||t>f-l&&e>p-l&&y(t,e,f-l,p-l,l,u,h)||t<c&&e>p-l&&y(t,e,c,p-l,l,u,h)}toString(){return`[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`}}var b=r(6442);const v=1.1920929e-7;function S(t,e,r,i,n,s,o,a,l,h){let u=(1-Math.min(.99,Math.max(0,h??b.GH.defaultOptions.bezierSmoothness)))/1;return u*=u,function(t,e,r,i,n,s,o,a,l,h){w(t,e,r,i,n,s,o,a,l,h,0),l.push(o,a)}(e,r,i,n,s,o,a,l,t,u),t}function w(t,e,r,i,n,s,o,a,l,h,u){if(u>8)return;Math.PI;const c=(t+r)/2,d=(e+i)/2,f=(r+n)/2,p=(i+s)/2,g=(n+o)/2,x=(s+a)/2,m=(c+f)/2,y=(d+p)/2,_=(f+g)/2,b=(p+x)/2,S=(m+_)/2,T=(y+b)/2;if(u>0){let u=o-t,c=a-e;const d=Math.abs((r-o)*c-(i-a)*u),f=Math.abs((n-o)*c-(s-a)*u);if(d>v&&f>v){if((d+f)*(d+f)<=h*(u*u+c*c))return void l.push(S,T)}else if(d>v){if(d*d<=h*(u*u+c*c))return void l.push(S,T)}else if(f>v){if(f*f<=h*(u*u+c*c))return void l.push(S,T)}else if(u=S-(t+o)/2,c=T-(e+a)/2,u*u+c*c<=h)return void l.push(S,T)}w(t,e,c,d,m,y,S,T,l,h,u+1),w(S,T,_,b,g,x,o,a,l,h,u+1)}function T(t,e,r,i,n,s,o,a){let l=(1-Math.min(.99,Math.max(0,a??b.GH.defaultOptions.bezierSmoothness)))/1;return l*=l,function(t,e,r,i,n,s,o,a){P(o,t,e,r,i,n,s,a,0),o.push(n,s)}(e,r,i,n,s,o,t,l),t}function P(t,e,r,i,n,s,o,a,l){if(l>8)return;Math.PI;const h=(e+i)/2,u=(r+n)/2,c=(i+s)/2,d=(n+o)/2,f=(h+c)/2,p=(u+d)/2;let g=s-e,x=o-r;const m=Math.abs((i-s)*x-(n-o)*g);if(m>1.1920929e-7){if(m*m<=a*(g*g+x*x))return void t.push(f,p)}else if(g=f-(e+s)/2,x=p-(r+o)/2,g*g+x*x<=a)return void t.push(f,p);P(t,e,r,h,u,f,p,a,l+1),P(t,f,p,c,d,s,o,a,l+1)}function C(t,e,r,i,n,s,o,a){let l=Math.abs(n-s);(!o&&n>s||o&&s>n)&&(l=2*Math.PI-l),a||(a=Math.max(6,Math.floor(6*Math.pow(i,1/3)*(l/Math.PI))));let h=l/(a=Math.max(a,3)),u=n;h*=o?-1:1;for(let n=0;n<a+1;n++){const n=e+Math.cos(u)*i,s=r+Math.sin(u)*i;t.push(n,s),u+=h}}const M=2*Math.PI,k={centerX:0,centerY:0,ang1:0,ang2:0},A=({x:t,y:e},r,i,n,s,o,a,l)=>{const h=n*(t*=r)-s*(e*=i),u=s*t+n*e;return l.x=h+o,l.y=u+a,l};function R(t,e){const r=-1.5707963267948966===e?-.551915024494:4/3*Math.tan(e/4),i=1.5707963267948966===e?.551915024494:r,n=Math.cos(t),s=Math.sin(t),o=Math.cos(t+e),a=Math.sin(t+e);return[{x:n-s*i,y:s+n*i},{x:o+a*i,y:a-o*i},{x:o,y:a}]}const F=(t,e,r,i)=>{let n=t*r+e*i;return n>1&&(n=1),n<-1&&(n=-1),(t*i-e*r<0?-1:1)*Math.acos(n)};const z=new f.M;class B{constructor(t){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new u.c,this._graphicsPath2D=t,this.signed=t.checkForHoles}moveTo(t,e){return this.startPoly(t,e),this}lineTo(t,e){this._ensurePoly();const r=this._currentPoly.points,i=r[r.length-2],n=r[r.length-1];return i===t&&n===e||r.push(t,e),this}arc(t,e,r,i,n,s){return this._ensurePoly(!1),C(this._currentPoly.points,t,e,r,i,n,s),this}arcTo(t,e,r,i,n){return this._ensurePoly(),function(t,e,r,i,n,s){const o=t[t.length-2],a=t[t.length-1]-r,l=o-e,h=n-r,u=i-e,c=Math.abs(a*u-l*h);if(c<1e-8||0===s)return void(t[t.length-2]===e&&t[t.length-1]===r||t.push(e,r));const d=a*a+l*l,f=h*h+u*u,p=a*h+l*u,g=s*Math.sqrt(d)/c,x=s*Math.sqrt(f)/c,m=g*p/d,y=x*p/f,_=g*u+x*l,b=g*h+x*a,v=l*(x+m),S=a*(x+m),w=u*(g+y),T=h*(g+y);C(t,_+e,b+r,s,Math.atan2(S-b,v-_),Math.atan2(T-b,w-_),l*h>u*a)}(this._currentPoly.points,t,e,r,i,n),this}arcToSvg(t,e,r,i,n,s,o){return function(t,e,r,i,n,s,o,a=0,l=0,h=0){if(0===s||0===o)return;const u=Math.sin(a*M/360),c=Math.cos(a*M/360),d=c*(e-i)/2+u*(r-n)/2,f=-u*(e-i)/2+c*(r-n)/2;if(0===d&&0===f)return;s=Math.abs(s),o=Math.abs(o);const p=Math.pow(d,2)/Math.pow(s,2)+Math.pow(f,2)/Math.pow(o,2);p>1&&(s*=Math.sqrt(p),o*=Math.sqrt(p)),((t,e,r,i,n,s,o,a,l,h,u,c,d)=>{const f=Math.pow(n,2),p=Math.pow(s,2),g=Math.pow(u,2),x=Math.pow(c,2);let m=f*p-f*x-p*g;m<0&&(m=0),m/=f*x+p*g,m=Math.sqrt(m)*(o===a?-1:1);const y=m*n/s*c,_=m*-s/n*u,b=h*y-l*_+(t+r)/2,v=l*y+h*_+(e+i)/2,S=(u-y)/n,w=(c-_)/s,T=(-u-y)/n,P=(-c-_)/s,C=F(1,0,S,w);let k=F(S,w,T,P);0===a&&k>0&&(k-=M),1===a&&k<0&&(k+=M),d.centerX=b,d.centerY=v,d.ang1=C,d.ang2=k})(e,r,i,n,s,o,l,h,u,c,d,f,k);let{ang1:g,ang2:x}=k;const{centerX:m,centerY:y}=k;let _=Math.abs(x)/(M/4);Math.abs(1-_)<1e-7&&(_=1);const b=Math.max(Math.ceil(_),1);x/=b;let v=t[t.length-2],w=t[t.length-1];const T={x:0,y:0};for(let e=0;e<b;e++){const e=R(g,x),{x:r,y:i}=A(e[0],s,o,c,u,m,y,T),{x:n,y:a}=A(e[1],s,o,c,u,m,y,T),{x:l,y:h}=A(e[2],s,o,c,u,m,y,T);S(t,v,w,r,i,n,a,l,h),v=l,w=h,g+=x}}(this._currentPoly.points,this._currentPoly.lastX,this._currentPoly.lastY,s,o,t,e,r,i,n),this}bezierCurveTo(t,e,r,i,n,s,o){this._ensurePoly();const a=this._currentPoly;return S(this._currentPoly.points,a.lastX,a.lastY,t,e,r,i,n,s,o),this}quadraticCurveTo(t,e,r,i,n){this._ensurePoly();const s=this._currentPoly;return T(this._currentPoly.points,s.lastX,s.lastY,t,e,r,i,n),this}closePath(){return this.endPoly(!0),this}addPath(t,e){this.endPoly(),e&&!e.isIdentity()&&(t=t.clone(!0)).transform(e);const r=this.shapePrimitives,i=r.length;for(let e=0;e<t.instructions.length;e++){const r=t.instructions[e];this[r.action](...r.data)}if(t.checkForHoles&&r.length-i>1){let t=null;for(let e=i;e<r.length;e++){const i=r[e];if("polygon"===i.shape.type){const n=i.shape,s=t?.shape;s&&s.containsPolygon(n)?(t.holes||(t.holes=[]),t.holes.push(i),r.copyWithin(e,e+1),r.length--,e--):t=i}}}return this}finish(t=!1){this.endPoly(t)}rect(t,e,r,i,n){return this.drawShape(new f.M(t,e,r,i),n),this}circle(t,e,r,i){return this.drawShape(new p(t,e,r),i),this}poly(t,e,r){const i=new m(t);return i.closePath=e,this.drawShape(i,r),this}regularPoly(t,e,r,i,n=0,s){i=Math.max(0|i,3);const o=-1*Math.PI/2+n,a=2*Math.PI/i,l=[];for(let n=0;n<i;n++){const i=o-n*a;l.push(t+r*Math.cos(i),e+r*Math.sin(i))}return this.poly(l,!0,s),this}roundPoly(t,e,r,i,n,s=0,o){if(i=Math.max(0|i,3),n<=0)return this.regularPoly(t,e,r,i,s);const a=r*Math.sin(Math.PI/i)-.001;n=Math.min(n,a);const l=-1*Math.PI/2+s,h=2*Math.PI/i,u=(i-2)*Math.PI/i/2;for(let s=0;s<i;s++){const i=s*h+l,a=t+r*Math.cos(i),c=e+r*Math.sin(i),d=i+Math.PI+u,f=i-Math.PI-u,p=a+n*Math.cos(d),g=c+n*Math.sin(d),x=a+n*Math.cos(f),m=c+n*Math.sin(f);0===s?this.moveTo(p,g):this.lineTo(p,g),this.quadraticCurveTo(a,c,x,m,o)}return this.closePath()}roundShape(t,e,r=!1,i){return t.length<3?this:(r?function(t,e,r,i){const n=(t,e)=>Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2),s=(t,e,r)=>({x:t.x+(e.x-t.x)*r,y:t.y+(e.y-t.y)*r}),o=e.length;for(let a=0;a<o;a++){const l=e[(a+1)%o],h=l.radius??r;if(h<=0){0===a?t.moveTo(l.x,l.y):t.lineTo(l.x,l.y);continue}const u=e[a],c=e[(a+2)%o],d=n(u,l);let f;f=d<1e-4?l:s(l,u,Math.min(d/2,h)/d);const p=n(c,l);let g;g=p<1e-4?l:s(l,c,Math.min(p/2,h)/p),0===a?t.moveTo(f.x,f.y):t.lineTo(f.x,f.y),t.quadraticCurveTo(l.x,l.y,g.x,g.y,i)}}(this,t,e,i):function(t,e,r){const i=(t,e)=>{const r=e.x-t.x,i=e.y-t.y,n=Math.sqrt(r*r+i*i);return{len:n,nx:r/n,ny:i/n}},n=(e,r)=>{0===e?t.moveTo(r.x,r.y):t.lineTo(r.x,r.y)};let s=e[e.length-1];for(let o=0;o<e.length;o++){const a=e[o%e.length],l=a.radius??r;if(l<=0){n(o,a),s=a;continue}const h=e[(o+1)%e.length],u=i(a,s),c=i(a,h);if(u.len<1e-4||c.len<1e-4){n(o,a),s=a;continue}let d=Math.asin(u.nx*c.ny-u.ny*c.nx),f=1,p=!1;u.nx*c.nx-u.ny*-c.ny<0?d<0?d=Math.PI+d:(d=Math.PI-d,f=-1,p=!0):d>0&&(f=-1,p=!0);const g=d/2;let x,m=Math.abs(Math.cos(g)*l/Math.sin(g));m>Math.min(u.len/2,c.len/2)?(m=Math.min(u.len/2,c.len/2),x=Math.abs(m*Math.sin(g)/Math.cos(g))):x=l;const y=a.x+c.nx*m+-c.ny*x*f,_=a.y+c.ny*m+c.nx*x*f,b=Math.atan2(u.ny,u.nx)+Math.PI/2*f,v=Math.atan2(c.ny,c.nx)-Math.PI/2*f;0===o&&t.moveTo(y+Math.cos(b)*x,_+Math.sin(b)*x),t.arc(y,_,x,b,v,p),s=a}}(this,t,e),this.closePath())}filletRect(t,e,r,i,n){if(0===n)return this.rect(t,e,r,i);const s=Math.min(r,i)/2,o=Math.min(s,Math.max(-s,n)),a=t+r,l=e+i,h=o<0?-o:0,u=Math.abs(o);return this.moveTo(t,e+u).arcTo(t+h,e+h,t+u,e,u).lineTo(a-u,e).arcTo(a-h,e+h,a,e+u,u).lineTo(a,l-u).arcTo(a-h,l-h,t+r-u,l,u).lineTo(t+u,l).arcTo(t+h,l-h,t,l-u,u).closePath()}chamferRect(t,e,r,i,n,s){if(n<=0)return this.rect(t,e,r,i);const o=Math.min(n,Math.min(r,i)/2),a=t+r,l=e+i,h=[t+o,e,a-o,e,a,e+o,a,l-o,a-o,l,t+o,l,t,l-o,t,e+o];for(let t=h.length-1;t>=2;t-=2)h[t]===h[t-2]&&h[t-1]===h[t-3]&&h.splice(t-1,2);return this.poly(h,!0,s)}ellipse(t,e,r,i,n){return this.drawShape(new g(t,e,r,i),n),this}roundRect(t,e,r,i,n,s){return this.drawShape(new _(t,e,r,i,n),s),this}drawShape(t,e){return this.endPoly(),this.shapePrimitives.push({shape:t,transform:e}),this}startPoly(t,e){let r=this._currentPoly;return r&&this.endPoly(),r=new m,r.points.push(t,e),this._currentPoly=r,this}endPoly(t=!1){const e=this._currentPoly;return e&&e.points.length>2&&(e.closePath=t,this.shapePrimitives.push({shape:e})),this._currentPoly=null,this}_ensurePoly(t=!0){if(!this._currentPoly&&(this._currentPoly=new m,t)){const t=this.shapePrimitives[this.shapePrimitives.length-1];if(t){let e=t.shape.x,r=t.shape.y;if(t.transform&&!t.transform.isIdentity()){const i=t.transform,n=e;e=i.a*e+i.c*r+i.tx,r=i.b*n+i.d*r+i.ty}this._currentPoly.points.push(e,r)}else this._currentPoly.points.push(0,0)}}buildPath(){const t=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let e=0;e<t.instructions.length;e++){const r=t.instructions[e];this[r.action](...r.data)}this.finish()}get bounds(){const t=this._bounds;t.clear();const e=this.shapePrimitives;for(let r=0;r<e.length;r++){const i=e[r],n=i.shape.getBounds(z);i.transform?t.addRect(n,i.transform):t.addRect(n)}return t}}class U{constructor(t,e=!1){this.instructions=[],this.uid=(0,l.L)("graphicsPath"),this._dirty=!0,this.checkForHoles=e,"string"==typeof t?function(t,e){const r=d(t),i=[];let n=null,s=0,o=0;for(let t=0;t<r.length;t++){const a=r[t],l=a[0],h=a;switch(l){case"M":s=h[1],o=h[2],e.moveTo(s,o);break;case"m":s+=h[1],o+=h[2],e.moveTo(s,o);break;case"H":s=h[1],e.lineTo(s,o);break;case"h":s+=h[1],e.lineTo(s,o);break;case"V":o=h[1],e.lineTo(s,o);break;case"v":o+=h[1],e.lineTo(s,o);break;case"L":s=h[1],o=h[2],e.lineTo(s,o);break;case"l":s+=h[1],o+=h[2],e.lineTo(s,o);break;case"C":s=h[5],o=h[6],e.bezierCurveTo(h[1],h[2],h[3],h[4],s,o);break;case"c":e.bezierCurveTo(s+h[1],o+h[2],s+h[3],o+h[4],s+h[5],o+h[6]),s+=h[5],o+=h[6];break;case"S":s=h[3],o=h[4],e.bezierCurveToShort(h[1],h[2],s,o);break;case"s":e.bezierCurveToShort(s+h[1],o+h[2],s+h[3],o+h[4]),s+=h[3],o+=h[4];break;case"Q":s=h[3],o=h[4],e.quadraticCurveTo(h[1],h[2],s,o);break;case"q":e.quadraticCurveTo(s+h[1],o+h[2],s+h[3],o+h[4]),s+=h[3],o+=h[4];break;case"T":s=h[1],o=h[2],e.quadraticCurveToShort(s,o);break;case"t":s+=h[1],o+=h[2],e.quadraticCurveToShort(s,o);break;case"A":s=h[6],o=h[7],e.arcToSvg(h[1],h[2],h[3],h[4],h[5],s,o);break;case"a":s+=h[6],o+=h[7],e.arcToSvg(h[1],h[2],h[3],h[4],h[5],s,o);break;case"Z":case"z":e.closePath(),i.length>0&&(n=i.pop(),n?(s=n.startX,o=n.startY):(s=0,o=0)),n=null;break;default:(0,c.R)(`Unknown SVG path command: ${l}`)}"Z"!==l&&"z"!==l&&null===n&&(n={startX:s,startY:o},i.push(n))}}(t,this):this.instructions=t?.slice()??[]}get shapePath(){return this._shapePath||(this._shapePath=new B(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(t,e){return t=t.clone(),this.instructions.push({action:"addPath",data:[t,e]}),this._dirty=!0,this}arc(...t){return this.instructions.push({action:"arc",data:t}),this._dirty=!0,this}arcTo(...t){return this.instructions.push({action:"arcTo",data:t}),this._dirty=!0,this}arcToSvg(...t){return this.instructions.push({action:"arcToSvg",data:t}),this._dirty=!0,this}bezierCurveTo(...t){return this.instructions.push({action:"bezierCurveTo",data:t}),this._dirty=!0,this}bezierCurveToShort(t,e,r,i,n){const s=this.instructions[this.instructions.length-1],a=this.getLastPoint(o.b.shared);let l=0,h=0;if(s&&"bezierCurveTo"===s.action){l=s.data[2],h=s.data[3];const t=a.x,e=a.y;l=t+(t-l),h=e+(e-h)}else l=a.x,h=a.y;return this.instructions.push({action:"bezierCurveTo",data:[l,h,t,e,r,i,n]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...t){return this.instructions.push({action:"ellipse",data:t}),this._dirty=!0,this}lineTo(...t){return this.instructions.push({action:"lineTo",data:t}),this._dirty=!0,this}moveTo(...t){return this.instructions.push({action:"moveTo",data:t}),this}quadraticCurveTo(...t){return this.instructions.push({action:"quadraticCurveTo",data:t}),this._dirty=!0,this}quadraticCurveToShort(t,e,r){const i=this.instructions[this.instructions.length-1],n=this.getLastPoint(o.b.shared);let s=0,a=0;if(i&&"quadraticCurveTo"===i.action){s=i.data[0],a=i.data[1];const t=n.x,e=n.y;s=t+(t-s),a=e+(e-a)}else s=n.x,a=n.y;return this.instructions.push({action:"quadraticCurveTo",data:[s,a,t,e,r]}),this._dirty=!0,this}rect(t,e,r,i,n){return this.instructions.push({action:"rect",data:[t,e,r,i,n]}),this._dirty=!0,this}circle(t,e,r,i){return this.instructions.push({action:"circle",data:[t,e,r,i]}),this._dirty=!0,this}roundRect(...t){return this.instructions.push({action:"roundRect",data:t}),this._dirty=!0,this}poly(...t){return this.instructions.push({action:"poly",data:t}),this._dirty=!0,this}regularPoly(...t){return this.instructions.push({action:"regularPoly",data:t}),this._dirty=!0,this}roundPoly(...t){return this.instructions.push({action:"roundPoly",data:t}),this._dirty=!0,this}roundShape(...t){return this.instructions.push({action:"roundShape",data:t}),this._dirty=!0,this}filletRect(...t){return this.instructions.push({action:"filletRect",data:t}),this._dirty=!0,this}chamferRect(...t){return this.instructions.push({action:"chamferRect",data:t}),this._dirty=!0,this}star(t,e,r,i,n,s,o){n||(n=i/2);const a=-1*Math.PI/2+s,l=2*r,h=2*Math.PI/l,u=[];for(let r=0;r<l;r++){const s=r%2?n:i,o=r*h+a;u.push(t+s*Math.cos(o),e+s*Math.sin(o))}return this.poly(u,!0,o),this}clone(t=!1){const e=new U;if(e.checkForHoles=this.checkForHoles,t)for(let t=0;t<this.instructions.length;t++){const r=this.instructions[t];e.instructions.push({action:r.action,data:r.data.slice()})}else e.instructions=this.instructions.slice();return e}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(t){if(t.isIdentity())return this;const e=t.a,r=t.b,i=t.c,n=t.d,s=t.tx,o=t.ty;let a=0,l=0,h=0,u=0,d=0,f=0,p=0,g=0;for(let x=0;x<this.instructions.length;x++){const m=this.instructions[x],y=m.data;switch(m.action){case"moveTo":case"lineTo":a=y[0],l=y[1],y[0]=e*a+i*l+s,y[1]=r*a+n*l+o;break;case"bezierCurveTo":h=y[0],u=y[1],d=y[2],f=y[3],a=y[4],l=y[5],y[0]=e*h+i*u+s,y[1]=r*h+n*u+o,y[2]=e*d+i*f+s,y[3]=r*d+n*f+o,y[4]=e*a+i*l+s,y[5]=r*a+n*l+o;break;case"quadraticCurveTo":h=y[0],u=y[1],a=y[2],l=y[3],y[0]=e*h+i*u+s,y[1]=r*h+n*u+o,y[2]=e*a+i*l+s,y[3]=r*a+n*l+o;break;case"arcToSvg":a=y[5],l=y[6],p=y[0],g=y[1],y[0]=e*p+i*g,y[1]=r*p+n*g,y[5]=e*a+i*l+s,y[6]=r*a+n*l+o;break;case"circle":y[4]=I(y[3],t);break;case"rect":y[4]=I(y[4],t);break;case"ellipse":y[8]=I(y[8],t);break;case"roundRect":y[5]=I(y[5],t);break;case"addPath":y[0].transform(t);break;case"poly":y[2]=I(y[2],t);break;default:(0,c.R)("unknown transform action",m.action)}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(t){let e=this.instructions.length-1,r=this.instructions[e];if(!r)return t.x=0,t.y=0,t;for(;"closePath"===r.action;){if(e--,e<0)return t.x=0,t.y=0,t;r=this.instructions[e]}switch(r.action){case"moveTo":case"lineTo":t.x=r.data[0],t.y=r.data[1];break;case"quadraticCurveTo":t.x=r.data[2],t.y=r.data[3];break;case"bezierCurveTo":t.x=r.data[4],t.y=r.data[5];break;case"arc":case"arcToSvg":t.x=r.data[5],t.y=r.data[6];break;case"addPath":r.data[0].getLastPoint(t)}return t}}function I(t,e){return t?t.prepend(e):e.clone()}var G=r(7276);function D(t,e,r){const i=t.getAttribute(e);return i?Number(i):r}function E(t){const e=D(t,"x1",0),r=D(t,"y1",0),i=D(t,"x2",1),s=D(t,"y2",0),o=t.getAttribute("gradientUnits")||"objectBoundingBox",a=new G._(e,r,i,s,"objectBoundingBox"===o?"local":"global");for(let e=0;e<t.children.length;e++){const r=t.children[e],i=D(r,"offset",0),s=n.Q.shared.setValue(r.getAttribute("stop-color")).toNumber();a.addColorStop(i,s)}return a}function O(t){return(0,c.R)("[SVG Parser] Radial gradients are not yet supported"),new G._(0,0,1,0)}function V(t){const e=t.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);return e?e[1]:""}const W={fill:{type:"paint",default:0},"fill-opacity":{type:"number",default:1},stroke:{type:"paint",default:0},"stroke-width":{type:"number",default:1},"stroke-opacity":{type:"number",default:1},"stroke-linecap":{type:"string",default:"butt"},"stroke-linejoin":{type:"string",default:"miter"},"stroke-miterlimit":{type:"number",default:10},"stroke-dasharray":{type:"string",default:"none"},"stroke-dashoffset":{type:"number",default:0},opacity:{type:"number",default:1}};function L(t,e){const r=t.getAttribute("style"),i={},n={},s={strokeStyle:i,fillStyle:n,useFill:!1,useStroke:!1};for(const r in W){const i=t.getAttribute(r);i&&$(e,s,r,i.trim())}if(r){const t=r.split(";");for(let r=0;r<t.length;r++){const i=t[r].trim(),[n,o]=i.split(":");W[n]&&$(e,s,n,o.trim())}}return{strokeStyle:s.useStroke?i:null,fillStyle:s.useFill?n:null,useFill:s.useFill,useStroke:s.useStroke}}function $(t,e,r,i){switch(r){case"stroke":if("none"!==i){if(i.startsWith("url(")){const r=V(i);e.strokeStyle.fill=t.defs[r]}else e.strokeStyle.color=n.Q.shared.setValue(i).toNumber();e.useStroke=!0}break;case"stroke-width":e.strokeStyle.width=Number(i);break;case"fill":if("none"!==i){if(i.startsWith("url(")){const r=V(i);e.fillStyle.fill=t.defs[r]}else e.fillStyle.color=n.Q.shared.setValue(i).toNumber();e.useFill=!0}break;case"fill-opacity":e.fillStyle.alpha=Number(i);break;case"stroke-opacity":e.strokeStyle.alpha=Number(i);break;case"opacity":e.fillStyle.alpha=Number(i),e.strokeStyle.alpha=Number(i)}}function H(t){const e=t.match(/[-+]?[0-9]*\.?[0-9]+/g);if(!e||e.length<4)return 0;const r=e.map(Number),i=[],n=[];for(let t=0;t<r.length;t+=2)t+1<r.length&&(i.push(r[t]),n.push(r[t+1]));if(0===i.length||0===n.length)return 0;const s=Math.min(...i),o=Math.max(...i),a=Math.min(...n);return(o-s)*(Math.max(...n)-a)}function j(t,e){const r=new U(t,!1);for(const t of r.instructions)e.instructions.push(t)}function X(t,e,r,i){const n=t.children,{fillStyle:s,strokeStyle:o}=L(t,e);s&&r?r={...r,...s}:s&&(r=s),o&&i?i={...i,...o}:o&&(i=o);const a=!r&&!i;let l,h,u,d,f,p,g,x,m,y,_,b,v,S,w,T,P;switch(a&&(r={color:0}),t.nodeName.toLowerCase()){case"path":{S=t.getAttribute("d");const n=t.getAttribute("fill-rule"),s=S.split(/(?=[Mm])/).filter(t=>t.trim().length>0),o="evenodd"===n,a=s.length>1;if(o&&a){const t=s.map(t=>({path:t,area:H(t)}));t.sort((t,e)=>e.area-t.area);const n=s.length>3||!function(t){if(t.length<=2)return!0;const e=t.map(t=>t.area).sort((t,e)=>e-t),[r,i]=e,n=e[e.length-1];return!(r/i>3&&i/n<2)}(t);if(n)for(let n=0;n<t.length;n++){const s=t[n],o=0===n;e.context.beginPath();const a=new U(void 0,!0);j(s.path,a),e.context.path(a),o?(r&&e.context.fill(r),i&&e.context.stroke(i)):e.context.cut()}else for(let n=0;n<t.length;n++){const s=t[n],o=n%2==1;e.context.beginPath();const a=new U(void 0,!0);j(s.path,a),e.context.path(a),o?e.context.cut():(r&&e.context.fill(r),i&&e.context.stroke(i))}}else w=new U(S,!n||"evenodd"===n),e.context.path(w),r&&e.context.fill(r),i&&e.context.stroke(i);break}case"circle":g=D(t,"cx",0),x=D(t,"cy",0),m=D(t,"r",0),e.context.ellipse(g,x,m,m),r&&e.context.fill(r),i&&e.context.stroke(i);break;case"rect":l=D(t,"x",0),h=D(t,"y",0),T=D(t,"width",0),P=D(t,"height",0),y=D(t,"rx",0),_=D(t,"ry",0),y||_?e.context.roundRect(l,h,T,P,y||_):e.context.rect(l,h,T,P),r&&e.context.fill(r),i&&e.context.stroke(i);break;case"ellipse":g=D(t,"cx",0),x=D(t,"cy",0),y=D(t,"rx",0),_=D(t,"ry",0),e.context.beginPath(),e.context.ellipse(g,x,y,_),r&&e.context.fill(r),i&&e.context.stroke(i);break;case"line":u=D(t,"x1",0),d=D(t,"y1",0),f=D(t,"x2",0),p=D(t,"y2",0),e.context.beginPath(),e.context.moveTo(u,d),e.context.lineTo(f,p),i&&e.context.stroke(i);break;case"polygon":v=t.getAttribute("points"),b=v.match(/\d+/g).map(t=>parseInt(t,10)),e.context.poly(b,!0),r&&e.context.fill(r),i&&e.context.stroke(i);break;case"polyline":v=t.getAttribute("points"),b=v.match(/\d+/g).map(t=>parseInt(t,10)),e.context.poly(b,!1),i&&e.context.stroke(i);break;case"g":case"svg":break;default:(0,c.R)(`[SVG parser] <${t.nodeName}> elements unsupported`)}a&&(r=null);for(let t=0;t<n.length;t++)X(n[t],e,r,i)}var N=r(990);const Y=new o.b,q=new s.u,K=class t extends i.A{constructor(){super(...arguments),this.uid=(0,l.L)("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new U,this._transform=new s.u,this._fillStyle={...t.defaultFillStyle},this._strokeStyle={...t.defaultStrokeStyle},this._stateStack=[],this._tick=0,this._bounds=new u.c,this._boundsDirty=!0}clone(){const e=new t;return e.batchMode=this.batchMode,e.instructions=this.instructions.slice(),e._activePath=this._activePath.clone(),e._transform=this._transform.clone(),e._fillStyle={...this._fillStyle},e._strokeStyle={...this._strokeStyle},e._stateStack=this._stateStack.slice(),e._bounds=this._bounds.clone(),e._boundsDirty=!0,e}get fillStyle(){return this._fillStyle}set fillStyle(e){this._fillStyle=(0,N.w)(e,t.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(e){this._strokeStyle=(0,N.T)(e,t.defaultStrokeStyle)}setFillStyle(e){return this._fillStyle=(0,N.w)(e,t.defaultFillStyle),this}setStrokeStyle(e){return this._strokeStyle=(0,N.w)(e,t.defaultStrokeStyle),this}texture(t,e,r,i,s,o){return this.instructions.push({action:"texture",data:{image:t,dx:r||0,dy:i||0,dw:s||t.frame.width,dh:o||t.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:e?n.Q.shared.setValue(e).toNumber():16777215}}),this.onUpdate(),this}beginPath(){return this._activePath=new U,this}fill(e,r){let i;const n=this.instructions[this.instructions.length-1];return i=0===this._tick&&"stroke"===n?.action?n.data.path:this._activePath.clone(),i?(null!=e&&(void 0!==r&&"number"==typeof e&&((0,h.t6)(h.lj,"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),e={color:e,alpha:r}),this._fillStyle=(0,N.w)(e,t.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:i}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:t,y:e}=this._activePath.getLastPoint(o.b.shared);this._activePath.clear(),this._activePath.moveTo(t,e)}stroke(e){let r;const i=this.instructions[this.instructions.length-1];return r=0===this._tick&&"fill"===i?.action?i.data.path:this._activePath.clone(),r?(null!=e&&(this._strokeStyle=(0,N.T)(e,t.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:r}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let t=0;t<2;t++){const e=this.instructions[this.instructions.length-1-t],r=this._activePath.clone();if(e&&("stroke"===e.action||"fill"===e.action)){if(!e.data.hole){e.data.hole=r;break}e.data.hole.addPath(r)}}return this._initNextPathLocation(),this}arc(t,e,r,i,n,s){this._tick++;const o=this._transform;return this._activePath.arc(o.a*t+o.c*e+o.tx,o.b*t+o.d*e+o.ty,r,i,n,s),this}arcTo(t,e,r,i,n){this._tick++;const s=this._transform;return this._activePath.arcTo(s.a*t+s.c*e+s.tx,s.b*t+s.d*e+s.ty,s.a*r+s.c*i+s.tx,s.b*r+s.d*i+s.ty,n),this}arcToSvg(t,e,r,i,n,s,o){this._tick++;const a=this._transform;return this._activePath.arcToSvg(t,e,r,i,n,a.a*s+a.c*o+a.tx,a.b*s+a.d*o+a.ty),this}bezierCurveTo(t,e,r,i,n,s,o){this._tick++;const a=this._transform;return this._activePath.bezierCurveTo(a.a*t+a.c*e+a.tx,a.b*t+a.d*e+a.ty,a.a*r+a.c*i+a.tx,a.b*r+a.d*i+a.ty,a.a*n+a.c*s+a.tx,a.b*n+a.d*s+a.ty,o),this}closePath(){return this._tick++,this._activePath?.closePath(),this}ellipse(t,e,r,i){return this._tick++,this._activePath.ellipse(t,e,r,i,this._transform.clone()),this}circle(t,e,r){return this._tick++,this._activePath.circle(t,e,r,this._transform.clone()),this}path(t){return this._tick++,this._activePath.addPath(t,this._transform.clone()),this}lineTo(t,e){this._tick++;const r=this._transform;return this._activePath.lineTo(r.a*t+r.c*e+r.tx,r.b*t+r.d*e+r.ty),this}moveTo(t,e){this._tick++;const r=this._transform,i=this._activePath.instructions,n=r.a*t+r.c*e+r.tx,s=r.b*t+r.d*e+r.ty;return 1===i.length&&"moveTo"===i[0].action?(i[0].data[0]=n,i[0].data[1]=s,this):(this._activePath.moveTo(n,s),this)}quadraticCurveTo(t,e,r,i,n){this._tick++;const s=this._transform;return this._activePath.quadraticCurveTo(s.a*t+s.c*e+s.tx,s.b*t+s.d*e+s.ty,s.a*r+s.c*i+s.tx,s.b*r+s.d*i+s.ty,n),this}rect(t,e,r,i){return this._tick++,this._activePath.rect(t,e,r,i,this._transform.clone()),this}roundRect(t,e,r,i,n){return this._tick++,this._activePath.roundRect(t,e,r,i,n,this._transform.clone()),this}poly(t,e){return this._tick++,this._activePath.poly(t,e,this._transform.clone()),this}regularPoly(t,e,r,i,n=0,s){return this._tick++,this._activePath.regularPoly(t,e,r,i,n,s),this}roundPoly(t,e,r,i,n,s){return this._tick++,this._activePath.roundPoly(t,e,r,i,n,s),this}roundShape(t,e,r,i){return this._tick++,this._activePath.roundShape(t,e,r,i),this}filletRect(t,e,r,i,n){return this._tick++,this._activePath.filletRect(t,e,r,i,n),this}chamferRect(t,e,r,i,n,s){return this._tick++,this._activePath.chamferRect(t,e,r,i,n,s),this}star(t,e,r,i,n=0,s=0){return this._tick++,this._activePath.star(t,e,r,i,n,s,this._transform.clone()),this}svg(t){return this._tick++,function(t,e){if("string"==typeof t){const e=document.createElement("div");e.innerHTML=t.trim(),t=e.querySelector("svg")}const r={context:e,defs:{},path:new U};!function(t,e){const r=t.querySelectorAll("defs");for(let t=0;t<r.length;t++){const i=r[t];for(let t=0;t<i.children.length;t++){const r=i.children[t];switch(r.nodeName.toLowerCase()){case"lineargradient":e.defs[r.id]=E(r);break;case"radialgradient":e.defs[r.id]=O()}}}}(t,r);const i=t.children,{fillStyle:n,strokeStyle:s}=L(t,r);for(let t=0;t<i.length;t++){const e=i[t];"defs"!==e.nodeName.toLowerCase()&&X(e,r,n,s)}}(t,this),this}restore(){const t=this._stateStack.pop();return t&&(this._transform=t.transform,this._fillStyle=t.fillStyle,this._strokeStyle=t.strokeStyle),this}save(){return this._stateStack.push({transform:this._transform.clone(),fillStyle:{...this._fillStyle},strokeStyle:{...this._strokeStyle}}),this}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(t){return this._transform.rotate(t),this}scale(t,e=t){return this._transform.scale(t,e),this}setTransform(t,e,r,i,n,o){return t instanceof s.u?(this._transform.set(t.a,t.b,t.c,t.d,t.tx,t.ty),this):(this._transform.set(t,e,r,i,n,o),this)}transform(t,e,r,i,n,o){return t instanceof s.u?(this._transform.append(t),this):(q.set(t,e,r,i,n,o),this._transform.append(q),this)}translate(t,e=t){return this._transform.translate(t,e),this}clear(){return this._activePath.clear(),this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this._boundsDirty=!0,this.dirty||(this.emit("update",this,16),this.dirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;this._boundsDirty=!1;const t=this._bounds;t.clear();for(let e=0;e<this.instructions.length;e++){const r=this.instructions[e],i=r.action;if("fill"===i){const e=r.data;t.addBounds(e.path.bounds)}else if("texture"===i){const e=r.data;t.addFrame(e.dx,e.dy,e.dx+e.dw,e.dy+e.dh,e.transform)}if("stroke"===i){const e=r.data,i=e.style.alignment,n=e.style.width*(1-i),s=e.path.bounds;t.addFrame(s.minX-n,s.minY-n,s.maxX+n,s.maxY+n)}}return t}containsPoint(t){if(!this.bounds.containsPoint(t.x,t.y))return!1;const e=this.instructions;let r=!1;for(let i=0;i<e.length;i++){const n=e[i],s=n.data,o=s.path;if(!n.action||!o)continue;const a=s.style,l=o.shapePath.shapePrimitives;for(let e=0;e<l.length;e++){const i=l[e].shape;if(!a||!i)continue;const o=l[e].transform,h=o?o.applyInverse(t,Y):t;if("fill"===n.action)r=i.contains(h.x,h.y);else{const t=a;r=i.strokeContains(h.x,h.y,t.width,t.alignment)}const u=s.hole;if(u){const t=u.shapePath?.shapePrimitives;if(t)for(let e=0;e<t.length;e++)t[e].shape.contains(h.x,h.y)&&(r=!1)}if(r)return!0}}return r}destroy(t=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),"boolean"==typeof t?t:t?.texture){const e="boolean"==typeof t?t:t?.textureSource;this._fillStyle.texture&&(this._fillStyle.fill&&"uid"in this._fillStyle.fill?this._fillStyle.fill.destroy():this._fillStyle.texture.destroy(e)),this._strokeStyle.texture&&(this._strokeStyle.fill&&"uid"in this._strokeStyle.fill?this._strokeStyle.fill.destroy():this._strokeStyle.texture.destroy(e))}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};K.defaultFillStyle={color:16777215,alpha:1,texture:a.g.WHITE,matrix:null,fill:null,textureSpace:"local"},K.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:a.g.WHITE,matrix:null,fill:null,textureSpace:"local",pixelLine:!1};let Z=K},8291:(t,e,r)=>{"use strict";r.d(e,{x:()=>f});var i=r(4486),n=r(2577),s=r(133),o=r(4670),a=r(268),l=r(7276),h=r(2806),u=r(8288),c=r(990);const d=class t extends i.A{constructor(e={}){super(),this.uid=(0,s.L)("textStyle"),this._tick=0,function(t){const e=t;if("boolean"==typeof e.dropShadow&&e.dropShadow){const r=f.defaultDropShadow;t.dropShadow={alpha:e.dropShadowAlpha??r.alpha,angle:e.dropShadowAngle??r.angle,blur:e.dropShadowBlur??r.blur,color:e.dropShadowColor??r.color,distance:e.dropShadowDistance??r.distance}}if(void 0!==e.strokeThickness){(0,o.t6)(o.lj,"strokeThickness is now a part of stroke");const r=e.stroke;let i={};if(n.Q.isColorLike(r))i.color=r;else if(r instanceof l._||r instanceof h.m)i.fill=r;else{if(!Object.hasOwnProperty.call(r,"color")&&!Object.hasOwnProperty.call(r,"fill"))throw new Error("Invalid stroke value.");i=r}t.stroke={...i,width:e.strokeThickness}}if(Array.isArray(e.fillGradientStops)){if((0,o.t6)(o.lj,"gradient fill is now a fill pattern: `new FillGradient(...)`"),!Array.isArray(e.fill)||0===e.fill.length)throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");e.fill.length!==e.fillGradientStops.length&&(0,a.R)("The number of fill colors must match the number of fill gradient stops.");const r=new l._({start:{x:0,y:0},end:{x:0,y:1},textureSpace:"local"}),i=e.fillGradientStops.slice(),s=e.fill.map(t=>n.Q.shared.setValue(t).toNumber());i.forEach((t,e)=>{r.addColorStop(t,s[e])}),t.fill={fill:r}}}(e);const r={...t.defaultTextStyle,...e};for(const t in r)this[t]=r[t];this.update(),this._tick=0}get align(){return this._align}set align(t){this._align!==t&&(this._align=t,this.update())}get breakWords(){return this._breakWords}set breakWords(t){this._breakWords!==t&&(this._breakWords=t,this.update())}get dropShadow(){return this._dropShadow}set dropShadow(e){this._dropShadow!==e&&(this._dropShadow=null!==e&&"object"==typeof e?this._createProxy({...t.defaultDropShadow,...e}):e?this._createProxy({...t.defaultDropShadow}):null,this.update())}get fontFamily(){return this._fontFamily}set fontFamily(t){this._fontFamily!==t&&(this._fontFamily=t,this.update())}get fontSize(){return this._fontSize}set fontSize(t){this._fontSize!==t&&(this._fontSize="string"==typeof t?parseInt(t,10):t,this.update())}get fontStyle(){return this._fontStyle}set fontStyle(t){this._fontStyle!==t&&(this._fontStyle=t.toLowerCase(),this.update())}get fontVariant(){return this._fontVariant}set fontVariant(t){this._fontVariant!==t&&(this._fontVariant=t,this.update())}get fontWeight(){return this._fontWeight}set fontWeight(t){this._fontWeight!==t&&(this._fontWeight=t,this.update())}get leading(){return this._leading}set leading(t){this._leading!==t&&(this._leading=t,this.update())}get letterSpacing(){return this._letterSpacing}set letterSpacing(t){this._letterSpacing!==t&&(this._letterSpacing=t,this.update())}get lineHeight(){return this._lineHeight}set lineHeight(t){this._lineHeight!==t&&(this._lineHeight=t,this.update())}get padding(){return this._padding}set padding(t){this._padding!==t&&(this._padding=t,this.update())}get filters(){return this._filters}set filters(t){this._filters!==t&&(this._filters=Object.freeze(t),this.update())}get trim(){return this._trim}set trim(t){this._trim!==t&&(this._trim=t,this.update())}get textBaseline(){return this._textBaseline}set textBaseline(t){this._textBaseline!==t&&(this._textBaseline=t,this.update())}get whiteSpace(){return this._whiteSpace}set whiteSpace(t){this._whiteSpace!==t&&(this._whiteSpace=t,this.update())}get wordWrap(){return this._wordWrap}set wordWrap(t){this._wordWrap!==t&&(this._wordWrap=t,this.update())}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(t){this._wordWrapWidth!==t&&(this._wordWrapWidth=t,this.update())}get fill(){return this._originalFill}set fill(t){t!==this._originalFill&&(this._originalFill=t,this._isFillStyle(t)&&(this._originalFill=this._createProxy({...u.T.defaultFillStyle,...t},()=>{this._fill=(0,c.w)({...this._originalFill},u.T.defaultFillStyle)})),this._fill=(0,c.w)(0===t?"black":t,u.T.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(t){t!==this._originalStroke&&(this._originalStroke=t,this._isFillStyle(t)&&(this._originalStroke=this._createProxy({...u.T.defaultStrokeStyle,...t},()=>{this._stroke=(0,c.T)({...this._originalStroke},u.T.defaultStrokeStyle)})),this._stroke=(0,c.T)(t,u.T.defaultStrokeStyle),this.update())}update(){this._tick++,this.emit("update",this)}reset(){const e=t.defaultTextStyle;for(const t in e)this[t]=e[t]}get styleKey(){return`${this.uid}-${this._tick}`}clone(){return new t({align:this.align,breakWords:this.breakWords,dropShadow:this._dropShadow?{...this._dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,filters:this._filters?[...this._filters]:void 0})}_getFinalPadding(){let t=0;if(this._filters)for(let e=0;e<this._filters.length;e++)t+=this._filters[e].padding;return Math.max(this._padding,t)}destroy(t=!1){if(this.removeAllListeners(),"boolean"==typeof t?t:t?.texture){const e="boolean"==typeof t?t:t?.textureSource;this._fill?.texture&&this._fill.texture.destroy(e),this._originalFill?.texture&&this._originalFill.texture.destroy(e),this._stroke?.texture&&this._stroke.texture.destroy(e),this._originalStroke?.texture&&this._originalStroke.texture.destroy(e)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}_createProxy(t,e){return new Proxy(t,{set:(t,r,i)=>(t[r]===i||(t[r]=i,e?.(r,i),this.update()),!0)})}_isFillStyle(t){return null!==(t??null)&&!(n.Q.isColorLike(t)||t instanceof l._||t instanceof h.m)}};d.defaultDropShadow={alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5},d.defaultTextStyle={align:"left",breakWords:!1,dropShadow:null,fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};let f=d},8306:(t,e,r)=>{"use strict";r.d(e,{m:()=>n});const i={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function n(t){return i[t]??i.float32}},8422:(t,e,r)=>{"use strict";r.d(e,{K:()=>i});class i{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}destroy(){}}},8475:(t,e,r)=>{"use strict";r.d(e,{M:()=>u});var i=r(4486),n=r(133),s=r(9113),o=r(3513),a=r(3012),l=r(5099),h=r(5811);class u extends i.A{constructor(t){super(),this.uid=(0,n.L)("shader"),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[],this._destroyed=!1;let{gpuProgram:e,glProgram:r,groups:i,resources:s,compatibleRenderers:a,groupMap:u}=t;this.gpuProgram=e,this.glProgram=r,void 0===a&&(a=0,e&&(a|=l.W.WEBGPU),r&&(a|=l.W.WEBGL)),this.compatibleRenderers=a;const c={};if(s||i||(s={}),s&&i)throw new Error("[Shader] Cannot have both resources and groups");if(!e&&i&&!u)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!e&&i&&u)for(const t in u)for(const e in u[t]){const r=u[t][e];c[r]={group:t,binding:e,name:r}}else if(e&&i&&!u){const t=e.structsAndGroups.groups;u={},t.forEach(t=>{u[t.group]=u[t.group]||{},u[t.group][t.binding]=t.name,c[t.name]=t})}else if(s){i={},u={},e&&e.structsAndGroups.groups.forEach(t=>{u[t.group]=u[t.group]||{},u[t.group][t.binding]=t.name,c[t.name]=t});let t=0;for(const e in s)c[e]||(i[99]||(i[99]=new o.T,this._ownedBindGroups.push(i[99])),c[e]={group:99,binding:t,name:e},u[99]=u[99]||{},u[99][t]=e,t++);for(const t in s){const e=t;let r=s[t];r.source||r._resourceType||(r=new h.k(r));const n=c[e];n&&(i[n.group]||(i[n.group]=new o.T,this._ownedBindGroups.push(i[n.group])),i[n.group].setResource(r,n.binding))}}this.groups=i,this._uniformBindMap=u,this.resources=this._buildResourceAccessor(i,c)}addResource(t,e,r){var i,n;(i=this._uniformBindMap)[e]||(i[e]={}),(n=this._uniformBindMap[e])[r]||(n[r]=t),this.groups[e]||(this.groups[e]=new o.T,this._ownedBindGroups.push(this.groups[e]))}_buildResourceAccessor(t,e){const r={};for(const i in e){const n=e[i];Object.defineProperty(r,n.name,{get:()=>t[n.group].getResource(n.binding),set(e){t[n.group].setResource(e,n.binding)}})}return r}destroy(t=!1){this._destroyed||(this._destroyed=!0,this.emit("destroy",this),t&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(t=>{t.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null)}static from(t){const{gpu:e,gl:r,...i}=t;let n,o;return e&&(n=a.B.from(e)),r&&(o=s.M.from(r)),new u({gpuProgram:n,glProgram:o,...i})}}},8734:(t,e,r)=>{"use strict";r.d(e,{U:()=>i});class i{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._textureMatrixUpdateId=-1,this._uvUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(t){this._topology=t}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}setTexture(t){this.texture!==t&&(this.texture=t,this._textureMatrixUpdateId=-1)}get uvs(){const t=this.geometry.getBuffer("aUV"),e=t.data;let r=e;const i=this.texture.textureMatrix;return i.isSimple||(r=this._transformedUvs,this._textureMatrixUpdateId===i._updateID&&this._uvUpdateId===t._updateID||((!r||r.length<e.length)&&(r=this._transformedUvs=new Float32Array(e.length)),this._textureMatrixUpdateId=i._updateID,this._uvUpdateId=t._updateID,i.multiplyUvs(e,r))),r}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}},8928:(t,e,r)=>{"use strict";var i=r(8507),n=r(6442),s=r(7547),o=r(8655),a=r(2760),l=r(6954);class h{constructor(){this.batches=[],this.batched=!1}destroy(){this.batches.forEach(t=>{o.Z.return(t)}),this.batches.length=0}}class u{constructor(t,e){this.state=s.U.for2d(),this.renderer=t,this._adaptor=e,this.renderer.runners.contextChange.add(this)}contextChange(){this._adaptor.contextChange(this.renderer)}validateRenderable(t){const e=t.context,r=!!t._gpuData,i=this.renderer.graphicsContext.updateGpuContext(e);return!(!i.isBatchable&&r===i.isBatchable)}addRenderable(t,e){const r=this.renderer.graphicsContext.updateGpuContext(t.context);t.didViewUpdate&&this._rebuild(t),r.isBatchable?this._addToBatcher(t,e):(this.renderer.renderPipes.batch.break(e),e.add(t))}updateRenderable(t){const e=this._getGpuDataForRenderable(t).batches;for(let t=0;t<e.length;t++){const r=e[t];r._batcher.updateElement(r)}}execute(t){if(!t.isRenderable)return;const e=this.renderer,r=t.context;if(!e.graphicsContext.getGpuContext(r).batches.length)return;const i=r.customShader||this._adaptor.shader;this.state.blendMode=t.groupBlendMode;const n=i.resources.localUniforms.uniforms;n.uTransformMatrix=t.groupTransform,n.uRound=e._roundPixels|t._roundPixels,(0,a.V)(t.groupColorAlpha,n.uColor,0),this._adaptor.execute(this,t)}_rebuild(t){const e=this._getGpuDataForRenderable(t),r=this.renderer.graphicsContext.updateGpuContext(t.context);e.destroy(),r.isBatchable&&this._updateBatchesForRenderable(t,e)}_addToBatcher(t,e){const r=this.renderer.renderPipes.batch,i=this._getGpuDataForRenderable(t).batches;for(let t=0;t<i.length;t++){const n=i[t];r.addToBatch(n,e)}}_getGpuDataForRenderable(t){return t._gpuData[this.renderer.uid]||this._initGpuDataForRenderable(t)}_initGpuDataForRenderable(t){const e=new h;return t._gpuData[this.renderer.uid]=e,e}_updateBatchesForRenderable(t,e){const r=t.context,i=this.renderer.graphicsContext.getGpuContext(r),n=this.renderer._roundPixels|t._roundPixels;e.batches=i.batches.map(e=>{const r=o.Z.get(l.G);return e.copyTo(r),r.renderable=t,r.roundPixels=n,r})}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null}}u.extension={type:[i.Ag.WebGLPipes,i.Ag.WebGPUPipes,i.Ag.CanvasPipes],name:"graphics"},i.XO.add(u),i.XO.add(n.GH)},9113:(t,e,r)=>{"use strict";r.d(e,{M:()=>d});var i=r(7952),n=r(3804);let s;function o(){if(!s){s="mediump";const t=(0,n.W)();if(t&&t.getShaderPrecisionFormat){const e=t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT);s=e.precision?"highp":"mediump"}}return s}const a={},l={},h={stripVersion:function(t,e){return e?t.replace("#version 300 es",""):t},ensurePrecision:function(t,e,r){const i=r?e.maxSupportedFragmentPrecision:e.maxSupportedVertexPrecision;if("precision"!==t.substring(0,9)){let n=r?e.requestedFragmentPrecision:e.requestedVertexPrecision;return"highp"===n&&"highp"!==i&&(n="mediump"),`precision ${n} float;\n${t}`}return"highp"!==i&&"precision highp"===t.substring(0,15)?t.replace("precision highp","precision mediump"):t},addProgramDefines:function(t,e,r){return e?t:r?`\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${t=t.replace("out vec4 finalColor;","")}\n        `:`\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${t}\n        `},setProgramName:function(t,{name:e="pixi-program"},r=!0){e=e.replace(/\s+/g,"-");const i=r?a:l;return i[e+=r?"-fragment":"-vertex"]?(i[e]++,e+=`-${i[e]}`):i[e]=1,-1!==t.indexOf("#define SHADER_NAME")?t:`#define SHADER_NAME ${e}\n${t}`},insertVersion:function(t,e){return e?`#version 300 es\n${t}`:t}},u=Object.create(null),c=class t{constructor(e){const r=-1!==(e={...t.defaultOptions,...e}).fragment.indexOf("#version 300 es"),n={stripVersion:r,ensurePrecision:{requestedFragmentPrecision:e.preferredFragmentPrecision,requestedVertexPrecision:e.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:o()},setProgramName:{name:e.name},addProgramDefines:r,insertVersion:r};let s=e.fragment,a=e.vertex;Object.keys(h).forEach(t=>{const e=n[t];s=h[t](s,e,!0),a=h[t](a,e,!1)}),this.fragment=s,this.vertex=a,this.transformFeedbackVaryings=e.transformFeedbackVaryings,this._key=(0,i.X)(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null,u[this._cacheKey]=null}static from(e){const r=`${e.vertex}:${e.fragment}`;return u[r]||(u[r]=new t(e),u[r]._cacheKey=r),u[r]}};c.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let d=c},9305:(t,e,r)=>{"use strict";var i=r(8507);class n{execute(t,e){const r=t.state,i=t.renderer,n=e.shader||t.defaultShader;n.resources.uTexture=e.texture._source,n.resources.uniforms=t.localUniforms;const s=i.gl,o=t.getBuffers(e);i.shader.bind(n),i.state.set(r),i.geometry.bind(o.geometry,n.glProgram);const a=2===o.geometry.indexBuffer.data.BYTES_PER_ELEMENT?s.UNSIGNED_SHORT:s.UNSIGNED_INT;s.drawElements(s.TRIANGLES,6*e.particleChildren.length,a,0)}}var s=r(9313),o=r(5811),a=r(2331),l=r(7547),h=r(2760),u=r(949),c=r(1132),d=r(6011),f=r(8306),p=r(1460);function g(t,e=null){const r=6*t;if(r>65535?e||(e=new Uint32Array(r)):e||(e=new Uint16Array(r)),e.length!==r)throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${r}`);for(let t=0,i=0;t<r;t+=6,i+=4)e[t+0]=i+0,e[t+1]=i+1,e[t+2]=i+2,e[t+3]=i+0,e[t+4]=i+2,e[t+5]=i+3;return e}function x(t,e){const r=[];r.push("\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            ");let i=0;for(const n in t){const s=t[n];e===s.dynamic&&(r.push(`offset = index + ${i}`),r.push(s.code),i+=(0,f.m)(s.format).stride/4)}r.push("\n            index += stride * 4;\n        }\n    "),r.unshift(`\n        var stride = ${i};\n    `);const n=r.join("\n");return new Function("ps","f32v","u32v",n)}class m{constructor(t){this._size=0,this._generateParticleUpdateCache={};const e=this._size=t.size??1e3,r=t.properties;let i=0,n=0;for(const t in r){const e=r[t],s=(0,f.m)(e.format);e.dynamic?n+=s.stride:i+=s.stride}this._dynamicStride=n/4,this._staticStride=i/4,this.staticAttributeBuffer=new p.u(4*e*i),this.dynamicAttributeBuffer=new p.u(4*e*n),this.indexBuffer=g(e);const s=new d.V;let o=0,a=0;this._staticBuffer=new u.h({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:c.S.VERTEX|c.S.COPY_DST}),this._dynamicBuffer=new u.h({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:c.S.VERTEX|c.S.COPY_DST});for(const t in r){const e=r[t],i=(0,f.m)(e.format);e.dynamic?(s.addAttribute(e.attributeName,{buffer:this._dynamicBuffer,stride:4*this._dynamicStride,offset:4*o,format:e.format}),o+=i.size):(s.addAttribute(e.attributeName,{buffer:this._staticBuffer,stride:4*this._staticStride,offset:4*a,format:e.format}),a+=i.size)}s.addIndex(this.indexBuffer);const l=this.getParticleUpdate(r);this._dynamicUpload=l.dynamicUpdate,this._staticUpload=l.staticUpdate,this.geometry=s}getParticleUpdate(t){const e=function(t){const e=[];for(const r in t){const i=t[r];e.push(r,i.code,i.dynamic?"d":"s")}return e.join("_")}(t);return this._generateParticleUpdateCache[e]||(this._generateParticleUpdateCache[e]=this.generateParticleUpdate(t)),this._generateParticleUpdateCache[e]}generateParticleUpdate(t){return function(t){return{dynamicUpdate:x(t,!0),staticUpdate:x(t,!1)}}(t)}update(t,e){t.length>this._size&&(e=!0,this._size=Math.max(t.length,1.5*this._size|0),this.staticAttributeBuffer=new p.u(this._size*this._staticStride*4*4),this.dynamicAttributeBuffer=new p.u(this._size*this._dynamicStride*4*4),this.indexBuffer=g(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const r=this.dynamicAttributeBuffer;if(this._dynamicUpload(t,r.float32View,r.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,t.length*this._dynamicStride*4,!0),e){const e=this.staticAttributeBuffer;this._staticUpload(t,e.float32View,e.uint32View),this._staticBuffer.setDataWithSize(e.float32View,t.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}var y=r(2577),_=r(9113),b=r(3012),v=r(8475),S=r(7174),w=r(218),T="\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";class P extends v.M{constructor(){super({glProgram:_.M.from({vertex:"attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n",fragment:"varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}"}),gpuProgram:b.B.from({fragment:{source:T,entryPoint:"mainFragment"},vertex:{source:T,entryPoint:"mainVertex"}}),resources:{uTexture:S.g.WHITE.source,uSampler:new w.n({}),uniforms:{uTranslationMatrix:{value:new s.u,type:"mat3x3<f32>"},uColor:{value:new y.Q(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class C{constructor(t,e){this.state=l.U.for2d(),this.localUniforms=new o.k({uTranslationMatrix:{value:new s.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=t,this.adaptor=e,this.defaultShader=new P,this.state=l.U.for2d()}validateRenderable(t){return!1}addRenderable(t,e){this.renderer.renderPipes.batch.break(e),e.add(t)}getBuffers(t){return t._gpuData[this.renderer.uid]||this._initBuffer(t)}_initBuffer(t){return t._gpuData[this.renderer.uid]=new m({size:t.particleChildren.length,properties:t._properties}),t._gpuData[this.renderer.uid]}updateRenderable(t){}execute(t){const e=t.particleChildren;if(0===e.length)return;const r=this.renderer,i=this.getBuffers(t);t.texture||(t.texture=e[0].texture);const n=this.state;i.update(e,t._childrenDirty),t._childrenDirty=!1,n.blendMode=(0,a.i)(t.blendMode,t.texture._source);const s=this.localUniforms.uniforms,o=s.uTranslationMatrix;t.worldTransform.copyTo(o),o.prepend(r.globalUniforms.globalUniformData.projectionMatrix),s.uResolution=r.globalUniforms.globalUniformData.resolution,s.uRound=r._roundPixels|t._roundPixels,(0,h.V)(t.groupColorAlpha,s.uColor,0),this.adaptor.execute(this,t)}destroy(){this.renderer=null,this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class M extends C{constructor(t){super(t,new n)}}M.extension={type:[i.Ag.WebGLPipes],name:"particle"};class k{execute(t,e){const r=t.renderer,i=e.shader||t.defaultShader;i.groups[0]=r.renderPipes.uniformBatch.getUniformBindGroup(t.localUniforms,!0),i.groups[1]=r.texture.getTextureBindGroup(e.texture);const n=t.state,s=t.getBuffers(e);r.encoder.draw({geometry:s.geometry,shader:e.shader||t.defaultShader,state:n,size:6*e.particleChildren.length})}}class A extends C{constructor(t){super(t,new k)}}A.extension={type:[i.Ag.WebGPUPipes],name:"particle"},i.XO.add(M),i.XO.add(A)}}]);
//# sourceMappingURL=735Bundle.js.map