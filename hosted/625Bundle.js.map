{"version":3,"file":"625Bundle.js","mappings":"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","sources":["webpack://Project2/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs","webpack://Project2/./node_modules/pixi.js/lib/utils/browser/isSafari.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-html/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/FilterPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/FilterSystem.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/app/ResizePlugin.mjs","webpack://Project2/./node_modules/pixi.js/lib/app/TickerPlugin.mjs","webpack://Project2/./node_modules/pixi.js/lib/app/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/text/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/mesh/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/filters/Filter.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/graphics/init.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs","webpack://Project2/./node_modules/pixi.js/lib/scene/particle-container/init.mjs"],"sourcesContent":["\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds.mjs';\n\n\"use strict\";\nfunction updateTextBounds(batchableSprite, text) {\n  const { texture, bounds } = batchableSprite;\n  const padding = text._style._getFinalPadding();\n  updateQuadBounds(bounds, text._anchor, texture);\n  const paddingOffset = text._anchor._x * padding * 2;\n  const paddingOffsetY = text._anchor._y * padding * 2;\n  bounds.minX -= padding - paddingOffset;\n  bounds.minY -= padding - paddingOffsetY;\n  bounds.maxX -= padding - paddingOffset;\n  bounds.maxY -= padding - paddingOffsetY;\n}\n\nexport { updateTextBounds };\n//# sourceMappingURL=updateTextBounds.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\nexport { getPo2TextureFromSource };\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n","import { BatchableSprite } from '../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableHTMLText extends BatchableSprite {\n  /**\n   * Creates an instance of BatchableHTMLText.\n   * @param renderer - The renderer instance to be used.\n   */\n  constructor(renderer) {\n    super();\n    this.generatingTexture = false;\n    this.currentKey = \"--\";\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n  destroy() {\n    const { htmlText } = this._renderer;\n    htmlText.getReferenceCount(this.currentKey) === null ? htmlText.returnTexturePromise(this.texturePromise) : htmlText.decreaseReferenceCount(this.currentKey);\n    this._renderer.runners.resolutionChange.remove(this);\n    this.texturePromise = null;\n    this._renderer = null;\n  }\n}\n\nexport { BatchableHTMLText };\n//# sourceMappingURL=BatchableHTMLText.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateTextBounds } from '../text/utils/updateTextBounds.mjs';\nimport { BatchableHTMLText } from './BatchableHTMLText.mjs';\n\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText.styleKey;\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText, instructionSet) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (htmlText._didTextUpdate) {\n      const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n      if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution) {\n        this._updateGpuText(htmlText).catch((e) => {\n          console.error(e);\n        });\n      }\n      htmlText._didTextUpdate = false;\n      updateTextBounds(batchableHTMLText, htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n  }\n  updateRenderable(htmlText) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    batchableHTMLText._batcher.updateElement(batchableHTMLText);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (batchableHTMLText.generatingTexture)\n      return;\n    const oldTexturePromise = batchableHTMLText.texturePromise;\n    batchableHTMLText.texturePromise = null;\n    batchableHTMLText.generatingTexture = true;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n    if (oldTexturePromise) {\n      texturePromise = texturePromise.finally(() => {\n        this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n        this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n      });\n    }\n    batchableHTMLText.texturePromise = texturePromise;\n    batchableHTMLText.currentKey = htmlText.styleKey;\n    batchableHTMLText.texture = await texturePromise;\n    const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    batchableHTMLText.generatingTexture = false;\n    updateTextBounds(batchableHTMLText, htmlText);\n  }\n  _getGpuText(htmlText) {\n    return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const batchableHTMLText = new BatchableHTMLText(this._renderer);\n    batchableHTMLText.renderable = htmlText;\n    batchableHTMLText.transform = htmlText.groupTransform;\n    batchableHTMLText.texture = Texture.EMPTY;\n    batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n    return batchableHTMLText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextPipe };\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nconst nssvg = \"http://www.w3.org/2000/svg\";\nconst nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, \"svg\");\n    this.foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    this.domElement = document.createElementNS(nsxhtml, \"div\");\n    this.styleElement = document.createElementNS(nsxhtml, \"style\");\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n    this.image = DOMAdapter.get().createImage();\n  }\n  destroy() {\n    this.svgRoot.remove();\n    this.foreignObject.remove();\n    this.styleElement.remove();\n    this.domElement.remove();\n    this.image.src = \"\";\n    this.image.remove();\n    this.svgRoot = null;\n    this.foreignObject = null;\n    this.styleElement = null;\n    this.domElement = null;\n    this.image = null;\n    this.canvasAndContext = null;\n  }\n}\n\nexport { HTMLTextRenderData };\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n","import { Cache } from '../../../assets/cache/Cache.mjs';\nimport { loadFontCSS } from './loadFontCSS.mjs';\n\n\"use strict\";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { entries } = Cache.get(`${fontFamily}-and-url`);\n      const promises = [];\n      entries.forEach((entry) => {\n        const url = entry.url;\n        const faces = entry.faces;\n        const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n        promises.push(\n          ...out.map(\n            (style) => loadFontCSS(\n              {\n                fontWeight: style.weight,\n                fontStyle: style.style,\n                fontFamily\n              },\n              url\n            )\n          )\n        );\n      });\n      FontStylePromiseCache.set(\n        fontFamily,\n        Promise.all(promises).then((css) => css.join(\"\\n\"))\n      );\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\nexport { FontStylePromiseCache, getFontCss };\n//# sourceMappingURL=getFontCss.mjs.map\n","import { HTMLTextRenderData } from '../HTMLTextRenderData.mjs';\n\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const doublePadding = style.padding * 2;\n  return {\n    width: contentBounds.width - doublePadding,\n    height: contentBounds.height - doublePadding\n  };\n}\n\nexport { measureHtmlText };\n//# sourceMappingURL=measureHtmlText.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { isSafari } from '../../utils/browser/isSafari.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource.mjs';\nimport { HTMLTextRenderData } from './HTMLTextRenderData.mjs';\nimport { extractFontFamilies } from './utils/extractFontFamilies.mjs';\nimport { getFontCss } from './utils/getFontCss.mjs';\nimport { getSVGUrl } from './utils/getSVGUrl.mjs';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage.mjs';\nimport { loadSVGImage } from './utils/loadSVGImage.mjs';\nimport { measureHtmlText } from './utils/measureHtmlText.mjs';\n\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === RendererType.WEBGPU;\n  }\n  /**\n   * @param options\n   * @deprecated Use getTexturePromise instead\n   */\n  getTexture(options) {\n    return this.getTexturePromise(options);\n  }\n  /**\n   * Increases the reference count for a texture.\n   * @param text - The HTMLText instance associated with the texture.\n   */\n  getManagedTexture(text) {\n    const textKey = text.styleKey;\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  /**\n   * Gets the current reference count for a texture associated with a text key.\n   * @param textKey - The unique key identifying the text style configuration\n   * @returns The number of Text instances currently using this texture\n   */\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey]?.usageCount ?? null;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  /**\n   * Decreases the reference count for a texture.\n   * If the count reaches zero, the texture is cleaned up.\n   * @param textKey - The key associated with the HTMLText instance.\n   */\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture.texture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture.texture);\n        }).catch(() => {\n          warn(\"HTMLTextSystem: Failed to clean texture\");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  /**\n   * Returns a promise that resolves to a texture for the given HTMLText options.\n   * @param options - The options for the HTMLText.\n   * @returns A promise that resolves to a Texture.\n   */\n  getTexturePromise(options) {\n    return this._buildTexturePromise(options);\n  }\n  async _buildTexturePromise(options) {\n    const { text, style, resolution, textureStyle } = options;\n    const htmlTextData = BigPool.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(fontFamilies);\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    const uvSafeOffset = 2;\n    image.width = (width | 0) + uvSafeOffset;\n    image.height = (height | 0) + uvSafeOffset;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    const resource = image;\n    let canvasAndContext;\n    if (this._createCanvas) {\n      canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource(\n      canvasAndContext ? canvasAndContext.canvas : resource,\n      image.width - uvSafeOffset,\n      image.height - uvSafeOffset,\n      resolution\n    );\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n    BigPool.return(htmlTextData);\n    return texture;\n  }\n  returnTexturePromise(texturePromise) {\n    texturePromise.then((texture) => {\n      this._cleanUp(texture);\n    }).catch(() => {\n      warn(\"HTMLTextSystem: Failed to clean texture\");\n    });\n  }\n  _cleanUp(texture) {\n    TexturePool.returnTexture(texture, true);\n    texture.source.resource = null;\n    texture.source.uploadMethodId = \"unknown\";\n  }\n  destroy() {\n    this._renderer = null;\n    for (const key in this._activeTextures) {\n      if (this._activeTextures[key])\n        this.returnTexturePromise(this._activeTextures[key].promise);\n    }\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextSystem };\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n","\"use strict\";\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;\"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(\":\")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\nexport { extractFontFamilies };\n//# sourceMappingURL=extractFontFamilies.mjs.map\n","import { loadFontAsBase64 } from './loadFontAsBase64.mjs';\n\n\"use strict\";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n\nexport { loadFontCSS };\n//# sourceMappingURL=loadFontCSS.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\n\n\"use strict\";\nasync function loadFontAsBase64(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\nexport { loadFontAsBase64 };\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n","\"use strict\";\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n  domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute(\"width\", width.toString());\n  svgRoot.setAttribute(\"height\", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\nexport { getSVGUrl };\n//# sourceMappingURL=getSVGUrl.mjs.map\n","\"use strict\";\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = \"anonymous\";\n  });\n}\n\nexport { loadSVGImage };\n//# sourceMappingURL=loadSVGImage.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nfunction isSafari() {\n  const { userAgent } = DOMAdapter.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\nexport { isSafari };\n//# sourceMappingURL=isSafari.mjs.map\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\n\n\"use strict\";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  return canvasAndContext;\n}\n\nexport { getTemporaryCanvasFromImage };\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { HTMLTextPipe } from './HTMLTextPipe.mjs';\nimport { HTMLTextSystem } from './HTMLTextSystem.mjs';\n\n\"use strict\";\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize: vec4<f32>,\\n  uInputPixel: vec4<f32>,\\n  uInputClamp: vec4<f32>,\\n  uOutputFrame: vec4<f32>,\\n  uGlobalFrame: vec4<f32>,\\n  uOutputTexture: vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv: vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition: vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n    return textureSample(uTexture, uSampler, uv);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=passthrough.wgsl.mjs.map\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport vertex from '../defaultFilter.vert.mjs';\nimport fragment from './passthrough.frag.mjs';\nimport source from './passthrough.wgsl.mjs';\n\n\"use strict\";\nclass PassthroughFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: { source, entryPoint: \"mainVertex\" },\n      fragment: { source, entryPoint: \"mainFragment\" },\n      name: \"passthrough-filter\"\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"passthrough-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram\n    });\n  }\n}\n\nexport { PassthroughFilter };\n//# sourceMappingURL=PassthroughFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\nuniform sampler2D uTexture;\\nvoid main() {\\n    finalColor = texture(uTexture, vTextureCoord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=passthrough.frag.mjs.map\n","import '../../../maths/index.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempProjectionMatrix = new Matrix();\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const actualMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n    if (renderGroup?.isCachedAsTexture) {\n      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);\n    } else if (renderGroup?._parentCacheAsTextureRenderGroup) {\n      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);\n    } else {\n      bounds.matrix = renderable.worldTransform;\n    }\n    bounds.addBounds(renderable.bounds);\n  }\n  bounds.matrix = actualMatrix;\n  return bounds;\n}\n\nexport { getGlobalRenderableBounds };\n//# sourceMappingURL=getRenderableBounds.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { PassthroughFilter } from './defaults/passthrough/PassthroughFilter.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterData {\n  constructor() {\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    this.skip = false;\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    this.inputTexture = null;\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    this.backTexture = null;\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    this.filters = null;\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    this.bounds = new Bounds();\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    this.container = null;\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    this.blendRequired = false;\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    this.outputRenderSurface = null;\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n    /** The first enabled filter index in the current filter list. */\n    this.firstEnabledIndex = -1;\n    /** The last enabled filter index in the current filter list. */\n    this.lastEnabledIndex = -1;\n  }\n}\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    const filterData = this._pushFilterData();\n    filterData.skip = false;\n    filterData.filters = filters;\n    filterData.container = instruction.container;\n    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    this._calculateFilterArea(instruction, bounds);\n    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n    if (filterData.skip) {\n      return;\n    }\n    const previousFilterData = this._getPreviousFilterData();\n    const globalResolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (previousFilterData) {\n      offsetX = previousFilterData.bounds.minX;\n      offsetY = previousFilterData.bounds.minY;\n    }\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n  }\n  /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */\n  generateFilteredTexture({ texture, filters }) {\n    const filterData = this._pushFilterData();\n    this._activeFilterData = filterData;\n    filterData.skip = false;\n    filterData.filters = filters;\n    const colorTextureSource = texture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return texture;\n    }\n    const bounds = filterData.bounds;\n    bounds.addRect(texture.frame);\n    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n    if (filterData.skip) {\n      return texture;\n    }\n    const globalResolution = rootResolution;\n    const offsetX = 0;\n    const offsetY = 0;\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = texture;\n    const renderer = this.renderer;\n    renderer.renderTarget.finishRenderPass();\n    this._applyFiltersToTexture(filterData, true);\n    const outputTexture = filterData.outputRenderSurface;\n    outputTexture.source.alphaMode = \"premultiplied-alpha\";\n    return outputTexture;\n  }\n  /** @internal */\n  pop() {\n    const renderer = this.renderer;\n    const filterData = this._popFilterData();\n    if (filterData.skip) {\n      return;\n    }\n    renderer.globalUniforms.pop();\n    renderer.renderTarget.finishRenderPass();\n    this._activeFilterData = filterData;\n    this._applyFiltersToTexture(filterData, false);\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(filterData.backTexture);\n    }\n    TexturePool.returnTexture(filterData.inputTexture);\n  }\n  /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._activeFilterData;\n    const outputRenderSurface = filterData.outputRenderSurface;\n    const isFinalTarget = outputRenderSurface === output;\n    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    const resolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (isFinalTarget) {\n      const offset = this._findPreviousFilterOffset();\n      offsetX = offset.x;\n      offsetY = offset.y;\n    }\n    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n    const filterToApply = filter.enabled ? filter : this._getPassthroughFilter();\n    this._setupBindGroupsAndRender(filterToApply, input, renderer);\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.orig.width,\n      1 / sprite.texture.orig.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n    this._passthroughFilter?.destroy(true);\n    this._passthroughFilter = null;\n  }\n  _getPassthroughFilter() {\n    this._passthroughFilter ?? (this._passthroughFilter = new PassthroughFilter());\n    return this._passthroughFilter;\n  }\n  /**\n   * Sets up the bind groups and renders the filter.\n   * @param filter - The filter to apply\n   * @param input - The input texture\n   * @param renderer - The renderer instance\n   */\n  _setupBindGroupsAndRender(filter, input, renderer) {\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  /**\n   * Sets up the filter textures including input texture and back texture if needed.\n   * @param filterData - The filter data to update\n   * @param bounds - The bounds for the texture\n   * @param renderer - The renderer instance\n   * @param previousFilterData - The previous filter data for back texture calculation\n   */\n  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    if (filterData.blendRequired) {\n      renderer.renderTarget.finishRenderPass();\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n    }\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  /**\n   * Calculates and sets the global frame for the filter.\n   * @param filterData - The filter data to update\n   * @param offsetX - The X offset\n   * @param offsetY - The Y offset\n   * @param globalResolution - The global resolution\n   * @param sourceWidth - The source texture width\n   * @param sourceHeight - The source texture height\n   */\n  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = sourceWidth * globalResolution;\n    globalFrame.height = sourceHeight * globalResolution;\n  }\n  /**\n   * Updates the filter uniforms with the current filter state.\n   * @param input - The input texture\n   * @param output - The output render surface\n   * @param filterData - The current filter data\n   * @param offsetX - The X offset for positioning\n   * @param offsetY - The Y offset for positioning\n   * @param resolution - The current resolution\n   * @param isFinalTarget - Whether this is the final render target\n   * @param clear - Whether to clear the output surface\n   */\n  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {\n    const uniforms = this._filterGlobalUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      outputFrame[0] = filterData.bounds.minX - offsetX;\n      outputFrame[1] = filterData.bounds.minY - offsetY;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offsetX * resolution;\n    globalFrame[1] = offsetY * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    if (output instanceof Texture)\n      output.source.resource = null;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    this.renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    this._filterGlobalUniforms.update();\n  }\n  /**\n   * Finds the correct resolution by looking back through the filter stack.\n   * @param rootResolution - The fallback root resolution to use\n   * @returns The resolution from the previous filter or root resolution\n   */\n  _findFilterResolution(rootResolution) {\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;\n  }\n  /**\n   * Finds the offset from the previous non-skipped filter in the stack.\n   * @returns The offset coordinates from the previous filter\n   */\n  _findPreviousFilterOffset() {\n    let offsetX = 0;\n    let offsetY = 0;\n    let lastIndex = this._filterStackIndex;\n    while (lastIndex > 0) {\n      lastIndex--;\n      const prevFilterData = this._filterStack[lastIndex];\n      if (!prevFilterData.skip) {\n        offsetX = prevFilterData.bounds.minX;\n        offsetY = prevFilterData.bounds.minY;\n        break;\n      }\n    }\n    return { x: offsetX, y: offsetY };\n  }\n  /**\n   * Calculates the filter area bounds based on the instruction type.\n   * @param instruction - The filter instruction\n   * @param bounds - The bounds object to populate\n   */\n  _calculateFilterArea(instruction, bounds) {\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n  }\n  _applyFiltersToTexture(filterData, clear) {\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    const firstEnabled = filterData.firstEnabledIndex;\n    const lastEnabled = filterData.lastEnabledIndex;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n    if (firstEnabled === lastEnabled) {\n      filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n    } else {\n      let flip = filterData.inputTexture;\n      const tempTexture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let flop = tempTexture;\n      for (let i = firstEnabled; i < lastEnabled; i++) {\n        const filter = filters[i];\n        if (!filter.enabled)\n          continue;\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n    const renderer = this.renderer;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    let firstEnabledIndex = -1;\n    let lastEnabledIndex = -1;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      if (!filter.enabled)\n        continue;\n      if (firstEnabledIndex === -1)\n        firstEnabledIndex = i;\n      lastEnabledIndex = i;\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = rootAntialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = true;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.antialias = antialias;\n    filterData.resolution = resolution;\n    filterData.blendRequired = blendRequired;\n    filterData.firstEnabledIndex = firstEnabledIndex;\n    filterData.lastEnabledIndex = lastEnabledIndex;\n  }\n  _popFilterData() {\n    this._filterStackIndex--;\n    return this._filterStack[this._filterStackIndex];\n  }\n  _getPreviousFilterData() {\n    let previousFilterData;\n    let index = this._filterStackIndex - 1;\n    while (index > 0) {\n      index--;\n      previousFilterData = this._filterStack[index];\n      if (!previousFilterData.skip) {\n        break;\n      }\n    }\n    return previousFilterData;\n  }\n  _pushFilterData() {\n    let filterData = this._filterStack[this._filterStackIndex];\n    if (!filterData) {\n      filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n    }\n    this._filterStackIndex++;\n    return filterData;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/ViewContainer.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends ViewContainer {\n  /**\n   * Creates a new Graphics object.\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.didViewUpdate = true;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The underlying graphics context used for drawing operations.\n   * Controls how shapes and paths are rendered.\n   * @example\n   * ```ts\n   * // Create a shared context\n   * const sharedContext = new GraphicsContext();\n   *\n   * // Create graphics objects sharing the same context\n   * const graphics1 = new Graphics();\n   * const graphics2 = new Graphics();\n   *\n   * // Assign shared context\n   * graphics1.context = sharedContext;\n   * graphics2.context = sharedContext;\n   *\n   * // Both graphics will show the same shapes\n   * sharedContext\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @see {@link GraphicsContext} For drawing operations\n   * @see {@link GraphicsOptions} For context configuration\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphics object.\n   * Returns the boundaries after all graphical operations but before any transforms.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Get bounds information\n   * const bounds = graphics.bounds;\n   * console.log(bounds.width);  // 100\n   * console.log(bounds.height); // 100\n   * ```\n   * @readonly\n   * @see {@link Bounds} For bounds operations\n   * @see {@link Container#getBounds} For transformed bounds\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */\n  updateBounds() {\n  }\n  /**\n   * Checks if the object contains the given point.\n   * Returns true if the point lies within the Graphics object's rendered area.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Check point intersection\n   * if (graphics.containsPoint({ x: 50, y: 50 })) {\n   *     console.log('Point is inside rectangle!');\n   * }\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is inside the Graphics object\n   * @see {@link Graphics#bounds} For bounding box checks\n   * @see {@link PointData} For point data structure\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @example\n   * ```ts\n   * // Destroy the graphics and its context\n   * graphics.destroy();\n   * graphics.destroy(true);\n   * graphics.destroy({ context: true, texture: true, textureSource: true });\n   * ```\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context.\n   * The fill style can be a color, gradient, pattern, or a complex style object.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics\n   *     .setFillStyle({ color: 0xff0000 }) // Red fill\n   *     .rect(0, 0, 100, 100)\n   *     .fill();\n   *\n   * // Gradient fill\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setFillStyle(gradient)\n   *     .circle(100, 100, 50)\n   *     .fill();\n   *\n   * // Pattern fill\n   * const pattern = new FillPattern(texture);\n   * graphics\n   *     .setFillStyle({\n   *         fill: pattern,\n   *         alpha: 0.5\n   *     })\n   *     .rect(0, 0, 200, 200)\n   *     .fill();\n   * ```\n   * @param {FillInput} args - The fill style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link FillStyle} For fill style options\n   * @see {@link FillGradient} For gradient fills\n   * @see {@link FillPattern} For pattern fills\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context.\n   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color stroke\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 2,\n   *         color: 0x000000\n   *     })\n   *     .rect(0, 0, 100, 100)\n   *     .stroke();\n   *\n   * // Complex stroke style\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 4,\n   *         color: 0xff0000,\n   *         alpha: 0.5,\n   *         join: 'round',\n   *         cap: 'round',\n   *         alignment: 0.5\n   *     })\n   *     .circle(100, 100, 50)\n   *     .stroke();\n   *\n   * // Gradient stroke\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 10,\n   *         fill: gradient\n   *     })\n   *     .poly([0,0, 100,50, 0,100])\n   *     .stroke();\n   * ```\n   * @param {StrokeInput} args - The stroke style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link FillPattern} For pattern strokes\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style or specified style.\n   * Outlines the shape using the stroke settings.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Stroke with direct color\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .stroke({\n   *         width: 2,\n   *         color: 0xff0000\n   *     }); // 2px red stroke\n   *\n   * // Fill with texture\n   * graphics\n   *    .rect(0, 0, 100, 100)\n   *    .stroke(myTexture); // Fill with texture\n   *\n   * // Stroke with gradient\n   * const gradient = new FillGradient({\n   *     end: { x: 1, y: 0 },\n   *     colorStops: [\n   *         { offset: 0, color: 0xff0000 },\n   *         { offset: 0.5, color: 0x00ff00 },\n   *         { offset: 1, color: 0x0000ff },\n   *     ],\n   * });\n   *\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .stroke({\n   *         width: 4,\n   *         fill: gradient,\n   *         alignment: 0.5,\n   *         join: 'round'\n   *     });\n   * ```\n   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n   * - A stroke style object with width, color, etc.\n   * - A gradient\n   * - A pattern\n   * If omitted, uses current stroke style.\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link setStrokeStyle} For setting default stroke style\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   * graphics\n   *     .circle(150, 150, 50)\n   *     .fill({ color: 0x00ff00 })\n   *     .beginPath() // Starts a new path\n   *     .circle(250, 150, 50)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for chaining\n   * @see {@link Graphics#moveTo} For starting a new subpath\n   * @see {@link Graphics#closePath} For closing the current path\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path.\n   *\n   * If a hole is not completely in a shape, it will fail to cut correctly.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw outer circle\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *     .circle(100, 100, 25) // Inner circle\n   *     .cut() // Cuts out the inner circle from the outer circle\n   * ```\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start point.\n   *\n   * This is useful for completing shapes and ensuring they are properly closed for fills.\n   * @example\n   * ```ts\n   * // Create a triangle with closed path\n   * const graphics = new Graphics();\n   * graphics\n   *     .moveTo(50, 50)\n   *     .lineTo(100, 100)\n   *     .lineTo(0, 100)\n   *     .closePath()\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path\n   * @see {@link Graphics#fill} For filling closed paths\n   * @see {@link Graphics#stroke} For stroking paths\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /**\n   * Saves the current graphics state onto a stack. The state includes:\n   * - Current transformation matrix\n   * - Current fill style\n   * - Current stroke style\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Save state before complex operations\n   * graphics.save();\n   *\n   * // Create transformed and styled shape\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4)\n   *     .setFillStyle({\n   *         color: 0xff0000,\n   *         alpha: 0.5\n   *     })\n   *     .rect(-25, -25, 50, 50)\n   *     .fill();\n   *\n   * // Restore to original state\n   * graphics.restore();\n   *\n   * // Continue drawing with previous state\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .fill();\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#restore} For restoring the saved state\n   * @see {@link Graphics#setTransform} For setting transformations\n   */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * This matrix represents all accumulated transformations including translate, scale, and rotate.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply some transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4);\n   *\n   * // Get the current transform matrix\n   * const matrix = graphics.getTransform();\n   * console.log(matrix.tx, matrix.ty); // 100, 100\n   *\n   * // Use the matrix for other operations\n   * graphics\n   *     .setTransform(matrix)\n   *     .circle(0, 0, 50)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @returns The current transformation matrix.\n   * @see {@link Graphics#setTransform} For setting the transform matrix\n   * @see {@link Matrix} For matrix operations\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .scaleTransform(2, 2)\n   *     .circle(0, 0, 25)\n   *     .fill({ color: 0xff0000 });\n   * // Reset transform to default state\n   * graphics\n   *     .resetTransform()\n   *     .circle(50, 50, 25) // Will draw at actual coordinates\n   *     .fill({ color: 0x00ff00 });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#getTransform} For getting the current transform\n   * @see {@link Graphics#setTransform} For setting a specific transform\n   * @see {@link Graphics#save} For saving the current transform state\n   * @see {@link Graphics#restore} For restoring a previous transform state\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it.\n   * This includes clearing the current path, fill style, stroke style, and transformations.\n   *\n   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n   * > Instead, they are intended to be used for static or semi-static graphics that\n   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw some shapes\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 })\n   *     .rect(200, 100, 100, 50)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Clear all graphics\n   * graphics.clear();\n   *\n   * // Start fresh with new shapes\n   * graphics\n   *     .circle(150, 150, 30)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n   * @see {@link Graphics#save} For saving the current state\n   * @see {@link Graphics#restore} For restoring a previous state\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * Gets or sets the current fill style for the graphics context. The fill style determines\n   * how shapes are filled when using the fill() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics.fillStyle = {\n   *     color: 0xff0000,  // Red\n   *     alpha: 1\n   * };\n   *\n   * // Using gradients\n   * const gradient = new FillGradient({\n   *     end: { x: 0, y: 1 }, // Vertical gradient\n   *     stops: [\n   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n   *     ]\n   * });\n   *\n   * graphics.fillStyle = {\n   *     fill: gradient,\n   *     alpha: 0.8\n   * };\n   *\n   * // Using patterns\n   * graphics.fillStyle = {\n   *     texture: myTexture,\n   *     alpha: 1,\n   *     matrix: new Matrix()\n   *         .scale(0.5, 0.5)\n   *         .rotate(Math.PI / 4)\n   * };\n   * ```\n   * @type {ConvertedFillStyle}\n   * @see {@link FillStyle} For all available fill style options\n   * @see {@link FillGradient} For creating gradient fills\n   * @see {@link Graphics#fill} For applying the fill to paths\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * Gets or sets the current stroke style for the graphics context. The stroke style determines\n   * how paths are outlined when using the stroke() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic stroke style\n   * graphics.strokeStyle = {\n   *     width: 2,\n   *     color: 0xff0000,\n   *     alpha: 1\n   * };\n   *\n   * // Using with gradients\n   * const gradient = new FillGradient({\n   *   end: { x: 0, y: 1 },\n   *   stops: [\n   *       { offset: 0, color: 0xff0000, alpha: 1 },\n   *       { offset: 1, color: 0x0000ff, alpha: 1 }\n   *   ]\n   * });\n   *\n   * graphics.strokeStyle = {\n   *     width: 4,\n   *     fill: gradient,\n   *     alignment: 0.5,\n   *     join: 'round',\n   *     cap: 'round'\n   * };\n   *\n   * // Complex stroke settings\n   * graphics.strokeStyle = {\n   *     width: 6,\n   *     color: 0x00ff00,\n   *     alpha: 0.5,\n   *     join: 'miter',\n   *     miterLimit: 10,\n   * };\n   * ```\n   * @see {@link StrokeStyle} For all available stroke style options\n   * @see {@link Graphics#stroke} For applying the stroke to paths\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object that copies the current graphics content.\n   * The clone can either share the same context (shallow clone) or have its own independent\n   * context (deep clone).\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Create original graphics content\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Create a shallow clone (shared context)\n   * const shallowClone = graphics.clone();\n   *\n   * // Changes to original affect the clone\n   * graphics\n   *     .circle(200, 100, 30)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Create a deep clone (independent context)\n   * const deepClone = graphics.clone(true);\n   *\n   * // Modify deep clone independently\n   * deepClone\n   *     .translateTransform(100, 100)\n   *     .circle(0, 0, 40)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @param deep - Whether to create a deep clone of the graphics object.\n   *              If false (default), the context will be shared between objects.\n   *              If true, creates an independent copy of the context.\n   * @returns A new Graphics instance with either shared or copied context\n   * @see {@link Graphics#context} For accessing the underlying graphics context\n   * @see {@link GraphicsContext} For understanding the shared context behavior\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    if (color !== void 0)\n      fillStyle.color = color;\n    if (alpha !== void 0)\n      fillStyle.alpha = alpha;\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","\"use strict\";\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n    )\n  }\n};\n\nexport { localUniformMSDFBit, localUniformMSDFBitGl };\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n","\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `\n    )\n  }\n};\n\nexport { mSDFBit, mSDFBitGl };\n//# sourceMappingURL=mSDFBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit.mjs';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass SdfShader extends Shader {\n  constructor(maxTextures) {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uDistance: { value: 4, type: \"f32\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexport { SdfShader };\n//# sourceMappingURL=SdfShader.mjs.map\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Graphics } from '../graphics/shared/Graphics.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { SdfShader } from '../text/sdfShader/SdfShader.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\n\n\"use strict\";\nclass BitmapTextGraphics extends Graphics {\n  destroy() {\n    if (this.context.customShader) {\n      this.context.customShader.destroy();\n    }\n    super.destroy();\n  }\n}\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n      }\n    }\n    const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    let tx = bitmapTextLayout.width;\n    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n    if (style._stroke) {\n      tx += style._stroke.width / scale;\n      ty += style._stroke.width / scale;\n    }\n    context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);\n    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;\n    let fontSize = bitmapFont.fontMetrics.fontSize;\n    let lineHeight = bitmapFont.lineHeight;\n    if (style.lineHeight) {\n      fontSize = style.fontSize / scale;\n      lineHeight = style.lineHeight / scale;\n    }\n    let linePositionYShift = (lineHeight - fontSize) / 2;\n    if (linePositionYShift - bitmapFont.baseLineOffset < 0) {\n      linePositionYShift = 0;\n    }\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = line.chars[j];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          const texture = charData.texture;\n          context.texture(\n            texture,\n            tint ? tint : \"black\",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset + linePositionYShift),\n            texture.orig.width,\n            texture.orig.height\n          );\n        }\n      }\n      currentY += lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = new BitmapTextGraphics();\n    bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    return proxyRenderable;\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\nexport { BitmapTextGraphics, BitmapTextPipe };\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { BitmapTextPipe } from './BitmapTextPipe.mjs';\n\n\"use strict\";\nextensions.add(BitmapTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        configurable: true,\n        set(dom) {\n          globalThis.removeEventListener(\"resize\", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener(\"resize\", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = ExtensionType.Application;\n\nexport { ResizePlugin };\n//# sourceMappingURL=ResizePlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        configurable: true,\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = ExtensionType.Application;\n\nexport { TickerPlugin };\n//# sourceMappingURL=TickerPlugin.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { ResizePlugin } from './ResizePlugin.mjs';\nimport { TickerPlugin } from './TickerPlugin.mjs';\n\n\"use strict\";\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation(v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    let uvs = options.uvs;\n    if (!uvs) {\n      if (options.positions) {\n        uvs = new Float32Array(positions.length);\n      } else {\n        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      }\n    }\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  /**\n   * Set the positions of the mesh.\n   * When setting the positions, its important that the uvs array is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The positions of the mesh.\n   */\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  /**\n   * Set the UVs of the mesh.\n   * Its important that the uvs array you set is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The UVs of the mesh.\n   */\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexport { MeshGeometry };\n//# sourceMappingURL=MeshGeometry.mjs.map\n","import { BatchableSprite } from '../../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableText extends BatchableSprite {\n  constructor(renderer) {\n    super();\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  destroy() {\n    const { canvasText } = this._renderer;\n    const refCount = canvasText.getReferenceCount(this.currentKey);\n    if (refCount > 0) {\n      canvasText.decreaseReferenceCount(this.currentKey);\n    } else if (this.texture) {\n      canvasText.returnTexture(this.texture);\n    }\n    this._renderer.runners.resolutionChange.remove(this);\n    this._renderer = null;\n  }\n}\n\nexport { BatchableText };\n//# sourceMappingURL=BatchableText.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { updateTextBounds } from '../utils/updateTextBounds.mjs';\nimport { BatchableText } from './BatchableText.mjs';\n\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text.styleKey;\n    if (gpuText.currentKey !== newKey)\n      return true;\n    return text._didTextUpdate;\n  }\n  addRenderable(text, instructionSet) {\n    const batchableText = this._getGpuText(text);\n    if (text._didTextUpdate) {\n      const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n      if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution) {\n        this._updateGpuText(text);\n      }\n      text._didTextUpdate = false;\n      updateTextBounds(batchableText, text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n  }\n  updateRenderable(text) {\n    const batchableText = this._getGpuText(text);\n    batchableText._batcher.updateElement(batchableText);\n  }\n  _updateGpuText(text) {\n    const batchableText = this._getGpuText(text);\n    if (batchableText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);\n    }\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    batchableText.texture = this._renderer.canvasText.getManagedTexture(text);\n    batchableText.currentKey = text.styleKey;\n  }\n  _getGpuText(text) {\n    return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const batchableText = new BatchableText(this._renderer);\n    batchableText.currentKey = \"--\";\n    batchableText.renderable = text;\n    batchableText.transform = text.groupTransform;\n    batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    text._gpuData[this._renderer.uid] = batchableText;\n    return batchableText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"text\"\n};\n\nexport { CanvasTextPipe };\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\nimport { nextPow2 } from '../../maths/misc/pow2.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nlet _internalCanvas = null;\nlet _internalContext = null;\nfunction ensureInternalCanvas(width, height) {\n  if (!_internalCanvas) {\n    _internalCanvas = DOMAdapter.get().createCanvas(256, 128);\n    _internalContext = _internalCanvas.getContext(\"2d\", { willReadFrequently: true });\n    _internalContext.globalCompositeOperation = \"copy\";\n    _internalContext.globalAlpha = 1;\n  }\n  if (_internalCanvas.width < width || _internalCanvas.height < height) {\n    _internalCanvas.width = nextPow2(width);\n    _internalCanvas.height = nextPow2(height);\n  }\n}\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(...args) {\n  let options = args[0];\n  if (!options.canvas) {\n    options = { canvas: args[0], resolution: args[1] };\n  }\n  const { canvas } = options;\n  const resolution = Math.min(options.resolution ?? 1, 1);\n  const width = options.width ?? canvas.width;\n  const height = options.height ?? canvas.height;\n  let output = options.output;\n  ensureInternalCanvas(width, height);\n  if (!_internalContext) {\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  }\n  _internalContext.drawImage(\n    canvas,\n    0,\n    0,\n    width,\n    height,\n    0,\n    0,\n    width * resolution,\n    height * resolution\n  );\n  const imageData = _internalContext.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  _internalContext.globalCompositeOperation = \"source-over\";\n  _internalContext.strokeRect(left, top, right - left, bottom - top);\n  _internalContext.globalCompositeOperation = \"copy\";\n  output ?? (output = new Rectangle());\n  output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n  return output;\n}\n\nexport { getCanvasBoundingBox };\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n","import { Color } from '../../../color/Color.mjs';\nimport { Rectangle } from '../../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox.mjs';\nimport { CanvasTextMetrics } from './CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nclass CanvasTextGeneratorClass {\n  /**\n   * Creates a canvas with the specified text rendered to it.\n   *\n   * Generates a canvas of appropriate size, renders the text with the provided style,\n   * and returns both the canvas/context and a Rectangle representing the text bounds.\n   *\n   * When trim is enabled in the style, the frame will represent the bounds of the\n   * non-transparent pixels, which can be smaller than the full canvas.\n   * @param options - The options for generating the text canvas\n   * @param options.text - The text to render\n   * @param options.style - The style to apply to the text\n   * @param options.resolution - The resolution of the canvas (defaults to 1)\n   * @param options.padding\n   * @returns An object containing the canvas/context and the frame (bounds) of the text\n   */\n  getCanvasAndContext(options) {\n    const { text, style, resolution = 1 } = options;\n    const padding = style._getFinalPadding();\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n    this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);\n    const frame = style.trim ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect }) : tempRect.set(0, 0, width, height);\n    return {\n      canvasAndContext,\n      frame\n    };\n  }\n  /**\n   * Returns a canvas and context to the pool.\n   *\n   * This should be called when you're done with the canvas to allow reuse\n   * and prevent memory leaks.\n   * @param canvasAndContext - The canvas and context to return to the pool\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @param text - The text to render\n   * @param style - The style of the text\n   * @param padding - The padding of the text\n   * @param resolution - The resolution of the text\n   * @param canvasAndContext - The canvas and context to render the text to\n   */\n  _renderTextToCanvas(text, style, padding, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = fontStringFromTextStyle(style);\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.textBaseline = style.textBaseline;\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured, padding * 2) : null;\n        if (style._stroke?.width) {\n          const strokePadding = style._stroke.width * 0.5 + padding * 2;\n          context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, strokePadding);\n        }\n        context.shadowColor = \"black\";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke?.width) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + padding,\n            linePositionY + padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + padding,\n            linePositionY + padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   *\n   * This method handles rendering text with the correct letter spacing, using either:\n   * 1. Native letter spacing if supported by the browser\n   * 2. Manual letter spacing calculation if not natively supported\n   *\n   * For manual letter spacing, it calculates the position of each character\n   * based on its width and the desired spacing.\n   * @param text - The text to draw\n   * @param style - The text style to apply\n   * @param canvasAndContext - The canvas and context to draw to\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Whether to render the stroke (true) or fill (false)\n   * @private\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n}\nconst CanvasTextGenerator = new CanvasTextGeneratorClass();\n\nexport { CanvasTextGenerator };\n//# sourceMappingURL=CanvasTextGenerator.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../TextStyle.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextGenerator } from './CanvasTextGenerator.mjs';\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._activeTextures = {};\n    this._renderer = _renderer;\n  }\n  getTexture(options, _resolution, _style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style: _style,\n        resolution: _resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle)) {\n      options.style = new TextStyle(options.style);\n    }\n    if (!(options.textureStyle instanceof TextureStyle)) {\n      options.textureStyle = new TextureStyle(options.textureStyle);\n    }\n    if (typeof options.text !== \"string\") {\n      options.text = options.text.toString();\n    }\n    const { text, style, textureStyle } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n      text,\n      style,\n      resolution\n    });\n    const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (style.trim) {\n      frame.pad(style.padding);\n      texture.frame.copyFrom(frame);\n      texture.frame.scale(1 / resolution);\n      texture.updateUvs();\n    }\n    if (style.filters) {\n      const filteredTexture = this._applyFilters(texture, style.filters);\n      this.returnTexture(texture);\n      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n      return filteredTexture;\n    }\n    this._renderer.texture.initSource(texture._source);\n    CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  /**\n   * Returns a texture that was created wit the above `getTexture` function.\n   * Handy if you are done with a texture and want to return it to the pool.\n   * @param texture - The texture to be returned.\n   */\n  returnTexture(texture) {\n    const source = texture.source;\n    source.resource = null;\n    source.uploadMethodId = \"unknown\";\n    source.alphaMode = \"no-premultiply-alpha\";\n    TexturePool.returnTexture(texture, true);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @deprecated since 8.10.0\n   */\n  renderTextToCanvas() {\n    deprecation(\n      \"8.10.0\",\n      \"CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead\"\n    );\n  }\n  /**\n   * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n   * @param text - The Text object that needs a texture\n   * @returns A Texture instance that represents the rendered text\n   * @remarks\n   * This method performs the following:\n   * 1. Sets the appropriate resolution based on auto-resolution settings\n   * 2. Checks if a texture already exists for the text's style\n   * 3. Creates a new texture if needed or returns an existing one\n   * 4. Manages reference counting for texture reuse\n   */\n  getManagedTexture(text) {\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    const textKey = text.styleKey;\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const texture = this.getTexture({\n      text: text.text,\n      style: text.style,\n      resolution: text._resolution,\n      textureStyle: text.textureStyle\n    });\n    this._activeTextures[textKey] = {\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  /**\n   * Decreases the reference count for a texture associated with a text key.\n   * When the reference count reaches zero, the texture is returned to the pool.\n   * @param textKey - The unique key identifying the text style configuration\n   * @remarks\n   * This method is crucial for memory management, ensuring textures are properly\n   * cleaned up when they are no longer needed by any Text instances.\n   */\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      this.returnTexture(activeTexture.texture);\n      this._activeTextures[textKey] = null;\n    }\n  }\n  /**\n   * Gets the current reference count for a texture associated with a text key.\n   * @param textKey - The unique key identifying the text style configuration\n   * @returns The number of Text instances currently using this texture\n   */\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey]?.usageCount ?? 0;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  /**\n   * Applies the specified filters to the given texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n   * texture is set to 'premultiplied-alpha'.\n   * @param {Texture} texture - The texture to which the filters will be applied.\n   * @param {Filter[]} filters - The filters to apply to the texture.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   */\n  _applyFilters(texture, filters) {\n    const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n    const resultTexture = this._renderer.filter.generateFilteredTexture({\n      texture,\n      filters\n    });\n    this._renderer.renderTarget.bind(currentRenderTarget, false);\n    return resultTexture;\n  }\n  destroy() {\n    this._renderer = null;\n    for (const key in this._activeTextures) {\n      if (this._activeTextures[key])\n        this.returnTexture(this._activeTextures[key].texture);\n    }\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexport { CanvasTextSystem };\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe.mjs';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem.mjs';\n\n\"use strict\";\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\n\"use strict\";\nclass MeshGpuData {\n  destroy() {\n  }\n}\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      if (batchableMesh.texture.uid !== mesh._texture.uid) {\n        batchableMesh._textureMatrixUpdateId = -1;\n      }\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        mesh._texture\n      );\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const meshData = this._getMeshData(mesh);\n    if (mesh.didViewUpdate) {\n      meshData.indexSize = mesh._geometry.indices?.length;\n      meshData.vertexSize = mesh._geometry.positions?.length;\n    }\n    if (meshData.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add(mesh);\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  execute(mesh) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    mesh._gpuData[this.renderer.uid].meshData = {\n      batched: mesh.batched,\n      indexSize: 0,\n      vertexSize: 0\n    };\n    return mesh._gpuData[this.renderer.uid].meshData;\n  }\n  _getBatchableMesh(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = new BatchableMesh();\n    gpuMesh.renderable = mesh;\n    gpuMesh.setTexture(mesh._texture);\n    gpuMesh.transform = mesh.groupTransform;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n    return gpuMesh;\n  }\n  destroy() {\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"mesh\"\n};\n\nexport { MeshGpuData, MeshPipe };\n//# sourceMappingURL=MeshPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { MeshPipe } from './shared/MeshPipe.mjs';\n\n\"use strict\";\nextensions.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n    if (options.blendRequired) {\n      this.addResource(\"uBackTexture\", 0, 3);\n    }\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/** The default filter settings */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\nexport { PlaneGeometry };\n//# sourceMappingURL=PlaneGeometry.mjs.map\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this._anchorX = options.anchor?.x;\n    this._anchorY = options.anchor?.y;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const p = this.positions;\n    const {\n      width,\n      height,\n      _leftWidth,\n      _rightWidth,\n      _topHeight,\n      _bottomHeight,\n      _anchorX,\n      _anchorY\n    } = this;\n    const w = _leftWidth + _rightWidth;\n    const scaleW = width > w ? 1 : width / w;\n    const h = _topHeight + _bottomHeight;\n    const scaleH = height > h ? 1 : height / h;\n    const scale = Math.min(scaleW, scaleH);\n    const anchorOffsetX = _anchorX * width;\n    const anchorOffsetY = _anchorY * height;\n    p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n    p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;\n    p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;\n    p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n    p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n    p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;\n    p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;\n    p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexport { NineSliceGeometry };\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nclass NineSliceSpriteGpuData extends BatchableMesh {\n  constructor() {\n    super();\n    this.geometry = new NineSliceGeometry();\n  }\n  destroy() {\n    this.geometry.destroy();\n  }\n}\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.setTexture(sprite._texture);\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n    const batchableMesh = gpuData;\n    batchableMesh.renderable = sprite;\n    batchableMesh.transform = sprite.groupTransform;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    if (!sprite.didViewUpdate) {\n      this._updateBatchableSprite(sprite, batchableMesh);\n    }\n    return gpuData;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexport { NineSliceSpriteGpuData, NineSliceSpritePipe };\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    )\n  }\n};\n\nexport { tilingBit, tilingBitGl };\n//# sourceMappingURL=tilingBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { tilingBit, tilingBitGl } from './tilingBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit,\n        tilingBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBitGl,\n        tilingBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup({\n      uMapCoord: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup({\n          uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.EMPTY.source,\n        uSampler: Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexport { TilingSpriteShader };\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexport { QuadGeometry };\n//# sourceMappingURL=QuadGeometry.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../rendering/renderers/shared/state/State.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader.mjs';\nimport { QuadGeometry } from './utils/QuadGeometry.mjs';\nimport { setPositions } from './utils/setPositions.mjs';\nimport { setUvs } from './utils/setUvs.mjs';\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpriteGpuData {\n  constructor() {\n    this.canBatch = true;\n    this.geometry = new MeshGeometry({\n      indices: sharedQuad.indices.slice(),\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n  }\n  destroy() {\n    this.geometry.destroy();\n    this.shader?.destroy();\n  }\n}\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._state = State.default2d;\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        renderable.texture\n      );\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite.didViewUpdate) {\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.renderable = tilingSprite;\n        batchableMesh.transform = tilingSprite.groupTransform;\n        batchableMesh.setTexture(tilingSprite._texture);\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._getTilingSpriteData(tilingSprite);\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: this._state\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite.didViewUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh._batcher.updateElement(batchableMesh);\n    } else if (tilingSprite.didViewUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n  }\n  _getTilingSpriteData(renderable) {\n    return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const gpuData = new TilingSpriteGpuData();\n    gpuData.renderable = tilingSprite;\n    tilingSprite._gpuData[this._renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexport { TilingSpriteGpuData, TilingSpritePipe };\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { applyMatrix } from './applyMatrix.mjs';\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite.applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexport { setUvs };\n//# sourceMappingURL=setUvs.mjs.map\n","\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexport { applyMatrix };\n//# sourceMappingURL=applyMatrix.mjs.map\n","\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexport { setPositions };\n//# sourceMappingURL=setPositions.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { TilingSpritePipe } from './TilingSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._textureMatrixUpdateId = -1;\n    this._uvUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get topology() {\n    return this._topology || this.geometry.topology;\n  }\n  set topology(value) {\n    this._topology = value;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */\n  setTexture(value) {\n    if (this.texture === value)\n      return;\n    this.texture = value;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexport { BatchableMesh };\n//# sourceMappingURL=BatchableMesh.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsGpuData {\n  constructor() {\n    this.batches = [];\n    this.batched = false;\n  }\n  destroy() {\n    this.batches.forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this.batches.length = 0;\n  }\n}\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!graphics._gpuData;\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics.didViewUpdate) {\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const batches = gpuData.batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batch._batcher.updateElement(batch);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    gpuData.destroy();\n    if (gpuContext.isBatchable) {\n      this._updateBatchesForRenderable(graphics, gpuData);\n    }\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getGpuDataForRenderable(graphics).batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getGpuDataForRenderable(graphics) {\n    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n  }\n  _initGpuDataForRenderable(graphics) {\n    const gpuData = new GraphicsGpuData();\n    graphics._gpuData[this.renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchesForRenderable(graphics, gpuData) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    gpuData.batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsGpuData, GraphicsPipe };\n//# sourceMappingURL=GraphicsPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nclass GlParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const state = particleContainerPipe.state;\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.resources.uTexture = container.texture._source;\n    shader.resources.uniforms = particleContainerPipe.localUniforms;\n    const gl = renderer.gl;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.shader.bind(shader);\n    renderer.state.set(state);\n    renderer.geometry.bind(buffer.geometry, shader.glProgram);\n    const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n    const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n    gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n  }\n}\n\nexport { GlParticleContainerAdaptor };\n//# sourceMappingURL=GlParticleContainerAdaptor.mjs.map\n","\"use strict\";\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  if (totalIndices > 65535) {\n    outBuffer || (outBuffer = new Uint32Array(totalIndices));\n  } else {\n    outBuffer || (outBuffer = new Uint16Array(totalIndices));\n  }\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\nexport { createIndicesForQuads };\n//# sourceMappingURL=createIndicesForQuads.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction generateParticleUpdateFunction(properties) {\n  return {\n    dynamicUpdate: generateUpdateFunction(properties, true),\n    staticUpdate: generateUpdateFunction(properties, false)\n  };\n}\nfunction generateUpdateFunction(properties, dynamic) {\n  const funcFragments = [];\n  funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n  let offset = 0;\n  for (const i in properties) {\n    const property = properties[i];\n    if (dynamic !== property.dynamic)\n      continue;\n    funcFragments.push(`offset = index + ${offset}`);\n    funcFragments.push(property.code);\n    const attributeInfo = getAttributeInfoFromFormat(property.format);\n    offset += attributeInfo.stride / 4;\n  }\n  funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n  funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n  const functionSource = funcFragments.join(\"\\n\");\n  return new Function(\"ps\", \"f32v\", \"u32v\", functionSource);\n}\n\nexport { generateParticleUpdateFunction };\n//# sourceMappingURL=generateParticleUpdateFunction.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads.mjs';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction.mjs';\n\n\"use strict\";\nclass ParticleBuffer {\n  constructor(options) {\n    this._size = 0;\n    this._generateParticleUpdateCache = {};\n    const size = this._size = options.size ?? 1e3;\n    const properties = options.properties;\n    let staticVertexSize = 0;\n    let dynamicVertexSize = 0;\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        dynamicVertexSize += attributeInfo.stride;\n      } else {\n        staticVertexSize += attributeInfo.stride;\n      }\n    }\n    this._dynamicStride = dynamicVertexSize / 4;\n    this._staticStride = staticVertexSize / 4;\n    this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n    this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n    this.indexBuffer = createIndicesForQuads(size);\n    const geometry = new Geometry();\n    let dynamicOffset = 0;\n    let staticOffset = 0;\n    this._staticBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"static-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    this._dynamicBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"dynamic-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._dynamicBuffer,\n          stride: this._dynamicStride * 4,\n          offset: dynamicOffset * 4,\n          format: property.format\n        });\n        dynamicOffset += attributeInfo.size;\n      } else {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._staticBuffer,\n          stride: this._staticStride * 4,\n          offset: staticOffset * 4,\n          format: property.format\n        });\n        staticOffset += attributeInfo.size;\n      }\n    }\n    geometry.addIndex(this.indexBuffer);\n    const uploadFunction = this.getParticleUpdate(properties);\n    this._dynamicUpload = uploadFunction.dynamicUpdate;\n    this._staticUpload = uploadFunction.staticUpdate;\n    this.geometry = geometry;\n  }\n  getParticleUpdate(properties) {\n    const key = getParticleSyncKey(properties);\n    if (this._generateParticleUpdateCache[key]) {\n      return this._generateParticleUpdateCache[key];\n    }\n    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n    return this._generateParticleUpdateCache[key];\n  }\n  generateParticleUpdate(properties) {\n    return generateParticleUpdateFunction(properties);\n  }\n  update(particles, uploadStatic) {\n    if (particles.length > this._size) {\n      uploadStatic = true;\n      this._size = Math.max(particles.length, this._size * 1.5 | 0);\n      this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n      this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n      this.indexBuffer = createIndicesForQuads(this._size);\n      this.geometry.indexBuffer.setDataWithSize(\n        this.indexBuffer,\n        this.indexBuffer.byteLength,\n        true\n      );\n    }\n    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n    this._dynamicBuffer.setDataWithSize(\n      this.dynamicAttributeBuffer.float32View,\n      particles.length * this._dynamicStride * 4,\n      true\n    );\n    if (uploadStatic) {\n      const staticAttributeBuffer = this.staticAttributeBuffer;\n      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n      this._staticBuffer.setDataWithSize(\n        staticAttributeBuffer.float32View,\n        particles.length * this._staticStride * 4,\n        true\n      );\n    }\n  }\n  destroy() {\n    this._staticBuffer.destroy();\n    this._dynamicBuffer.destroy();\n    this.geometry.destroy();\n  }\n}\nfunction getParticleSyncKey(properties) {\n  const keyGen = [];\n  for (const key in properties) {\n    const property = properties[key];\n    keyGen.push(key, property.code, property.dynamic ? \"d\" : \"s\");\n  }\n  return keyGen.join(\"_\");\n}\n\nexport { ParticleBuffer };\n//# sourceMappingURL=ParticleBuffer.mjs.map\n","var wgsl = \"\\nstruct ParticleUniforms {\\n  uTranslationMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uRound:f32,\\n  uResolution:vec2<f32>,\\n};\\n\\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\\n{\\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n   if(uniforms.uRound == 1.0) {\\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\\n   }\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\nexport { wgsl as default };\n//# sourceMappingURL=particles.wgsl.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport fragment from './particles.frag.mjs';\nimport vertex from './particles.vert.mjs';\nimport wgsl from './particles.wgsl.mjs';\n\n\"use strict\";\nclass ParticleShader extends Shader {\n  constructor() {\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment\n    });\n    const gpuProgram = GpuProgram.from({\n      fragment: {\n        source: wgsl,\n        entryPoint: \"mainFragment\"\n      },\n      vertex: {\n        source: wgsl,\n        entryPoint: \"mainVertex\"\n      }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        // this will be replaced with the texture from the particle container\n        uTexture: Texture.WHITE.source,\n        // this will be replaced with the texture style from the particle container\n        uSampler: new TextureStyle({}),\n        // this will be replaced with the local uniforms from the particle container\n        uniforms: {\n          uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Color(16777215), type: \"vec4<f32>\" },\n          uRound: { value: 1, type: \"f32\" },\n          uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n        }\n      }\n    });\n  }\n}\n\nexport { ParticleShader };\n//# sourceMappingURL=ParticleShader.mjs.map\n","var vertex = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=particles.vert.mjs.map\n","var fragment = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=particles.frag.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { ParticleBuffer } from './ParticleBuffer.mjs';\nimport { ParticleShader } from './shader/ParticleShader.mjs';\n\n\"use strict\";\nclass ParticleContainerPipe {\n  /**\n   * @param renderer - The renderer this sprite batch works for.\n   * @param adaptor\n   */\n  constructor(renderer, adaptor) {\n    /** @internal */\n    this.state = State.for2d();\n    /** Local uniforms that are used for rendering particles. */\n    this.localUniforms = new UniformGroup({\n      uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uRound: { value: 1, type: \"f32\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    });\n    this.renderer = renderer;\n    this.adaptor = adaptor;\n    this.defaultShader = new ParticleShader();\n    this.state = State.for2d();\n  }\n  validateRenderable(_renderable) {\n    return false;\n  }\n  addRenderable(renderable, instructionSet) {\n    this.renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderable);\n  }\n  getBuffers(renderable) {\n    return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n  }\n  _initBuffer(renderable) {\n    renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n      size: renderable.particleChildren.length,\n      properties: renderable._properties\n    });\n    return renderable._gpuData[this.renderer.uid];\n  }\n  updateRenderable(_renderable) {\n  }\n  execute(container) {\n    const children = container.particleChildren;\n    if (children.length === 0) {\n      return;\n    }\n    const renderer = this.renderer;\n    const buffer = this.getBuffers(container);\n    container.texture || (container.texture = children[0].texture);\n    const state = this.state;\n    buffer.update(children, container._childrenDirty);\n    container._childrenDirty = false;\n    state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n    const uniforms = this.localUniforms.uniforms;\n    const transformationMatrix = uniforms.uTranslationMatrix;\n    container.worldTransform.copyTo(transformationMatrix);\n    transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n    uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n    uniforms.uRound = renderer._roundPixels | container._roundPixels;\n    color32BitToUniform(\n      container.groupColorAlpha,\n      uniforms.uColor,\n      0\n    );\n    this.adaptor.execute(this, container);\n  }\n  /** Destroys the ParticleRenderer. */\n  destroy() {\n    this.renderer = null;\n    if (this.defaultShader) {\n      this.defaultShader.destroy();\n      this.defaultShader = null;\n    }\n  }\n}\n\nexport { ParticleContainerPipe };\n//# sourceMappingURL=ParticleContainerPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GlParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GlParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGlParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GlParticleContainerPipe };\n//# sourceMappingURL=GlParticleContainerPipe.mjs.map\n","\"use strict\";\nclass GpuParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n    shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n    const state = particleContainerPipe.state;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.encoder.draw({\n      geometry: buffer.geometry,\n      shader: container.shader || particleContainerPipe.defaultShader,\n      state,\n      size: container.particleChildren.length * 6\n    });\n  }\n}\n\nexport { GpuParticleContainerAdaptor };\n//# sourceMappingURL=GpuParticleContainerAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GpuParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GpuParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGpuParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GpuParticleContainerPipe };\n//# sourceMappingURL=GpuParticleContainerPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe.mjs';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe.mjs';\n\n\"use strict\";\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n//# sourceMappingURL=init.mjs.map\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","updateTextBounds","batchableSprite","text","texture","bounds","padding","_style","_getFinalPadding","_anchor","paddingOffset","_x","paddingOffsetY","_y","minX","minY","maxX","maxY","tempBounds","getPo2TextureFromSource","image","width","height","resolution","getOptimalTexture","source","uploadMethodId","resource","alphaMode","frame","emit","updateUvs","BatchableHTMLText","BatchableSprite","constructor","renderer","super","this","generatingTexture","currentKey","_renderer","runners","resolutionChange","add","renderable","_autoResolution","onViewUpdate","destroy","htmlText","getReferenceCount","returnTexturePromise","texturePromise","decreaseReferenceCount","remove","HTMLTextPipe","validateRenderable","gpuText","_getGpuText","newKey","styleKey","addRenderable","instructionSet","batchableHTMLText","_didTextUpdate","_updateGpuText","catch","e","console","error","renderPipes","batch","addToBatch","updateRenderable","_batcher","updateElement","oldTexturePromise","_resolution","getTexturePromise","finally","renderGroup","parentRenderGroup","structureDidChange","_gpuData","uid","initGpuText","transform","groupTransform","Texture","EMPTY","roundPixels","_roundPixels","extension","type","WebGLPipes","WebGPUPipes","CanvasPipes","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","setAttribute","style","overflow","appendChild","get","createImage","src","canvasAndContext","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_activeTextures","_createCanvas","WEBGPU","getTexture","options","getManagedTexture","textKey","_increaseReferenceCount","promise","_buildTexturePromise","then","usageCount","activeTexture","_cleanUp","warn","textureStyle","htmlTextData","fontFamilies","fontFamily","dedupe","matches","match","addFontFamily","fontFamily2","push","Array","isArray","i","length","forEach","split","trim","tagStyles","extractFontFamilies","fontCSS","async","fontPromises","filter","Cache","has","map","entries","promises","entry","url","out","faces","face","weight","dataSrc","response","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","loadFontAsBase64","fontWeight","fontStyle","loadFontCSS","set","all","css","join","getFontCss","measured","fontStyleCSS","htmlTextRenderData","innerHTML","cssStyle","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","Math","ceil","max","svgURL","toString","XMLSerializer","serializeToString","getSVGUrl","delay","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","test","isSafari","CanvasPool","getOptimalCanvasAndContext","context","clearRect","drawImage","getTemporaryCanvasFromImage","canvas","initSource","returnCanvasAndContext","return","TexturePool","returnTexture","key","WebGLSystem","WebGPUSystem","CanvasSystem","color32BitToUniform","abgr","offset","alpha","FilterPipe","filterEffect","container","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","PassthroughFilter","Filter","gpuProgram","GpuProgram","from","fragment","glProgram","GlProgram","tempProjectionMatrix","Matrix","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","indexBuffer","Uint32Array","FilterData","skip","inputTexture","backTexture","filters","Bounds","blendRequired","outputRenderSurface","globalFrame","x","y","firstEnabledIndex","lastEnabledIndex","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","filterData","_pushFilterData","renderTarget","renderSurface","colorTextureSource","colorTexture","rootResolution","rootAntialias","antialias","every","enabled","_calculateFilterArea","_calculateFilterBounds","rootViewPort","previousFilterData","_getPreviousFilterData","globalResolution","_findFilterResolution","offsetX","offsetY","_calculateGlobalFrame","_setupFilterTextures","generateFilteredTexture","addRect","rectangle","finishRenderPass","_applyFiltersToTexture","outputTexture","_popFilterData","globalUniforms","getBackTexture","lastRenderSurface","previousBounds","backgroundResolution","floor","copyToTexture","applyFilter","input","output","clear","isFinalTarget","rootRenderTarget","_findPreviousFilterOffset","_updateFilterUniforms","filterToApply","_getPassthroughFilter","_setupBindGroupsAndRender","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","_source","worldTransform","copyTo","shared","cacheToLocalTransform","prepend","invert","scale","orig","translate","anchor","_passthroughFilter","uniformBatch","batchUniforms","getUboResource","setResource","groups","encoder","draw","geometry","shader","state","_state","topology","WEBGL","getRenderTarget","bind","sourceWidth","sourceHeight","uniforms","outputFrame","inputSize","inputPixel","inputClamp","pixelWidth","pixelHeight","rootTexture","isRoot","update","currentIndex","lastIndex","prevFilterData","renderables","actualMatrix","matrix","globalDisplayStatus","isCachedAsTexture","copyFrom","textureOffsetInverseTransform","append","_parentCacheAsTextureRenderGroup","inverseWorldTransform","addBounds","getGlobalRenderableBounds","filterArea","applyMatrix","getFastGlobalBounds","filterFrameTransform","firstEnabled","lastEnabled","apply","flip","tempTexture","flop","t","viewPort","paddingMultiplier","Infinity","clipToViewport","min","compatibleRenderers","backBuffer","useBackBuffer","fitBounds","pad","isPositive","index","Graphics","ViewContainer","GraphicsContext","rest","label","_context","_ownedContext","on","didViewUpdate","allowChildren","off","updateBounds","containsPoint","point","_callContextMethod","method","args","setFillStyle","setStrokeStyle","fill","stroke","beginPath","cut","arc","arcTo","arcToSvg","bezierCurveTo","closePath","ellipse","circle","path","lineTo","moveTo","quadraticCurveTo","rect","roundRect","poly","regularPoly","roundPoly","roundShape","filletRect","chamferRect","star","svg","restore","save","getTransform","resetTransform","rotateTransform","scaleTransform","setTransform","translateTransform","fillStyle","strokeStyle","clone","deep","lineStyle","color","deprecation","beginFill","endFill","defaultStrokeStyle","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","Shader","maxTextures","uColor","uTransformMatrix","uDistance","uRound","bits","colorBit","generateTextureBatchBit","roundPixelsBit","resources","localUniforms","batchSamplers","getBatchSamplersUniformGroup","BitmapTextGraphics","customShader","BitmapTextPipe","bitmapText","graphicsRenderable","_getGpuBitmapText","graphics","syncWithProxy","_updateContext","_updateDistanceField","proxyGraphics","bitmapFont","BitmapFontManager","getFont","distanceField","limits","maxBatchableTextures","chars","CanvasTextMetrics","graphemeSegmenter","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","tx","ty","_stroke","tint","applyFillAsTint","_fill","fontSize","fontMetrics","lineHeight","linePositionYShift","lines","line","j","charPositions","char","charData","round","xOffset","yOffset","proxyRenderable","dynamicFont","a","b","c","d","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","distance","range","proxy","groupColorAlpha","groupColor","groupBlendMode","localDisplayStatus","groupAlpha","ResizePlugin","init","Object","defineProperty","configurable","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","window","innerWidth","innerHeight","clientWidth","clientHeight","render","resizeTo","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","LOW","stop","start","Ticker","oldTicker","_MeshGeometry","positions","uvs","indices","defaultOptions","shrinkToFit","shrinkBuffersToFit","usage","VERTEX","COPY_DST","aUV","INDEX","batchMode","MeshGeometry","BatchableText","canvasText","CanvasTextPipe","batchableText","_internalCanvas","_internalContext","checkRow","checkColumn","top","bottom","getCanvasBoundingBox","createCanvas","getContext","willReadFrequently","globalCompositeOperation","globalAlpha","ensureInternalCanvas","TypeError","getImageData","left","right","Rectangle","strokeRect","tempRect","CanvasTextGenerator","getCanvasAndContext","measureText","_renderTextToCanvas","font","fontStringFromTextStyle","lineWidths","maxLineWidth","fontProperties","textBaseline","lineWidth","miterLimit","lineJoin","lineCap","cap","linePositionX","linePositionY","passesCount","dropShadow","isShadowPass","dsOffsetText","dsOffsetShadow","shadowOptions","dropShadowColor","dropShadowAlpha","shadowColor","Color","setValue","setAlpha","toRgbaString","dropShadowBlur","blur","dropShadowDistance","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","getCanvasFillStyle","strokePadding","strokeWidth","i2","ascent","align","_drawLetterSpacing","isStroke","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","previousWidth","currentWidth","currentChar","textStr","CanvasTextSystem","_textKey","TextStyle","TextureStyle","filteredTexture","_applyFilters","renderTextToCanvas","currentRenderTarget","resultTexture","MeshGpuData","MeshPipe","adaptor","localUniformsBindGroup","_adaptor","mesh","meshData","_getMeshData","wasBatched","batched","isBatched","_geometry","indexSize","vertexSize","batchableMesh","_getBatchableMesh","_texture","_textureMatrixUpdateId","checkAndUpdateTexture","batcher","gpuBatchableMesh","setTexture","isRenderable","blendMode","getAdjustedBlendModeBlend","_a","_b","_initMeshData","_initBatchableMesh","gpuMesh","BatchableMesh","_Filter","for2d","addResource","filterManager","clearMode","gpu","gl","_PlaneGeometry","verticesX","verticesY","build","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updatePositions","p","w","scaleW","h","scaleH","anchorOffsetX","anchorOffsetY","getBuffer","_uvw","_uvh","NineSliceGeometry","NineSliceSpriteGpuData","NineSliceSpritePipe","gpuSprite","_getGpuSprite","_updateBatchableSprite","_initGPUSprite","gpuData","blendModeIds","normal","multiply","screen","overlay","erase","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","default2d","State","batcherName","attributeSize","packAsQuad","_attributeStart","_batch","reset","tilingBit","tilingBitGl","TilingSpriteShader","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","textureMatrix","mapCoord","QuadGeometry","sharedQuad","TilingSpriteGpuData","canBatch","slice","TilingSpritePipe","tilingSpriteData","_getTilingSpriteData","couldBatch","_updateCanBatch","tilingSprite","_updateBatchableMesh","bindGroup","_tileTransform","_initTilingSpriteData","renderableData","addressMode","applyAnchorToTexture","array","size","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo","indexOffset","attributeOffset","_uvUpdateId","_topology","uvBuffer","transformedUvs","_transformedUvs","_updateID","multiplyUvs","GraphicsGpuData","batches","GraphicsPipe","contextChange","gpuContext","graphicsContext","updateGpuContext","isBatchable","_rebuild","_addToBatcher","_getGpuDataForRenderable","getGpuContext","_updateBatchesForRenderable","batchPipe","_initGpuDataForRenderable","batchClone","BatchableGraphics","GraphicsContextSystem","GlParticleContainerAdaptor","particleContainerPipe","defaultShader","getBuffers","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","Uint16Array","Error","generateUpdateFunction","properties","dynamic","funcFragments","property","code","getAttributeInfoFromFormat","unshift","functionSource","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","Buffer","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","wgsl","ParticleShader","entryPoint","WHITE","uTranslationMatrix","uResolution","ParticleContainerPipe","_renderable","_initBuffer","_properties","children","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe"],"sourceRoot":""}